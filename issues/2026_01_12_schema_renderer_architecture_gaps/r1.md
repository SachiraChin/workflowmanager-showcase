# Architecture Gaps Analysis: CardStack Refactor (R1-R4)

## What R4 Final Architecture Specified

### Core Principle
SchemaRenderer is a **pure data extractor** that:
1. Handles null/undefined
2. Handles display_format (template collapse)
3. Detects containers → switches renderer
4. Extracts innerData from objects/arrays
5. Passes to renderer.Render with pre-rendered children
6. Falls back to TerminalRenderer

### Renderer Interface
```tsx
interface Renderer {
  slotConfigs?: SlotConfig[];  // Optional slots for grouping
  Render: FC<{ schema, children, index? }>;
  Field?: Renderer | FC;  // Per-item renderer
}

interface SlotConfig {
  name: string;
  match: (schema) => boolean;
  Slot: FC<{ children }>;
}
```

### Expected Line Counts
| Component | Expected |
|-----------|----------|
| SchemaRenderer | ~150 lines |
| CardStackRenderer | ~100 lines |
| SectionListRenderer | ~80 lines |

---

## What Was NOT Covered in R4

### 1. Display Flag Semantics
**Gap:** R4 never defined what `display: true/false/undefined` means in different contexts.

**What we assumed:** Only nodes with explicit `display: true` should render.

**Reality:**
- Array items from containers don't have `display` on the item schema
- Object properties use `display: false` to mean "invisible wrapper"
- `display: undefined` sometimes means "inherit" and sometimes "false"

**Impact:** Required `isArrayItem` hack and complex pass-through logic.

---

### 2. Renderer Priority When Parent Provides Field
**Gap:** R4 said "renderer is passed DOWN" but didn't specify what happens when child has its own `render_as`.

**What we assumed:** Child's explicit renderer always wins.

**Reality:**
- Sometimes parent's Field should wrap child's renderer (Section wrapping CardStack)
- Sometimes child's renderer should replace parent's Field (card-content replacing CardRenderer)

**Impact:** Required wrapper pattern with `isWrapper` flag.

---

### 3. Object-Mode vs Array-Mode Containers
**Gap:** R4 examples showed array-mode card-stack. Object-mode was mentioned but not architected.

**Schema patterns not covered:**
```json
// Object-mode card-stack (OMS prompts)
{
  "type": "object",
  "render_as": "card-stack",
  "properties": {
    "prompt_a": { "render_as": "card-content" }
  }
}
```

**Impact:** `card-content` became both a role type AND a registered renderer. Confusing semantics.

---

### 4. Invisible Wrapper Nodes
**Gap:** R4 didn't address schemas with intermediate objects that shouldn't render.

**Example:**
```json
{
  "render_as": "section-list",
  "properties": {
    "prompts": {          // <-- display: false, invisible wrapper
      "properties": {
        "midjourney": {}  // <-- actual content
      }
    }
  }
}
```

**Impact:** Required pass-through logic to skip wrappers while preserving parent's renderer.

---

### 5. When Slots Don't Apply
**Gap:** R4 assumed slots always work. Didn't cover when slotConfigs is undefined.

**Reality:**
- CardStackRenderer has no slots (just Render + Field)
- SectionRenderer has slots (title, badge, summary, content)

**Impact:** renderWithSlots has two branches - with slots and without. The "no slots" branch just iterates.

---

### 6. Role Type Lifecycle
**Gap:** R4 said "role types are consumed by slots" but didn't specify:
- When to strip role type from schema after consumption
- What happens to unconsumed role types
- How to handle role types that are also registered renderers

**Impact:** Added `prepareChildSchema` to strip role types, plus warning logs for unconsumed ones.

---

## Root Causes of Complexity

### 1. Schema Design Inconsistency
The workflow schemas use different patterns:
- CC uses array-mode card-stack with card-title/card-subtitle
- OMS uses object-mode card-stack with card-content
- Some schemas have display: true, some don't

**Fix needed:** Standardize schema patterns, not code workarounds.

### 2. `display` Flag Overloading
One flag means three things:
- "Show this value"
- "This is a visible container"
- "This is a structural wrapper (display: false)"

**Fix needed:** Separate concerns - maybe `visible`, `structural`, or different patterns.

### 3. Renderer vs Container Confusion
The architecture conflates:
- **Container**: Something that holds multiple items (section-list, card-stack)
- **Renderer**: Something that provides layout/styling
- **Role type**: A hint for parent's slots

**Example:** `card-content` is registered as a renderer but acts like a role type.

---

## Current SchemaRenderer Flow vs R4 Vision

### R4 Vision (Simple)
```
1. null check
2. display_format → template
3. container → switch renderer
4. extract innerData
5. renderer → renderWithSlots
6. terminal
```

### Current Reality (Complex)
```
1. null check
2. root displayable check
3. nested selectable check
4. display_format → template
5. role type warning
6. get renderer + extract innerData
7. WRAPPER PATTERN (parent.isWrapper + child.explicit)
8. determine effective renderer (explicit > parent > default)
9. PASS-THROUGH (!isArrayItem + !display + !explicit)
10. renderWithSlots
11. fallback iteration
12. terminal with strictMode check
```

Steps 7, 8, 9 were not in R4.

---

## Specific Gaps Per Architecture Section

### R4 Section: "Renderer Interface"
**Gap:** No `isWrapper` property defined.
**Added:** `isWrapper?: boolean` to distinguish Section (wraps) from Card (replaces).

### R4 Section: "Simplified SchemaRenderer"
**Gap:** Only ~60 lines of pseudocode.
**Reality:** 398 lines with multiple edge cases.

### R4 Section: "Detailed Plan of Action"
**Gap:** Plan assumed happy path. No contingency for:
- What if slots don't match anything?
- What if parent renderer conflicts with child?
- What if display flag is missing?

### R4 Section: "Risk Mitigation"
**Listed risks:**
1. Nested container switching - addressed but created wrapper pattern
2. Selection context - moved to useSelectable hook (good)
3. Slot ordering edge cases - works correctly
4. Breaking existing schemas - schemas work but code is complex

**Unlisted risks that materialized:**
- Display flag ambiguity
- Object-mode containers
- Invisible wrapper nodes
- Default renderer interference

---

## Recommendations

### Short-term (Code)
1. Document the three "modes" in SchemaRenderer clearly
2. Add comprehensive tests for edge cases
3. Consider splitting SchemaRenderer into smaller functions

### Long-term (Architecture)
1. **Standardize schemas:** Pick one pattern (array-mode OR object-mode), not both
2. **Explicit display semantics:** If structural wrapper, use different property
3. **Separate container vs renderer:** Don't register role types as renderers
4. **Revisit R4:** Update architecture doc with reality

---

## Questions for Discussion

1. Should we update schemas to be more consistent, rather than adding code complexity?
2. Is `card-content` a role type or a renderer? Should it be both?
3. Should `display: false` mean "pass through" or "hide completely"?
4. Can we eliminate the wrapper pattern by changing schema structure?
