# Issue: Simplify Version Management - Revision 5

## R4 Feedback Addressed

### 1. Keep source_type, add version_type

Keep `source_type` for the original data format. Add `version_type` for raw/flattened distinction.

**source_type** - Original data format at creation:
| Value | Meaning |
|-------|---------|
| "json" | Created from JSON dict |
| "zip" | Created from ZIP file |

Note: "stored" was never actually persisted - it's only set locally when loading existing version but the version already has its original source_type.

**version_type** (NEW) - For filtering raw vs flattened:
| Value | Meaning |
|-------|---------|
| "raw" | Original workflow (not flattened) |
| "flattened" | Derived from raw via execution_groups flattening |

**Combinations:**
- Raw versions: `source_type="json"/"zip"`, `version_type="raw"`
- Flattened versions: `source_type="json"`, `version_type="flattened"`

**Hash calculation for flattened versions:**
Flattened workflows must have `content_hash` calculated from their JSON:
```python
flattened_json = json.dumps(flattened_workflow, sort_keys=True)
content_hash = f"sha256:{hashlib.sha256(flattened_json.encode()).hexdigest()}"
```

### 2. selected_paths - is it needed?

**You're right to question this.** Let me reconsider:

The `_group_origin` metadata on individual modules already contains:
```json
{
  "group_name": "aesthetic_selection_pipeline",
  "path_name": "webui_path",
  "module_index": 0
}
```

So each module in a flattened workflow already knows which group/path it came from.

**`selected_paths` on version would be redundant** - it's just a summary of what's already in the modules.

**Decision**: Remove `selected_paths` from version schema. If UI needs to know selected paths, it can derive from `_group_origin` in the first module with that metadata.

### 3. Rename get_or_create_workflow → get_or_create_workflow_run

Agreed. This is a workflow **run**, not a workflow definition. Will include in the changes.

---

## Updated Schema

### workflow_versions (revised)

```
workflow_versions
    workflow_version_id         (existing)
    workflow_template_id        (existing)
    content_hash                (existing)
    source_type                 (existing) "json" | "zip" - original data format
    resolved_workflow           (existing)
    created_at                  (existing)

    # NEW FIELDS
    version_type                "raw" | "flattened" - NEW, for filtering
    parent_workflow_version_id  null for raw, points to raw version for flattened
    requires                    [] for raw, [{capability, priority}] for flattened
```

**Notes**:
- `source_type` is KEPT - tracks original data format (json/zip)
- `version_type` is NEW - tracks raw vs flattened for filtering
- Flattened versions always have `source_type="json"` (they're JSON serialized)
- `selected_paths` removed - redundant with `_group_origin` on modules

### workflow_runs (unchanged from r4)

```
workflow_runs
    initial_workflow_version_id   → raw version uploaded at creation
    current_workflow_version_id   → actual version being executed
```

---

## Updated Migration

```python
MIGRATION_ID = 7
DESCRIPTION = "Simplify version management: parent links, remove resolutions"

def apply(db: Database) -> None:
    """
    1. Add version_type field based on source_type
    2. Fix source_type for flattened versions (set to "json")
    3. Add parent_workflow_version_id and requires to workflow_versions
    4. Migrate data from workflow_resolutions
    5. Update workflow_runs.current_workflow_version_id
    6. Drop resolution collections
    """

    # 1. Add version_type field
    # Raw versions: source_type is "json" or "zip"
    db.workflow_versions.update_many(
        {"source_type": {"$in": ["json", "zip"]}},
        {"$set": {"version_type": "raw"}}
    )
    # Flattened versions: source_type was incorrectly "flattened", fix to "json"
    db.workflow_versions.update_many(
        {"source_type": "flattened"},
        {"$set": {"version_type": "flattened", "source_type": "json"}}
    )

    # 2. Set defaults for new fields
    db.workflow_versions.update_many(
        {"version_type": "raw"},
        {"$set": {"parent_workflow_version_id": None, "requires": []}}
    )

    # 3. Migrate parent relationships and requires from workflow_resolutions
    # Note: requires keeps original format [{capability: str, priority: int}]
    for resolution in db.workflow_resolutions.find():
        db.workflow_versions.update_one(
            {"workflow_version_id": resolution["resolved_workflow_version_id"]},
            {"$set": {
                "parent_workflow_version_id": resolution["source_workflow_version_id"],
                "requires": resolution.get("requires", [])  # Keep original format
            }}
        )

    # 4. Update workflow_runs.current_workflow_version_id to point to flattened
    for run_res in db.workflow_run_resolutions.find({"is_active": True}):
        resolution = db.workflow_resolutions.find_one({
            "workflow_resolution_id": run_res["workflow_resolution_id"]
        })
        if resolution:
            db.workflow_runs.update_one(
                {"workflow_run_id": run_res["workflow_run_id"]},
                {"$set": {
                    "current_workflow_version_id": resolution["resolved_workflow_version_id"]
                }}
            )

    # 5. Drop resolution collections
    db.workflow_resolutions.drop()
    print("  Dropped collection: workflow_resolutions")
    db.workflow_run_resolutions.drop()
    print("  Dropped collection: workflow_run_resolutions")

    # 6. Create indexes
    ensure_index(db.workflow_versions, "parent_workflow_version_id")
    ensure_index(db.workflow_versions, "version_type")

    print("  Migration 7 complete: version management simplified")
```

---

## Code Changes Summary

### database_provider.py

**Rename**:
- `get_or_create_workflow()` → `get_or_create_workflow_run()`

**Remove**:
- `create_workflow_run_resolution()`
- `get_active_run_resolution()`
- `select_resolution_for_capabilities()`
- `switch_run_resolution()`
- `load_workflow_for_start()`

**Add**:
```python
def get_flattened_version_for_capabilities(
    self,
    raw_version_id: str,
    capabilities: List[str]
) -> Optional[Dict]:
    """Find best flattened version for given capabilities."""
    pipeline = [
        {"$match": {
            "parent_workflow_version_id": raw_version_id,
            "version_type": "flattened"
        }},
        {"$match": {
            "$expr": {
                "$setIsSubset": [
                    {"$ifNull": ["$requires", []]},
                    capabilities
                ]
            }
        }},
        {"$addFields": {
            "specificity": {"$size": {"$ifNull": ["$requires", []]}}
        }},
        {"$sort": {"specificity": -1}},
        {"$limit": 1}
    ]
    results = list(self.workflow_versions.aggregate(pipeline))
    return results[0] if results else None


def get_version_with_parent(self, version_id: str) -> Optional[Dict]:
    """Get version with its parent (if flattened)."""
    pipeline = [
        {"$match": {"workflow_version_id": version_id}},
        {"$lookup": {
            "from": "workflow_versions",
            "localField": "parent_workflow_version_id",
            "foreignField": "workflow_version_id",
            "as": "parent"
        }},
        {"$addFields": {
            "parent_version": {"$arrayElemAt": ["$parent", 0]}
        }},
        {"$project": {"parent": 0}}
    ]
    results = list(self.workflow_versions.aggregate(pipeline))
    return results[0] if results else None
```

### workflow_processor.py

**Update start_workflow()**:
```python
def start_workflow(self, ...):
    workflow_run_id, is_new, template_id, version_changed = \
        self.db.get_or_create_workflow_run(...)  # renamed

    workflow = self.db.get_workflow(workflow_run_id)
    raw_version_id = workflow["initial_workflow_version_id"]

    # Find flattened version if capabilities provided
    flattened = None
    if capabilities:
        flattened = self.db.get_flattened_version_for_capabilities(
            raw_version_id, capabilities
        )

    if flattened:
        active_version_id = flattened["workflow_version_id"]
        workflow_def = flattened["resolved_workflow"]
    else:
        active_version_id = raw_version_id
        workflow_def = self.db.get_resolved_workflow(raw_version_id)

    # Update to actual version being executed
    if active_version_id != raw_version_id:
        self.db.workflow_runs.update_one(
            {"workflow_run_id": workflow_run_id},
            {"$set": {"current_workflow_version_id": active_version_id}}
        )

    # Continue execution...
```

### workflow_api.py /definition endpoint

```python
@router.get("/{workflow_run_id}/definition")
async def get_workflow_definition(workflow_run_id: str, ...):
    workflow = db.get_workflow(workflow_run_id)
    version_id = workflow["current_workflow_version_id"]

    result = db.get_version_with_parent(version_id)
    if not result:
        raise HTTPException(404, "Version not found")

    response = {
        "workflow_run_id": workflow_run_id,
        "version_id": version_id,
        "definition": result["resolved_workflow"],
    }

    # Include raw definition if this is flattened
    if result.get("parent_version"):
        response["raw_definition"] = result["parent_version"]["resolved_workflow"]

    return response
```

### execution_groups.py

Update `flatten_workflow()` to NOT add `selected_paths` to module `_group_origin` (it already has `group_name` and `path_name`).

No changes needed - the existing `_group_origin` metadata is sufficient.

---

## Files Affected

| File | Changes |
|------|---------|
| `database_provider.py` | Rename method, remove resolution methods, add version methods |
| `database_history.py` | Update version creation for new schema |
| `workflow_processor.py` | Use renamed method, simplified version selection |
| `workflow_api.py` | Update /definition endpoint |
| `migrations/m_7.py` | New migration |

---

## Questions for Review

1. ~~Should `requires` store just capability strings, or include priority for scoring?~~
   - **Decision**: Keep original format `[{capability: str, priority: int}]` for weighted scoring
   - This matches how it's used in OMS workflow (`07_aesthetic_selection_group.json`)

---

## Plan of Action (POA)

### Phase 1: Database Migration
1. Create `server/migrations/m_7.py`
   - Add `version_type` field to all workflow_versions
   - Fix `source_type` for flattened versions (change "flattened" → "json")
   - Add `parent_workflow_version_id` and `requires` fields
   - Migrate parent relationships from workflow_resolutions
   - Update workflow_runs.current_workflow_version_id from active resolutions
   - Drop workflow_resolutions and workflow_run_resolutions collections
   - Create indexes

### Phase 2: Database Provider Updates
2. Update `server/api/database_provider.py`
   - Rename `get_or_create_workflow()` → `get_or_create_workflow_run()`
   - Add `get_flattened_version_for_capabilities()` method
   - Add `get_version_with_parent()` method
   - Remove resolution methods:
     - `create_workflow_run_resolution()`
     - `get_active_run_resolution()`
     - `select_resolution_for_capabilities()`
     - `switch_run_resolution()`
     - `load_workflow_for_start()`

### Phase 3: Version Creation Updates
3. Update `server/api/database_history.py`
   - Update `create_workflow_version()` to set `version_type`
   - Update flattened version creation to set parent link and requires

### Phase 4: Workflow Processor Updates
4. Update `server/engine/workflow_processor.py`
   - Update `start_workflow()` to use new version selection
   - Update `resume_with_update()` to use new approach
   - Replace `get_or_create_workflow` calls with `get_or_create_workflow_run`

### Phase 5: API Updates
5. Update `server/api/workflow_api.py`
   - Update `/definition` endpoint to use `get_version_with_parent()`
   - Update any other endpoints using resolution system
   - Replace `get_or_create_workflow` calls

### Phase 6: Testing & Cleanup
6. Test the changes
   - Run migration on test database
   - Test workflow start with capabilities
   - Test /definition endpoint returns both raw and flattened
   - Verify existing workflows still work

### Execution Order
```
m_7.py → database_provider.py → database_history.py → workflow_processor.py → workflow_api.py → test
```
