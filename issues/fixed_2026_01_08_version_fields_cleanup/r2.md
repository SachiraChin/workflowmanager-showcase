# Issue: workflow_runs Version Fields Not Removed Per Architecture - Revision 2

## Summary

R1 feedback incorporated:
1. Resolution lookup must work for both flattened and non-flattened workflows
2. Use MongoDB pipelines instead of nested Python code
3. Priority: workflow creation → run creation → start/resume (critical path first)
4. No backwards compatibility fallback - focus on correct new implementation
5. In-depth analysis of all field usages required

---

## In-Depth Field Usage Analysis

### Field: `initial_workflow_version_id`

| Location | Line | Operation | Context | Current Behavior |
|----------|------|-----------|---------|------------------|
| `database_provider.py` | 515 | WRITE | Run creation | Set to source version_id when creating new run |
| `database_provider.py` | 664 | READ | Event logging | Fallback if `current_workflow_version_id` missing |
| `database_provider.py` | 1842 | READ | Status recovery | Fallback for version lookup |
| `workflow_processor.py` | 184 | READ | Start workflow | Fallback for resolution lookup |
| `workflow_api.py` | 890 | READ | `/definition` | Fallback for definition lookup |
| `workflow_api.py` | 1116 | READ | Resume | Fallback for stored definition |
| `workflow_api.py` | 1676 | READ | Status display | Fallback for workflow config |

**Analysis**: This field stores the **source** version at run creation time. It's used as fallback when `current_workflow_version_id` is not set.

### Field: `current_workflow_version_id`

| Location | Line | Operation | Context | Current Behavior |
|----------|------|-----------|---------|------------------|
| `database_provider.py` | 455 | READ | Update existing | Check if version changed |
| `database_provider.py` | 474 | WRITE | Update existing | Update version when workflow updated |
| `database_provider.py` | 516 | WRITE | Run creation | Set to same as `initial_workflow_version_id` |
| `database_provider.py` | 663 | READ | Event logging | Get version for event tagging |
| `database_provider.py` | 1513 | READ | Status response | Include in status data |
| `database_provider.py` | 1841 | READ | Status recovery | Get version for workflow definition |
| `workflow_processor.py` | 184 | READ | Start workflow | Primary source for resolution lookup |
| `workflow_processor.py` | 350 | WRITE | Resume with update | Update to new version after workflow file update |
| `workflow_api.py` | 890 | READ | `/definition` | Primary source for definition lookup |
| `workflow_api.py` | 1116 | READ | Resume | Primary source for stored definition |
| `workflow_api.py` | 1676 | READ | Status display | Primary source for workflow config |

**Analysis**: This field is meant to track "current" version (can change on resume_with_update), but **always points to source version, never flattened**. This is the core bug.

---

## Critical Path Analysis

### Priority 1: Workflow Run Creation (`database_provider.py:510-521`)

**Current code:**
```python
workflow_run = {
    "workflow_run_id": workflow_run_id,
    # ...
    "initial_workflow_version_id": version_id,  # source version
    "current_workflow_version_id": version_id,  # same as initial
    # ...
}
```

**Problem**: Sets both to source version. No resolution created at this point.

**New behavior needed**:
1. At run creation, don't set these fields (or set to None)
<!--explain the difference between above and below. isnt this 
    happening on same endpoint (/start) or am i missing something here?
-->
2. Resolution is created when `start()` is called
3. `workflow_run_resolutions` entry links run to resolution

**Replacement approach**:
- Remove these fields from initial run document
- Add `workflow_template_id` (already exists) - needed for resolution lookup
<!--why do we lookup from workflow_template_id? this is very highlevel 
    construct which is not reliable at all for situations like this.
    may be this is not discussed in original docs, but i need concrete
    info about this before proceeding
-->
- Resolution created in `start()` will link run to correct flattened version

### Priority 2: Start Workflow (`workflow_processor.py:182-220`)

**Current code:**
```python
workflow = self.db.get_workflow(workflow_run_id)
source_version_id = workflow.get("current_workflow_version_id") or workflow.get("initial_workflow_version_id")

if source_version_id and workflow_template_id and capabilities:
    result = self.db.load_workflow_for_start(source_version_id, capabilities)
    if result and result.get("is_flattened"):
        workflow_def = result["resolved_workflow"]
        # Creates workflow_run_resolution entry
        self.db.create_run_resolution(...)
```

**Problem**: Gets source_version_id from deprecated fields, then uses it for resolution lookup.

**New behavior needed**:
1. Get source version from `workflow_versions` via `workflow_template_id`
<!--same issue i mentioned above about workflow_template_id-->
2. Use `load_workflow_for_start()` (already uses resolution system)
3. `workflow_run_resolutions` becomes the authority for which version run uses

**Key insight**: `load_workflow_for_start()` already implements resolution selection correctly. The issue is just where the source_version_id comes from.

### Priority 3: Resume Workflow (`workflow_api.py:1110-1160`)

**Current code:**
```python
workflow = db.get_workflow(workflow_run_id)
version_id = workflow.get("current_workflow_version_id") or workflow.get("initial_workflow_version_id")
version = db.get_workflow_version_by_id(version_id)
workflow_def = version.get("resolved_workflow")
```

**Problem**: Gets version from deprecated fields. Returns source version, not flattened.

**New behavior needed**:
1. Look up active resolution from `workflow_run_resolutions`
2. Get `resolved_workflow_version_id` from resolution
3. Load flattened workflow from that version

### Priority 4: Resume with Update (`workflow_processor.py:340-380`)

**Current code:**
```python
# Creates new workflow version
workflow_version_id, template_id, is_new = self.db.get_or_create_workflow_version(...)

# Updates deprecated field
self.db.workflow_runs.update_one(
    {"workflow_run_id": workflow_run_id},
    {"$set": {"current_workflow_version_id": workflow_version_id}}
)

# Then does resolution lookup
if capabilities and workflow_template_id:
    selected_resolution = self.db.select_resolution_for_capabilities(...)
    self.db.switch_run_resolution(...)  # Creates new workflow_run_resolution
```

**Problem**: Still updates deprecated field even though resolution system handles it.

**New behavior needed**:
1. Create new workflow version (keep)
2. Remove the `$set` of `current_workflow_version_id`
3. `switch_run_resolution()` already handles linking run to new resolution

---

## MongoDB Pipeline for Resolution Lookup

Single pipeline to get workflow definition for a run:

```python
def get_workflow_definition_for_run(self, workflow_run_id: str) -> Optional[Dict]:
    """
    Get the resolved workflow definition for a run via resolution system.
    Works for both flattened and non-flattened workflows.

    Returns:
        Dict with: resolved_workflow, source_version_id, resolved_version_id,
                   selected_paths (if flattened), is_flattened
    """
    pipeline = [
        # Start with the workflow run
        {"$match": {"workflow_run_id": workflow_run_id}},

        # Lookup active run_resolution
        {"$lookup": {
            "from": "workflow_run_resolutions",
            "let": {"run_id": "$workflow_run_id"},
            "pipeline": [
                {"$match": {
                    "$expr": {"$eq": ["$workflow_run_id", "$$run_id"]},
                    "is_active": True
                }}
            ],
            "as": "run_resolution"
        }},
        {"$addFields": {
            "active_run_resolution": {"$arrayElemAt": ["$run_resolution", 0]}
        }},

        # Lookup the resolution details
        {"$lookup": {
            "from": "workflow_resolutions",
            "let": {"res_id": "$active_run_resolution.workflow_resolution_id"},
            "pipeline": [
                {"$match": {
                    "$expr": {"$eq": ["$workflow_resolution_id", "$$res_id"]}
                }}
            ],
            "as": "resolution"
        }},
        {"$addFields": {
            "resolution": {"$arrayElemAt": ["$resolution", 0]}
        }},

        # Lookup the resolved (flattened) workflow version
        {"$lookup": {
            "from": "workflow_versions",
            "let": {"version_id": "$resolution.resolved_workflow_version_id"},
            "pipeline": [
                {"$match": {
                    "$expr": {"$eq": ["$workflow_version_id", "$$version_id"]}
                }}
            ],
            "as": "resolved_version"
        }},
        {"$addFields": {
            "resolved_version": {"$arrayElemAt": ["$resolved_version", 0]}
        }},

        # Also lookup source version for reference
        {"$lookup": {
            "from": "workflow_versions",
            "let": {"version_id": "$resolution.source_workflow_version_id"},
            "pipeline": [
                {"$match": {
                    "$expr": {"$eq": ["$workflow_version_id", "$$version_id"]}
                }}
            ],
            "as": "source_version"
        }},
        {"$addFields": {
            "source_version": {"$arrayElemAt": ["$source_version", 0]}
        }},

        # Project final result
        {"$project": {
            "_id": 0,
            "workflow_run_id": 1,
            "workflow_template_id": 1,
            "resolved_workflow": "$resolved_version.resolved_workflow",
            "source_workflow": "$source_version.resolved_workflow",
            "resolved_version_id": "$resolution.resolved_workflow_version_id",
            "source_version_id": "$resolution.source_workflow_version_id",
            "selected_paths": "$resolution.selected_paths",
            "is_flattened": {
                "$ne": [
                    "$resolution.resolved_workflow_version_id",
                    "$resolution.source_workflow_version_id"
                ]
            }
        }}
    ]

    results = list(self.workflow_runs.aggregate(pipeline))
    return results[0] if results else None
```

**Key features:**
1. Single pipeline, no nested Python calls
2. Handles both flattened and non-flattened (when `resolved_workflow_version_id == source_workflow_version_id`)
3. Returns both source and resolved workflows for UI needs
4. Declarative and easy to debug

---

## What About Workflows Without Groups?

For workflows without `pipeline.execution_groups`:

1. **At upload**: `process_and_store_workflow_resolutions()` creates a **passthrough resolution**:
   - `source_workflow_version_id` = version_id
   - `resolved_workflow_version_id` = same version_id
   - `requires` = []
   - `selected_paths` = {}

2. **At start**: Resolution lookup finds the passthrough resolution (empty requires matches any capabilities)

3. **At runtime**: `workflow_run_resolutions` points to the passthrough resolution

**Result**: Same code path for both flattened and non-flattened workflows. The pipeline above handles both cases via `is_flattened` field.

<!--I think we need better solution for this, this sounds like patch to make this 
kind of workflow work with new implementation. dont get stuck with what we have now,
its kind of broken anyways, give me few proposals on how to do this. I am willing to 
change almost anything (given things are messed up already) to do things right. This 
applies for all comments I added above. -->
---

## Implementation Plan

### Phase 1: Add New Pipeline Method

Add `get_workflow_definition_for_run()` to `database_provider.py` without removing old code yet.

### Phase 2: Update Critical Path (One at a Time)

**Order:**
1. `workflow_processor.py:start()` - Use pipeline instead of deprecated fields
2. `workflow_api.py:resume()` - Use pipeline for getting workflow definition
3. `workflow_processor.py:resume_with_update()` - Remove `$set` of deprecated field
4. `database_provider.py:create_or_update_workflow()` - Stop setting deprecated fields

**For each change:**
- Make the change
- Test with new workflow
- Verify resolution system is working

### Phase 3: Update Secondary Usages

1. `database_provider.py:add_event()` - Get version from resolution
2. `database_provider.py:get_workflow_status()` - Remove field from response
3. `database_provider.py:check_workflow_status_recovery()` - Use resolution lookup
4. `workflow_api.py:/definition` - Use pipeline
5. `workflow_api.py:status_display` - Use pipeline

### Phase 4: Migration

Create `m_7.py`:
```python
def apply(db: Database) -> None:
    # Drop the deprecated fields
    db.workflow_runs.update_many(
        {},
        {"$unset": {
            "initial_workflow_version_id": "",
            "current_workflow_version_id": ""
        }}
    )

    # Drop indexes
    try:
        db.workflow_runs.drop_index("initial_workflow_version_id_1")
        db.workflow_runs.drop_index("current_workflow_version_id_1")
    except:
        pass
```

---

## Files Affected

| File | Changes |
|------|---------|
| `database_provider.py` | Add pipeline method, update 7 usages |
| `workflow_processor.py` | Update 2 usages (start, resume_with_update) |
| `workflow_api.py` | Update 3 usages (definition, resume, status) |
| `migrations/m_7.py` | New - drop deprecated fields |

---

## Questions for Review

1. Is the passthrough resolution approach correct for non-group workflows?
2. Should the pipeline also return `client_capabilities` from `workflow_run_resolutions`?
3. Do we need to verify passthrough resolutions exist for all existing workflows before Phase 4?
