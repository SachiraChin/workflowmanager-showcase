# Issue: Simplify Version Management - Revision 4

## Summary

Previous proposals added complexity on top of existing mess. This revision proposes a simpler approach: extend `workflow_versions` with parent tracking and remove the resolution system entirely.

---

## The Simpler Solution

### 1. Extend workflow_versions

```
workflow_versions
    workflow_version_id         (existing)
    workflow_template_id        (existing)
    content_hash                (existing)
    <!--On below, I assume you meant rename to version_type -->
    source_type                 (existing - rename to "raw"/"flattened")
    resolved_workflow           (existing)
    created_at                  (existing)

    # NEW FIELDS
    version_type                "raw" | "flattened"
    parent_workflow_version_id  null for raw, points to raw version for flattened
    <!--Not sure if I understand the need of selected_paths. In this doc, I didnt see
        any use of having this field in the collection. -->
    selected_paths              {} for raw, {group_name: path_name} for flattened
    requires                    [] for raw, capability requirements for flattened
```

### 2. Keep version fields on workflow_runs (use correctly)

```
workflow_runs
    initial_workflow_version_id   → raw version uploaded at creation
    current_workflow_version_id   → ACTUAL version being executed
                                    (flattened for grouped, raw for non-grouped)
```

**Key change**: `current_workflow_version_id` now points to the REAL version being executed, not always the raw version.

### 3. Remove resolution system

**Delete**:
- `workflow_resolutions` collection
- `workflow_run_resolutions` collection
- All resolution-related methods

**Why it's not needed**:
- Flattening is deterministic at upload time
- At runtime, we just need to pick correct flattened version
- Parent link on workflow_version provides the raw→flattened relationship
- No need for separate resolution tracking

---

## Data Flow

### Upload Flow

```
User uploads workflow JSON
    │
    ├── Create raw workflow_version
    │   version_type: "raw"
    │   parent_workflow_version_id: null
    │
    └── If has execution_groups:
        │
        └── For each flattened combination:
            Create flattened workflow_version
                version_type: "flattened"
                parent_workflow_version_id: raw_version_id
                selected_paths: {group_name: path_name}
                requires: [capabilities needed]
```

### Start Flow

```
POST /workflow/start with capabilities
    │
    ├── Get or create workflow_run
    │   initial_workflow_version_id: raw_version_id
    │
    ├── Find best flattened version for capabilities
    │   SELECT * FROM workflow_versions
    │   WHERE parent_workflow_version_id = raw_version_id
    │     AND version_type = "flattened"
    │     AND requires is subset of client_capabilities
    │   ORDER BY length(requires) DESC  -- most specific first
    │
    └── Set current_workflow_version_id
        - If flattened found: use flattened version
        - If no groups/no match: use raw version (same as initial)
```

### Definition Endpoint

```
GET /workflow/{run_id}/definition
    │
    ├── Get run.current_workflow_version_id
    │
    ├── Get workflow_version
    │
    └── If version_type == "flattened":
        │   Also get parent (raw) version
        │   Return both
        └── Else:
            Return just raw version
```

**Response**:
```json
{
  "workflow_run_id": "...",
  "version_id": "...",
  "definition": { /* flattened or raw workflow */ },
  "raw_definition": { /* raw workflow, only if different */ },
  "selected_paths": { /* only if flattened */ }
}
```

---

## Database Changes

### Migration m_7.py

```python
def apply(db: Database) -> None:
    """
    Simplify version management:
    1. Add new fields to workflow_versions
    2. Migrate existing flattened versions to use new fields
    3. Drop resolution collections
    """

    # 1. Add version_type field (default to "raw" for existing)
    db.workflow_versions.update_many(
        {"version_type": {"$exists": False}},
        {"$set": {"version_type": "raw", "parent_workflow_version_id": None}}
    )

    # 2. Update flattened versions (source_type="flattened")
    db.workflow_versions.update_many(
        {"source_type": "flattened"},
        {"$set": {"version_type": "flattened"}}
    )

    # 3. Migrate parent relationships from workflow_resolutions
    for resolution in db.workflow_resolutions.find():
        db.workflow_versions.update_one(
            {"workflow_version_id": resolution["resolved_workflow_version_id"]},
            {"$set": {
                "parent_workflow_version_id": resolution["source_workflow_version_id"],
                "selected_paths": resolution.get("selected_paths", {}),
                "requires": [r["capability"] for r in resolution.get("requires", [])]
            }}
        )

    # 4. Update workflow_runs.current_workflow_version_id
    # For runs with active resolution, point to flattened version
    for run_res in db.workflow_run_resolutions.find({"is_active": True}):
        resolution = db.workflow_resolutions.find_one({
            "workflow_resolution_id": run_res["workflow_resolution_id"]
        })
        if resolution:
            db.workflow_runs.update_one(
                {"workflow_run_id": run_res["workflow_run_id"]},
                {"$set": {
                    "current_workflow_version_id": resolution["resolved_workflow_version_id"]
                }}
            )

    # 5. Drop resolution collections
    db.workflow_resolutions.drop()
    db.workflow_run_resolutions.drop()

    # 6. Create index on parent_workflow_version_id
    db.workflow_versions.create_index("parent_workflow_version_id")
    db.workflow_versions.create_index("version_type")
```

---

## Code Changes

### database_provider.py

**Remove**:
- `create_workflow_run_resolution()`
- `get_active_run_resolution()`
- `select_resolution_for_capabilities()`
- `switch_run_resolution()`
- `load_workflow_for_start()` (replace with simpler version)

**Add**:
```python
def get_flattened_version_for_capabilities(
    self,
    raw_version_id: str,
    capabilities: List[str]
) -> Optional[Dict]:
    """
    Find best flattened version for given capabilities.
    Returns flattened version or None if no flattening needed.
    """
    pipeline = [
        {"$match": {
            "parent_workflow_version_id": raw_version_id,
            "version_type": "flattened"
        }},
        # Filter: requires must be subset of capabilities
        {"$match": {
            "$expr": {
                "$setIsSubset": [
                    {"$ifNull": ["$requires", []]},
                    capabilities
                ]
            }
        }},
        # Score by specificity (more requirements = better match)
        {"$addFields": {
            "specificity": {"$size": {"$ifNull": ["$requires", []]}}
        }},
        {"$sort": {"specificity": -1}},
        {"$limit": 1}
    ]

    results = list(self.workflow_versions.aggregate(pipeline))
    return results[0] if results else None

def get_workflow_with_parent(self, version_id: str) -> Dict:
    """
    Get workflow version with its parent (if flattened).
    Returns: {version, parent_version (or None)}
    """
    version = self.get_workflow_version_by_id(version_id)
    if not version:
        return None

    parent = None
    if version.get("version_type") == "flattened":
        parent = self.get_workflow_version_by_id(
            version["parent_workflow_version_id"]
        )

    return {
        "version": version,
        "parent_version": parent
    }
```

### workflow_processor.py

**Simplify start_workflow()**:
```python
def start_workflow(self, ...):
    # Create or get run (sets initial_workflow_version_id to raw)
    workflow_run_id, is_new, template_id, version_changed = \
        <!--trivial but we should really rename get_or_create_workflow 
        to get_or_create_workflow_run -->
        self.db.get_or_create_workflow(...)

    workflow = self.db.get_workflow(workflow_run_id)
    raw_version_id = workflow["initial_workflow_version_id"]

    # Find best flattened version for capabilities
    flattened = self.db.get_flattened_version_for_capabilities(
        raw_version_id, capabilities
    )

    if flattened:
        # Use flattened version
        active_version_id = flattened["workflow_version_id"]
        workflow_def = flattened["resolved_workflow"]
    else:
        # No flattening needed, use raw
        active_version_id = raw_version_id
        workflow_def = self.db.get_resolved_workflow(raw_version_id)

    # Update current_workflow_version_id to actual version
    self.db.workflow_runs.update_one(
        {"workflow_run_id": workflow_run_id},
        {"$set": {"current_workflow_version_id": active_version_id}}
    )

    # Continue with workflow_def...
```

### workflow_api.py

**Update /definition endpoint**:
```python
@router.get("/{workflow_run_id}/definition")
async def get_workflow_definition(workflow_run_id: str, ...):
    workflow = db.get_workflow(workflow_run_id)
    version_id = workflow["current_workflow_version_id"]

    result = db.get_workflow_with_parent(version_id)
    version = result["version"]
    parent = result["parent_version"]

    response = {
        "workflow_run_id": workflow_run_id,
        "version_id": version_id,
        "definition": version["resolved_workflow"],
    }

    if parent:
        response["raw_definition"] = parent["resolved_workflow"]
        response["selected_paths"] = version.get("selected_paths", {})

    return response
```

---

## Benefits

1. **Simpler model**: Parent-child relationship on versions is intuitive
2. **No resolution tables**: Removes two collections and all related code
3. **Direct lookups**: Version ID on run points to actual version
4. **Clear semantics**:
   - `initial_workflow_version_id` = raw version at creation
   - `current_workflow_version_id` = version being executed
5. **Easy definition lookup**: If flattened, follow parent link for raw

---

## Files Affected

| File | Changes |
|------|---------|
| `database_provider.py` | Remove resolution methods, add simpler version methods |
| `database_history.py` | Update version creation to set new fields |
| `workflow_processor.py` | Simplify start/resume to use new version lookup |
| `workflow_api.py` | Update /definition endpoint |
| `execution_groups.py` | Update flattening to set parent_workflow_version_id |
| `migrations/m_7.py` | Migrate data, drop resolution collections |

---

## Questions for Review

1. Should we keep `source_type` field or replace it entirely with `version_type`?
2. For `requires` on flattened versions, store as array of strings or array of {capability, priority}?
3. Do we need to keep any audit trail of version changes, or is the simpler model sufficient?
