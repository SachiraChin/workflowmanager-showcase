# Issue: Remove initial_workflow_version_id and Simplify Version Types - R2

## Summary

`initial_workflow_version_id` is incorrectly used and causes major issues. The field adds confusion with no real value. This issue removes it entirely and clarifies version type semantics.

## Root Cause

The dual-field approach (`initial_workflow_version_id` + `current_workflow_version_id`) creates confusion about which version to use and when. The system incorrectly allows `unresolved` versions to be associated with workflow runs.

## Changes

### 1. Remove initial_workflow_version_id

- Remove `initial_workflow_version_id` from `workflow_runs` collection
- Only `current_workflow_version_id` remains
- `current_workflow_version_id` is the version currently used by the workflow run

### 2. Version Type Clarification

| Type | Description | Can Run? |
|------|-------------|----------|
| `raw` | Workflow without execution groups | Yes |
| `unresolved` | Workflow with execution groups, not flattened | **No** |
| `resolved` | Flattened workflow from unresolved (renamed from `flattened`) | Yes |

**Type derivation:**
- If a version has flattened children → type is `unresolved`
- If a version has no flattened children and no execution groups → type is `raw`
- If a version is flattened from a parent → type is `resolved`

### 3. Strict Version Type Validation

- `current_workflow_version_id` must ALWAYS point to `raw` or `resolved` version
- If `unresolved` version is ever returned for a workflow run, throw immediately
- No attempt to default or recover - fail fast

### 4. New Collection: workflow_run_version_history

Track version usage for audit purposes:

```
workflow_run_version_history
    workflow_run_id                 string
    workflow_version_id             string (raw or resolved only)
    client_capabilities             string[] (capabilities sent by client)
    workflow_version_requirements   array of {capability: string, priority: int}
                                    (from resolved version's "requires" field, empty for raw)
    created_at                      datetime
```

**Rules:**
- Insert only, never update
- Created when:
  - New workflow_run is created
  - Workflow run switches to new version (resume with update)
- `workflow_version_id` is always the version used to run (raw or resolved), never unresolved
- `workflow_version_requirements` populated from version's `requires` field (only for resolved versions, empty for raw)

## Migration (m_8)

### Step 1: Rename flattened → resolved
```python
db.workflow_versions.update_many(
    {"version_type": "flattened"},
    {"$set": {"version_type": "resolved"}}
)
```

### Step 2: Set parent versions to unresolved
For each resolved version, look up its parent and set parent's type to `unresolved`:
```python
for resolved in db.workflow_versions.find({"version_type": "resolved"}):
    parent_id = resolved.get("parent_workflow_version_id")
    if parent_id:
        db.workflow_versions.update_one(
            {"workflow_version_id": parent_id},
            {"$set": {"version_type": "unresolved"}}
        )
```

### Step 3: Migrate existing workflow_runs to history table
For each workflow_run with `current_workflow_version_id`:
1. Look up the version
2. If version is `resolved` → add to history table with `requires` as `workflow_version_requirements`
3. If version is `raw`:
   - Check if flattened/resolved versions exist for this raw version
   - If yes → reference is broken, skip (don't add to history)
   - If no → add to history table (workflow_version_requirements = empty)
4. `client_capabilities` = empty (data is lost)

```python
for run in db.workflow_runs.find({"current_workflow_version_id": {"$exists": True}}):
    version_id = run["current_workflow_version_id"]
    version = db.workflow_versions.find_one({"workflow_version_id": version_id})

    if not version:
        continue  # Skip broken reference

    version_type = version.get("version_type")

    if version_type == "resolved":
        # Valid - add to history
        db.workflow_run_version_history.insert_one({
            "workflow_run_id": run["workflow_run_id"],
            "workflow_version_id": version_id,
            "client_capabilities": [],  # Lost
            "workflow_version_requirements": version.get("requires", []),
            "created_at": run.get("created_at", datetime.utcnow())
        })
    elif version_type == "raw":
        # Check if resolved versions exist for this raw version
        has_resolved = db.workflow_versions.find_one({
            "parent_workflow_version_id": version_id,
            "version_type": "resolved"
        })
        if has_resolved:
            # Broken reference - skip
            continue
        else:
            # Valid raw workflow - add to history
            db.workflow_run_version_history.insert_one({
                "workflow_run_id": run["workflow_run_id"],
                "workflow_version_id": version_id,
                "client_capabilities": [],
                "workflow_version_requirements": [],  # Raw has no requirements
                "created_at": run.get("created_at", datetime.utcnow())
            })
```

### Step 4: Remove initial_workflow_version_id field
```python
db.workflow_runs.update_many(
    {},
    {"$unset": {"initial_workflow_version_id": ""}}
)
```

### Step 5: Create index
```python
db.workflow_run_version_history.create_index("workflow_run_id")
```

## Files Affected

| File | Changes |
|------|---------|
| `server/api/database_provider.py` | Remove initial_workflow_version_id handling, add version history methods, add version type validation |
| `server/api/database_history.py` | Update version creation for new types |
| `server/api/workflow_processor.py` | Add version type validation on load |
| `server/api/workflow_api.py` | Update endpoints |
| `server/api/migrations/m_8.py` | New migration |

## Priority

**Critical** - Current implementation causes workflow execution failures.

---

## Plan of Action (POA) - Part A: API Endpoint Refactoring

This must be done FIRST to clean up the messy endpoint logic before continuing with version field changes.

### Problem Statement

Current `/start` endpoint handles two different flows in one endpoint:
1. Start with uploaded content
2. Start with existing version_id

This creates ambiguity (what if both provided?), duplicate logic, and messy code.

### New Endpoint Structure

| Endpoint | Input | Purpose |
|----------|-------|---------|
| `POST /start/{version_id}` | version_id, project_name, capabilities, ai_config | Start with existing version |
| `POST /start` | content, project_name, capabilities, ai_config | Start with new content |
| `POST /start/confirm` | content, project_name, capabilities, ai_config | Confirm after diff |
| `POST /resume/{run_id}` | optional content | Resume, check diff if content |
| `POST /resume/{run_id}/confirm` | content | Confirm resume with new version |

### Phase A1: Create `POST /start/{version_id}`

**File:** `server/api/workflow_api.py`

```python
@router.post("/start/{workflow_version_id}", response_model=WorkflowResponse)
async def start_workflow_by_version(
    workflow_version_id: str,
    request: StartWorkflowByVersionRequest,  # project_name, capabilities, ai_config
    user_id: str = Depends(get_current_user_id)
):
    """Start workflow with existing version."""
    # 1. Validate version exists
    version = db.get_workflow_version_by_id(workflow_version_id)
    if not version:
        raise HTTPException(404, "Version not found")

    # 2. Validate version_type is source (raw or unresolved), not resolved
    version_type = version.get("version_type")
    if version_type == "resolved":
        raise HTTPException(400, "Cannot start with resolved version. Use source version.")

    # 3. Get workflow_template_name
    template = db.get_workflow_template_by_id(version.get("workflow_template_id"))
    workflow_template_name = template.get("workflow_template_name")

    # 4. Call processor
    result = processor.start_workflow(
        version_id=workflow_version_id,
        project_name=request.project_name,
        capabilities=request.capabilities,
        ai_config=request.ai_config,
        user_id=user_id
    )
    return result
```

### Phase A2: Refactor `POST /start` (content only)

**File:** `server/api/workflow_api.py`

```python
@router.post("/start", response_model=WorkflowResponse)
async def start_workflow(
    request: StartWorkflowRequest,  # content required, no version_id
    user_id: str = Depends(get_current_user_id)
):
    """Start workflow with uploaded content."""
    # 1. Validate content provided
    if not request.workflow_content:
        raise HTTPException(400, "workflow_content required. Use /start/{version_id} for existing versions.")

    # 2. Resolve content
    resolved_workflow, content_hash, source_type = _resolve_workflow_from_content(...)
    workflow_template_name = resolved_workflow.get("workflow_id")

    # 3. Check for existing version (source versions only: raw or unresolved)
    existing = db.get_latest_source_version(workflow_template_name, user_id)

    if existing:
        if existing.get("content_hash") == content_hash:
            # Same version exists - use it
            version_id = existing.get("workflow_version_id")
        else:
            # Different version - return diff
            diff = compute_workflow_diff(existing.get("resolved_workflow"), resolved_workflow)
            return WorkflowResponse(
                status=WorkflowStatus.CREATED,
                result={"requires_confirmation": True, "version_diff": diff, ...}
            )
    else:
        # No existing version - create raw version
        version_id, template_id, _ = db.get_or_create_workflow_version(
            content_hash, source_type, resolved_workflow, workflow_template_name, user_id
        )

    # 4. Call processor
    result = processor.start_workflow(version_id=version_id, ...)
    return result
```

### Phase A3: Refactor `POST /start/confirm`

**File:** `server/api/workflow_api.py`

Same as current but:
1. Create new raw version from confirmed content
2. Call processor with new version_id

### Phase A4: Refactor `POST /resume/{run_id}`

**File:** `server/api/workflow_api.py`

```python
@router.post("/{workflow_run_id}/resume", response_model=WorkflowResponse)
async def resume_workflow(
    workflow_run_id: str,
    request: Optional[ResumeWorkflowRequest] = None,
    user_id: str = Depends(get_current_user_id)
):
    # 1. Validate workflow exists, user owns it
    # 2. Apply recovery if needed
    # 3. If no content - just return current state

    if request and request.workflow_content:
        # 4. Resolve new content
        new_workflow, new_hash, _ = _resolve_workflow_from_content(...)

        # 5. Get SOURCE version for comparison
        current_version_id = workflow.get("current_workflow_version_id")
        current_version = db.get_workflow_version_by_id(current_version_id)

        if current_version.get("version_type") == "resolved":
            # Get parent (unresolved) for comparison
            source_version = db.get_workflow_version_by_id(
                current_version.get("parent_workflow_version_id")
            )
        else:
            # raw or unresolved - use directly
            source_version = current_version

        # 6. Compare
        if new_hash != source_version.get("content_hash"):
            diff = compute_workflow_diff(source_version.get("resolved_workflow"), new_workflow)
            return WorkflowResponse(
                workflow_run_id=workflow_run_id,
                status=WorkflowStatus.CREATED,
                result={"requires_confirmation": True, "version_diff": diff, ...}
            )

    # 7. Return current state
    return WorkflowResponse(...)
```

### Phase A5: Refactor `POST /resume/{run_id}/confirm`

**File:** `server/api/workflow_api.py`

```python
@router.post("/{workflow_run_id}/resume/confirm", response_model=WorkflowResponse)
async def confirm_resume_with_update(
    workflow_run_id: str,
    request: ResumeWorkflowRequest,
    user_id: str = Depends(get_current_user_id)
):
    # 1. Validate workflow exists, user owns it
    # 2. Resolve new content
    new_workflow, new_hash, source_type = _resolve_workflow_from_content(...)
    workflow_template_name = new_workflow.get("workflow_id")

    # 3. Create new raw version
    version_id, template_id, _ = db.get_or_create_workflow_version(
        new_hash, source_type, new_workflow, workflow_template_name, user_id
    )

    # 4. Call processor
    result = processor.resume_workflow_with_update(
        workflow_run_id=workflow_run_id,
        version_id=version_id,
        capabilities=request.capabilities,
        ai_config=request.ai_config,
        user_id=user_id
    )
    return result
```

### Phase A6: Update processor.start_workflow signature

**File:** `server/api/workflow_processor.py`

Change from:
```python
def start_workflow(
    self,
    project_name: str,
    resolved_workflow: Dict[str, Any],
    workflow_template_name: str,
    content_hash: str,
    source_type: str,
    ...
)
```

To:
```python
def start_workflow(
    self,
    version_id: str,
    project_name: str,
    user_id: str,
    capabilities: List[str] = None,
    ai_config: Dict[str, Any] = None,
    force_new: bool = False
)
```

Processor responsibilities:
1. Load version from DB
2. If version has execution groups (unresolved) → create resolved versions, select best
3. If version is raw → use directly
4. Get or create workflow_run
5. Add version history entry
6. Execute

### Phase A7: Update processor.resume_workflow_with_update signature

**File:** `server/api/workflow_processor.py`

Change to receive `version_id` instead of `resolved_workflow` + `content_hash`.

### Phase A8: Add helper method `get_latest_source_version`

**File:** `server/api/database_history.py`

```python
def get_latest_source_version(
    self,
    workflow_template_name: str,
    user_id: str
) -> Optional[Dict[str, Any]]:
    """Get latest source version (raw or unresolved) for template."""
    template = self.get_workflow_template_by_name(workflow_template_name, user_id)
    if not template:
        return None

    return self.workflow_versions.find_one(
        {
            "workflow_template_id": template["workflow_template_id"],
            "version_type": {"$in": ["raw", "unresolved"]}
        },
        sort=[("created_at", -1)]
    )
```

### Phase A9: Update WebUI/TUI clients

**Files:** `webui/src/lib/api.ts`, `tui/workflow_runner.py`

- Template selection flow → `POST /start/{version_id}`
- Upload flow → `POST /start`

---

## Plan of Action (POA) - Part B: Original Version Field Changes

Continue with original plan after Part A is complete.

### Phase 1: Migration (m_8.py)

**File:** `server/api/migrations/m_8.py`

1. Backup database
2. Rename `version_type: "flattened"` → `"resolved"` in workflow_versions
3. Set parent versions to `unresolved`:
   - For each resolved version, find parent and set `version_type: "unresolved"`
4. Create `workflow_run_version_history` collection
5. Migrate workflow_runs to history table:
   - For each run with `current_workflow_version_id`:
     - Look up the version
     - If `resolved` → add to history with `requires` as `workflow_version_requirements`
     - If `raw` AND has resolved children → skip (broken reference)
     - If `raw` AND no resolved children → add to history (empty requirements)
     - `client_capabilities` = [] (data is lost)
6. Remove `initial_workflow_version_id` from all workflow_runs
7. Create index on `workflow_run_version_history.workflow_run_id`

### Phase 2: Database Provider Updates

**File:** `server/api/database_provider.py`

1. Add `workflow_run_version_history` collection in `__init__`
2. Update `get_or_create_workflow_run()`:
   - Remove `initial_workflow_version_id` from insert
   - After setting `current_workflow_version_id`, call `_add_version_history_entry()`
3. Add new method `_add_version_history_entry()`:
   ```python
   def _add_version_history_entry(
       self,
       workflow_run_id: str,
       workflow_version_id: str,
       client_capabilities: List[str]
   ) -> None:
       """Insert entry into workflow_run_version_history."""
       version = self.get_workflow_version_by_id(workflow_version_id)
       if not version:
           return

       version_type = version.get("version_type")
       if version_type == "unresolved":
           raise ValueError(f"Cannot use unresolved version {workflow_version_id} for workflow run")

       self.workflow_run_version_history.insert_one({
           "workflow_run_id": workflow_run_id,
           "workflow_version_id": workflow_version_id,
           "client_capabilities": client_capabilities,
           "workflow_version_requirements": version.get("requires", []) if version_type == "resolved" else [],
           "created_at": datetime.utcnow()
       })
   ```
4. Add version type validation in `get_version_for_capabilities()`:
   - After finding version, validate it's not `unresolved`
   - Throw early if invalid
5. Update `store_event()`:
   - Remove fallback to `initial_workflow_version_id`
   - Only use `current_workflow_version_id`

### Phase 3: Database History Updates

**File:** `server/api/database_history.py`

1. Update `get_or_create_workflow_version()`:
   - Keep setting `version_type: "raw"` for new raw versions (unchanged)
2. Update flattened version logic:
   - When checking for execution groups in `process_and_store_workflow_versions()`:
     - If workflow has execution groups → set raw version `version_type` to `"unresolved"`
     - Create resolved versions with `version_type: "resolved"`

### Phase 4: Database Provider - create_flattened_version rename

**File:** `server/api/database_provider.py`

1. Rename `create_flattened_version()` → `create_resolved_version()`
2. Update `version_type` from `"flattened"` to `"resolved"`
3. Update all callers

### Phase 5: Workflow Processor Updates

**File:** `server/api/workflow_processor.py`

1. Update `start_workflow()`:
   - Remove `initial_workflow_version_id` references
   - Pass `capabilities` to `_add_version_history_entry()` when updating version
2. Update `resume_workflow_with_update()`:
   - Remove `initial_workflow_version_id` update
   - Add version history entry when switching versions
3. Update `_get_workflow_def()`:
   - Add validation: if version_type is `"unresolved"`, throw error immediately
   - Log clearly which version type is being used
4. Remove all references to `initial_workflow_version_id` throughout file

### Phase 6: Execution Groups Processor

**File:** `server/engine/execution_groups.py`

1. Verify `process_workflow()` correctly identifies workflows with execution groups
2. Update any `version_type` references from `"flattened"` to `"resolved"`

### Phase 7: Testing

1. Run migration on test database
2. Verify:
   - All versions have correct `version_type` (raw, unresolved, resolved)
   - History table populated correctly
   - `initial_workflow_version_id` removed from all runs
   - Workflow start works with capabilities
   - Workflow resume works
   - Error thrown when `unresolved` version used for run

---

## Execution Order

```
m_8.py (migration)
    ↓
database_provider.py (add collection, methods, validation)
    ↓
database_history.py (update version type logic)
    ↓
workflow_processor.py (remove initial_workflow_version_id, add validation)
    ↓
execution_groups.py (verify/update)
    ↓
test
```

---

## Key Code Locations

| Location | Line | Current Code |
|----------|------|--------------|
| `database_provider.py:535` | `initial_workflow_version_id: version_id` | Remove this line |
| `database_provider.py:681-688` | Fallback to `initial_workflow_version_id` | Remove fallback |
| `workflow_processor.py:184` | `raw_version_id = workflow.get("initial_workflow_version_id")` | Use `current_workflow_version_id` |
| `workflow_processor.py:359-365` | Updates both version IDs | Remove `initial_workflow_version_id` |
| `database_provider.py:2100` | `version_type": "flattened"` | Change to `"resolved"` |
