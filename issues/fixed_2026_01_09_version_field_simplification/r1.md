# Issue: Remove initial_workflow_version_id and Simplify Version Types

## Summary

`initial_workflow_version_id` is incorrectly used and causes major issues. The field adds confusion with no real value. This issue removes it entirely and clarifies version type semantics.

## Root Cause

The dual-field approach (`initial_workflow_version_id` + `current_workflow_version_id`) creates confusion about which version to use and when. The system incorrectly allows `unresolved` versions to be associated with workflow runs.

## Changes

### 1. Remove initial_workflow_version_id

- Remove `initial_workflow_version_id` from `workflow_runs` collection
- Only `current_workflow_version_id` remains
- `current_workflow_version_id` is the version currently used by the workflow run

### 2. Version Type Clarification

Rename and clarify version types:

| Type | Description | Can Run? |
|------|-------------|----------|
| `raw` | Workflow without execution groups | Yes |
| `unresolved` | Workflow with execution groups, not flattened | **No** |
| `resolved` | Flattened workflow from unresolved (renamed from `flattened`) | Yes |

### 3. Strict Version Type Validation

- `current_workflow_version_id` must ALWAYS point to `raw` or `resolved` version
- If `unresolved` version is ever returned for a workflow run, throw immediately
- No attempt to default or recover - fail fast

### 4. New Collection: workflow_run_version_history

Track version usage for audit purposes:

```
workflow_run_version_history
    workflow_run_id         string
    workflow_version_id     string (raw or resolved only)
    created_at              datetime
```

**Rules:**
- Insert only, never update
- Created when:
  - New workflow_run is created
  - Workflow run switches to new version (resume with update)
- `workflow_version_id` is always the version used to run (raw or resolved), never unresolved

## Migration

1. For each workflow_run:
   - If `initial_workflow_version_id` exists, create entry in `workflow_run_version_history`
   - Remove `initial_workflow_version_id` field
<--due to the mess we are in, above is not that simple, first, we are using current_workflow_version_id to add it to hisory table, but we will look up if current_workflow_versio_id, if its flattened, we add it to history table, if its raw and has flattened versions for that raw version, that means the reference is broken, in that case, we will not add anything to history table, leave it broken, if there are no flattened versions for raw versions thats fine, add it to history table.-->
2. Rename `version_type: "flattened"` to `version_type: "resolved"` in workflow_versions
<!--for is flattened/resolved version, we lookup parent workflow for it, and set its type as "unsolved" -->
3. Add validation that no workflow_run has `unresolved` version
<!--I think above will have errors anyways, so dont check for it as we dont have reliable way to fix it.-->
<!--for history table, we will 2 more fields field called, client_capabilities, workflow_version_requirements. first will store capabilities sent by client at the time of creation of the entry, this is array of strings. second will store value of "require" field of the flattened version of the workflow, this is in the format of {capability: string, priority: int}, verify both of these before adding changes. you should be able to get value for workflow_version_requirements from workflow_versions table, but client capabilties are lost, so leave it empty.-->

## Files Affected

| File | Changes |
|------|---------|
| `server/api/database_provider.py` | Remove initial_workflow_version_id handling, add version history methods |
| `server/api/database_history.py` | Update version creation |
| `server/api/workflow_processor.py` | Add version type validation |
| `server/api/workflow_api.py` | Update endpoints |
| `server/api/migrations/m_8.py` | New migration |

## Priority

**Critical** - Current implementation causes workflow execution failures.
