# Issue: workflow_runs Version Fields Not Removed Per Architecture

## Summary

The `pipeline.execution_groups` architecture (r5.md) specifies that `initial_workflow_version_id` and `current_workflow_version_id` should be dropped from `workflow_runs` and replaced by the resolution system. Migration m_6.py created the resolution collections but never removed these deprecated fields. The codebase now has mixed usage of both old and new patterns.

## Architecture Reference

**Document**: `architecture/2026_01_06_aesthetic_selection_ux/r5.md`

**Lines 173-177**:
```sql
-- Modified: workflow_runs
-- Remove version columns, add resolution reference
ALTER TABLE workflow_runs
    DROP COLUMN initial_workflow_version_id,
    DROP COLUMN current_workflow_version_id;
```

**Lines 179-192** define the replacement:
```sql
-- New: workflow_run_resolutions
-- Links a run to its resolution (can have multiple if capabilities change)
CREATE TABLE workflow_run_resolutions (
    workflow_run_resolution_id UUID PRIMARY KEY,
    workflow_run_id UUID NOT NULL REFERENCES workflow_runs,
    workflow_resolution_id UUID NOT NULL REFERENCES workflow_resolutions,
    capabilities TEXT[] NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
```

## Expected Behavior

1. `workflow_runs` should NOT contain version fields
2. Version lookup should use: `workflow_run_resolutions` → `workflow_resolutions` → `workflow_versions`
3. Active resolution determined by `is_active: true` on `workflow_run_resolutions`

## Actual Behavior

1. `workflow_runs` still contains both version fields
2. Code uses `current_workflow_version_id` for lookups (12+ usages across 3 files)
3. `current_workflow_version_id` points to **source** version, not flattened
4. Resolution system exists but is underutilized

### Current Usages of Deprecated Fields

| File | Count | Purpose |
|------|-------|---------|
| `database_provider.py` | 7 | Create runs, lookup versions, status checks |
| `workflow_api.py` | 3 | `/definition` endpoint, resume, status display |
| `workflow_processor.py` | 2 | Resume with update |

## Root Cause Analysis

Migration m_6.py was implemented as an additive change only:
- Created `workflow_resolutions` collection ✓
- Created `workflow_run_resolutions` collection ✓
- Did NOT drop deprecated fields from `workflow_runs` ✗
- Did NOT update code to use resolution system exclusively ✗

## Impact

1. **Wrong workflow returned**: `/definition` returns raw workflow instead of flattened
2. **Module config lookup fails**: Grouped modules don't exist in raw workflow
3. **Inconsistent data model**: Two systems coexist, unclear which is authoritative
4. **Technical debt**: Code maintains both patterns

## Proposed Solution

### Step 1: Audit All Usages

Before any changes, document every usage of:
- `initial_workflow_version_id`
- `current_workflow_version_id`

Determine for each:
- Can it be replaced with resolution lookup?
- Is it needed for backwards compatibility?
- What happens for runs created before resolution system?

### Step 2: Add Resolution Lookup Methods

Add helper methods to `database_provider.py`:
```python
<!--
Few things about following code,
1. we have to make sure this works for both flattened workflows as well as 
    workflows which didnt need flattened (workflows where there were no
    groups)
2. All these has to be done using mongodb pipelines. writing nested code
    like this just are prone to more errors, pipeline is clearly declarative
    and provides final result from get go.
-->
def get_active_resolution(self, workflow_run_id: str) -> Optional[Dict]:
    """Get the active resolution for a run."""
    return self.workflow_run_resolutions.find_one({
        "workflow_run_id": workflow_run_id,
        "is_active": True
    })

def get_resolved_workflow_for_run(self, workflow_run_id: str) -> Optional[Dict]:
    """Get the flattened workflow for a run via resolution."""
    resolution = self.get_active_resolution(workflow_run_id)
    if resolution:
        full_resolution = self.workflow_resolutions.find_one({
            "workflow_resolution_id": resolution["workflow_resolution_id"]
        })
        if full_resolution:
            return self.get_resolved_workflow(
                full_resolution["resolved_workflow_version_id"]
            )
    # Fallback for pre-resolution runs
    workflow = self.get_workflow(workflow_run_id)
    if workflow:
        return self.get_resolved_workflow(
            workflow.get("initial_workflow_version_id")
        )
    return None
```

### Step 3: Migrate Code Gradually

Update each usage site to use resolution lookup:
1. `/definition` endpoint - highest priority
<!--tbh, #1 is less priority, my biggest worry is logic of workflow creation,
    workflow run creation, start/resume workflow. these are critical points
    of the application. these must function always without any issue. -->
2. Resume logic
3. Status display
4. Other usages

### Step 4: Backfill Existing Runs (Optional)

<!--no fallback in this case, focus on new implementation, i dont care about existing
    workflows not working. focus on getting this correct. -->
For runs created before resolution system:
- Create "passthrough" resolutions that point source to itself
- Or keep `initial_workflow_version_id` as fallback

### Step 5: Create Migration to Drop Fields

Once all code migrated:
- Create m_7.py to drop `current_workflow_version_id`
- Possibly keep `initial_workflow_version_id` as historical reference

## Files Affected

- `server/api/database_provider.py` - Add resolution lookup methods, update 7 usages
- `server/api/workflow_api.py` - Update 3 usages
- `server/api/workflow_processor.py` - Update 2 usages
- `server/api/migrations/m_7.py` - New migration (final step)

## Priority

<!--I need indepth analysis of all uses of existing 2 fields and 
    how they are used now, and how replacement going to work. -->

**High**

Justification:
- Architecture was approved but not fully implemented
- Causes downstream issues (tree view, module config lookup)
- Technical debt that will compound over time
- Need to do carefully to avoid breaking existing runs

## Risk Assessment

**High risk if done incorrectly:**
- Could break existing workflow runs
- Could lose version history
- Could break resume functionality

**Mitigation:**
- Always backup database before migration
- Test with existing runs from before resolution system
- Gradual migration with fallbacks
- Keep `initial_workflow_version_id` as readonly historical field

## Dependencies

This issue blocks:
- `issues/2026_01_08_execution_groups_tree_view` - Tree view display for grouped modules
