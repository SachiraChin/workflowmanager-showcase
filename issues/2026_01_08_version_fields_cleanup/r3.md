# Issue: workflow_runs Version Fields Cleanup - Revision 3

## Clarifications from R2 Feedback

### Q: What's the difference between run creation and start?

**They happen in the SAME endpoint (`POST /workflow/start`), but sequentially:**

```
POST /workflow/start
    │
    ├── 1. db.get_or_create_workflow()     ← Creates run, sets version fields
    │       └── Creates workflow_run with initial/current_workflow_version_id
    │
    ├── 2. Read back version fields        ← Wasteful! Just set them above
    │       └── source_version_id = workflow.get("current_workflow_version_id")
    │
    ├── 3. select_resolution_for_capabilities()  ← Resolution lookup
    │       └── Uses source_version_id + template_id + capabilities
    │
    └── 4. create_workflow_run_resolution()  ← Links run to resolution
            └── Creates audit trail entry
```

**The problem**: We create run with version fields, then immediately read them back, then do resolution lookup. This is wasteful and creates confusion.

### Q: Why use workflow_template_id for resolution lookup?

**Current reasoning**: Resolutions are stored per template+version combination:

```
workflow_resolutions:
    workflow_template_id     → Groups all versions of same template
    source_workflow_version_id  → Specific version being flattened
    resolved_workflow_version_id → Flattened result
    requires: [...]          → Capability requirements
```

**The issue you're sensing**: `workflow_template_id` is a high-level grouping that can have many versions. When we need the workflow for a specific run, we need to know WHICH version, not just which template.

**Current flow (problematic)**:
1. At run creation: Store source version on run
2. At resolution time: Read source version from run, lookup resolution by template+version
3. Get flattened version from resolution

**What should happen**:
1. At run creation: Determine final version immediately
2. Store direct reference to the version being executed
<!--I agree on #1, but it is required to store raw version and all other versions in db as well. 
    reason being, user simply can raw version of the workflow to start new workflow anywhere,
    api will pick correct flattend version based on client capabilities.

    I'm kind of regret current resolution system, it is confusing at best, disasterous at 
    worst. the simpler mechanism would extending workflow_versions table

    workflow_versions
        ...all current fields
        type=raw/flattened
        parent_workflow_version_id = None

    workflow_runs
        ...keep all fields (including initial/current workflow version ids
        ...values of those 2 version ids are real workflow which used
        ...in the run. flattened for grouped, raw for non-grouped

    when we call /definitions 
        we take the workflow_version by workflow run version id, if
        received workflow is flattened, we use its parent to get raw version

    this removes whole resolution system which right now amost no utilization,
        simplify things, and intutive to understand.
    -->

---

## Alternative Proposals

### Proposal A: Store Active Version Directly on Run

**Add single field to workflow_runs**: `active_version_id`

```python
# At run creation (in get_or_create_workflow)
workflow_run = {
    "workflow_run_id": workflow_run_id,
    "workflow_template_id": template_id,
    "active_version_id": None,  # Set after resolution selection
    # ... other fields
}

# After resolution selection (in start_workflow)
if selected_resolution:
    active_version_id = selected_resolution["resolved_workflow_version_id"]
else:
    active_version_id = source_version_id  # No flattening needed

db.workflow_runs.update_one(
    {"workflow_run_id": workflow_run_id},
    {"$set": {"active_version_id": active_version_id}}
)
```

**Lookup is trivial**:
```python
def get_workflow_for_run(self, workflow_run_id: str):
    run = self.get_workflow(workflow_run_id)
    return self.get_resolved_workflow(run["active_version_id"])
```

**For non-group workflows**: `active_version_id` = source version (no flattening)
**For group workflows**: `active_version_id` = flattened version

**Pros**:
- Single field, clear semantics
- O(1) lookup
- No passthrough resolutions needed
- `workflow_run_resolutions` becomes pure audit trail

**Cons**:
- Adds a field to workflow_runs (but architecture said to remove the confusing ones, not ban all version fields)

---

### Proposal B: Resolution-Only (Per Original Architecture)

**No version fields on workflow_runs**. Everything via resolution chain.

**For ALL workflows (including non-group)**: Create resolution entry at upload time.

```python
# At upload time
if has_execution_groups:
    # Create multiple resolutions for different capability sets
    for flattened in flatten_all_combinations():
        create_resolution(source_id, flattened_id, requires)
else:
    # Create passthrough resolution
    create_resolution(source_id, source_id, requires=[])  # Points to itself
```

**Lookup via aggregation**:
```python
def get_workflow_for_run(self, workflow_run_id: str):
    pipeline = [
        {"$match": {"workflow_run_id": workflow_run_id}},
        {"$lookup": {
            "from": "workflow_run_resolutions",
            "localField": "workflow_run_id",
            "foreignField": "workflow_run_id",
            "pipeline": [{"$match": {"is_active": True}}],
            "as": "run_res"
        }},
        {"$lookup": {
            "from": "workflow_resolutions",
            "localField": "run_res.workflow_resolution_id",
            "foreignField": "workflow_resolution_id",
            "as": "res"
        }},
        {"$lookup": {
            "from": "workflow_versions",
            "localField": "res.resolved_workflow_version_id",
            "foreignField": "workflow_version_id",
            "as": "version"
        }},
        {"$project": {
            "resolved_workflow": {"$arrayElemAt": ["$version.resolved_workflow", 0]}
        }}
    ]
    return list(self.workflow_runs.aggregate(pipeline))[0]
```

**Pros**:
- Clean separation of concerns
- Full audit trail
- Follows original architecture exactly

**Cons**:
- Passthrough resolutions feel hacky
- More complex lookup
- More records in database

---

### Proposal C: Hybrid - Resolution ID on Run

**Store `workflow_resolution_id` on workflow_runs** (nullable):

```python
workflow_run = {
    "workflow_run_id": workflow_run_id,
    "workflow_template_id": template_id,
    "workflow_resolution_id": resolution_id,  # nullable
    # ... other fields
}
```

**For non-group workflows**: `workflow_resolution_id` = null
- Lookup uses template's latest version directly

**For group workflows**: `workflow_resolution_id` = selected resolution
- Lookup follows resolution → version

```python
def get_workflow_for_run(self, workflow_run_id: str):
    run = self.get_workflow(workflow_run_id)

    if run.get("workflow_resolution_id"):
        # Follow resolution chain
        resolution = self.get_resolution(run["workflow_resolution_id"])
        return self.get_resolved_workflow(resolution["resolved_workflow_version_id"])
    else:
        # No resolution - use template's version directly
        # But which version? Need to track this somehow...
        ???
```

**Problem**: For non-group workflows, we still need to know which version. This proposal doesn't solve that.

---

### Proposal D: Two Clear Fields

**Store both source and active version**:

```python
workflow_run = {
    "workflow_run_id": workflow_run_id,
    "workflow_template_id": template_id,
    "source_version_id": version_id,    # Original uploaded version
    "active_version_id": version_id,    # Version being executed (may differ)
    # ... other fields
}
```

**At creation**: Both set to source version
**After resolution**: `active_version_id` updated to flattened version

```python
# Resolution selection
if selected_resolution:
    db.workflow_runs.update_one(
        {"workflow_run_id": workflow_run_id},
        {"$set": {
            "active_version_id": selected_resolution["resolved_workflow_version_id"]
        }}
    )
```

**Lookup**: Always use `active_version_id`
**Source reference**: `source_version_id` available for debugging/UI

**Pros**:
- Clear semantics
- O(1) lookup
- Source preserved for reference
- No passthrough hackery

**Cons**:
- Two fields (but with clear, distinct purposes)

---

## Recommendation

**Proposal A (Single `active_version_id`) or Proposal D (source + active)**

Both are simpler than the resolution-only approach and avoid passthrough resolutions.

**Key insight**: The resolution system is great for MANAGING different flattened versions at upload time. But at runtime, a run just needs to know which version it's executing. Storing that directly is cleaner than chaining through multiple collections.

**workflow_run_resolutions** should be:
- Created when resolution is selected (audit trail)
- Used for capability-change scenarios (switch resolution mid-run)
- NOT the primary source for "which version is this run using"

---

## Questions for Review

1. **Proposal A vs D**: Do we need `source_version_id` on the run, or can it be derived from resolution/template when needed?

2. **Passthrough resolutions**: If we go with Proposal B, is the passthrough approach acceptable, or does it feel too hacky?

3. **Architecture deviation**: The original architecture said to drop version fields. Are we okay adding `active_version_id` instead, given it has clearer semantics?

4. **Resume with update**: When user uploads new workflow mid-run, should `active_version_id` update to new flattened version, or stay on original?
