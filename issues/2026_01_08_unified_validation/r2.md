# Issue: Unified Validation Strategy (Client + Server)

## Summary

The validation system needs a unified approach across client (WebUI/TUI) and server (io.validate module). Currently:
- Server uses `io.validate` with JSON schema validation
- WebUI has ad-hoc client-side validation
- TUI uses pattern-based validation
- No shared schema or error format

This issue merges the concerns from client-side validation and io.validate scope into a single unified validation strategy using standard JSON Schema libraries.

## Architecture Reference

- [R5 Part 6](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Validation with `io.validate` Module" - Server-side specification
- [R5 Part 4](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Generic `user.form` Module" - Form schema structure
- [R9](../architecture/2026_01_06_aesthetic_selection_ux/r9.md): References io.validate module design

## Current State

### Server-Side (io.validate)

From `server/modules/io/validate.py`:
- Uses Python `jsonschema` library
- Auto-generated by flattener at group exit
- Validates state keys against schema
- Throws `ModuleExecutionError` on failure

### Client-Side (WebUI)

From `webui/src/components/interactions/FormInteraction.tsx`:
- Custom validation logic
- Uses `input_schema` from form definition
- Inconsistent error format with server

### Client-Side (TUI)

From `tui/workflow_runner.py`:
- Uses `validation_pattern` regex for text input
- No form validation (TUI doesn't support forms)

### Workarounds in Workflows

From `workflows/oms/steps/1_user_input/modules/07_aesthetic_selection_group.json`:
```json
{
  "module_id": "io.write_state",
  "inputs": {
    "values": {
      "aesthetic_selection_valid": true,
      "aesthetic_selection_errors": []
    }
  }
}
```

Manual validation state because io.validate doesn't output validation status.

## Proposed Solution: JSON Schema 2020-12 Libraries

Use standard JSON Schema 2020-12 compliant libraries on both client and server to ensure consistent validation behavior.

<!--Can you add few examples of how schema would look with this? -->

### Why JSON Schema 2020-12?

1. **Industry Standard**: Widely adopted, well-documented specification
2. **Library Support**: Mature libraries exist for both Python and TypeScript
3. **Same Schema, Same Results**: Identical validation behavior across platforms
4. **Rich Validation**: Supports complex schemas (conditionals, references, formats)
5. **Standard Error Format**: Libraries provide consistent error structures

### Python: jsonschema Library

[jsonschema](https://pypi.org/project/jsonschema/) (v4.26.0) - The standard Python JSON Schema implementation.

```python
from jsonschema import Draft202012Validator, ValidationError

def validate_data(data: dict, schema: dict) -> tuple[bool, list[dict]]:
    """
    Validate data against JSON Schema 2020-12.

    Returns:
        (is_valid, errors) - errors is list of {path, message}
    """
    validator = Draft202012Validator(schema)
    errors = []

    for error in validator.iter_errors(data):
        errors.append({
            "path": list(error.path),
            "message": error.message,
            "schema_path": list(error.schema_path)
        })

    return len(errors) == 0, errors
```

**Features:**
- Full Draft 2020-12 support
- Format validation (email, date, uuid, etc.) with `format_checker`
- Detailed error messages with JSON path to invalid field
- Schema composition ($ref, allOf, oneOf, anyOf)

**Documentation:** [python-jsonschema.readthedocs.io](https://python-jsonschema.readthedocs.io/)

### TypeScript: Ajv Library

[Ajv](https://ajv.js.org/) (Another JSON Validator) - The fastest JSON validator for Node.js and browser.

```typescript
import Ajv2020 from "ajv/dist/2020";
import type { ErrorObject } from "ajv";

const ajv = new Ajv2020({ allErrors: true });

interface ValidationResult {
  valid: boolean;
  errors: Array<{
    path: string;
    message: string;
  }>;
}

export function validateData(data: unknown, schema: object): ValidationResult {
  const validate = ajv.compile(schema);
  const valid = validate(data);

  if (valid) {
    return { valid: true, errors: [] };
  }

  const errors = (validate.errors || []).map((err: ErrorObject) => ({
    path: err.instancePath,
    message: err.message || "Validation error"
  }));

  return { valid: false, errors };
}
```

**Features:**
- Full Draft 2020-12 support (import from `ajv/dist/2020`)
- TypeScript type guards for validated data
- Compiled validators for performance
- Same error structure can be normalized to match Python

**Documentation:** [ajv.js.org](https://ajv.js.org/)

### Unified Error Format

Both libraries output errors that can be normalized to:

```typescript
interface ValidationError {
  path: string;          // JSON path to invalid field (e.g., "/items/0/count")
  message: string;       // Human-readable error message
  keyword?: string;      // Schema keyword that failed (e.g., "minimum", "required")
  schema_path?: string;  // Path in schema where error occurred
}
```

### Implementation Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     JSON Schema 2020-12                         │
│                   (Single Source of Truth)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
          ┌───────────────────┼───────────────────┐
          │                   │                   │
          ▼                   ▼                   ▼
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │   WebUI     │    │    TUI      │    │   Server    │
   │   (Ajv)     │    │ (jsonschema)│    │ (jsonschema)│
   └─────────────┘    └─────────────┘    └─────────────┘
          │                   │                   │
          └───────────────────┼───────────────────┘
                              │
                              ▼
                 ┌─────────────────────────┐
                 │  Normalized Error Format │
                 │  { path, message, ... }  │
                 └─────────────────────────┘
```

### Validation Flow

```
User Input
    │
    ▼
┌─────────────────────────────────────┐
│ Client-Side Validation (Ajv)        │
│ - Real-time on field blur           │
│ - Block submit if errors            │
│ - Show inline error messages        │
└─────────────────────────────────────┘
    │
    │ (only if client validation passes)
    ▼
┌─────────────────────────────────────┐
│ Server-Side Validation (jsonschema) │
│ - io.validate at group exit         │
│ - Final authority                   │
│ - May catch edge cases client missed│
└─────────────────────────────────────┘
    │
    ▼
Continue Workflow
```

## Files Affected

### New/Modified Files

1. **contracts/validation.py** - Shared validation wrapper
   ```python
   from jsonschema import Draft202012Validator

   def validate_against_schema(data, schema) -> ValidationResult:
       """Normalize jsonschema output to standard format."""
   ```

2. **webui/src/lib/validation.ts** - Ajv wrapper with normalized output
   ```typescript
   import Ajv2020 from "ajv/dist/2020";

   export function validateAgainstSchema(data, schema): ValidationResult
   ```

3. **server/modules/io/validate.py** - Use contracts/validation.py
   - Add `output_state` option to return validation result instead of throwing

4. **server/modules/user/form.py** - Use contracts/validation.py for input validation

5. **webui/src/components/interactions/FormInteraction.tsx** - Use lib/validation.ts

### Package Dependencies

**Python (requirements.txt):**
```
jsonschema>=4.20.0  # Already likely present
```

**WebUI (package.json):**
```json
{
  "dependencies": {
    "ajv": "^8.12.0"
  }
}
```

## Implementation Steps

### Phase 1: Create Validation Wrappers

1. Create `contracts/validation.py` with normalized interface
2. Create `webui/src/lib/validation.ts` with same interface
3. Add unit tests for both ensuring identical behavior

### Phase 2: Update Server Modules

1. Update `io.validate` to use `contracts/validation.py`
2. Add `output_state` option for non-throwing validation
3. Update `user.form` to use shared validation

### Phase 3: Update WebUI

1. Replace ad-hoc validation with `lib/validation.ts`
2. Add real-time validation on field blur
3. Normalize error display format

### Phase 4: Update TUI (Optional)

1. TUI can use `contracts/validation.py` for text input validation
2. Pattern validation can coexist with schema validation

## Priority

**Medium**

**Justification:**
- Workarounds exist but add complexity
- Using standard libraries reduces maintenance burden
- Ensures consistent validation across all clients
- Foundation for future form types

## Testing Plan

1. Create test schema covering all JSON Schema 2020-12 features used
2. Run identical test cases through Python and TypeScript validators
3. Verify error format matches between platforms
4. Test edge cases: empty values, type coercion, nested objects
5. Integration test with user.form module
6. End-to-end test WebUI form submission

## References

- [JSON Schema Draft 2020-12 Specification](https://json-schema.org/draft/2020-12)
- [Python jsonschema Documentation](https://python-jsonschema.readthedocs.io/)
- [Ajv JSON Schema Validator](https://ajv.js.org/)
- [Ajv TypeScript Guide](https://ajv.js.org/guide/typescript.html)
