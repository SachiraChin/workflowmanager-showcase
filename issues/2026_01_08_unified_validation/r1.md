# Issue: Client-Side io.validate Module Not Documented or Implemented

## Summary

The architecture documents (R5-R11) only specify server-side validation via `io.validate`. However, for interactive modules like `user.form`, client-side validation is essential for good UX. Currently, there's no documented pattern for client-side validation, leading to inconsistent implementation across WebUI and TUI.

## Architecture Reference

<!--meta feedback: this should link to existing arch doc relative format so user can click and open the doc.-->
- **R5 Part 6**: Only specifies server-side io.validate
- **Not Documented**: No client-side validation specification exists
- **Implicit Need**: Form interactions require validation before submission

## Expected Behavior (Gap in Architecture)

### What Should Be Documented

1. **Client-Side Validation Patterns**
   - Schema-based validation on client before submission
   - Real-time validation feedback as user types
   - Relationship to server-side io.validate

2. **Validation Flow**
   ```
   User Input → Client Validation → Submit → Server Validation → Continue
                      ↓
              Show errors inline
   ```

3. **Schema Distribution**
   - Where does client get validation schema?
   - Is it part of InteractionRequest?
   - Is it the same schema as server io.validate?

## Actual Behavior

### Current WebUI Implementation

From `webui/src/components/interactions/FormInteraction.tsx` (inferred from architecture):
- Some client-side validation exists
- Uses `input_schema` from form definition
- Validation on blur/submit

### Current TUI Implementation

From `tui/workflow_runner.py` (inferred):
- Uses `validation_pattern` and `validation_separator` for text input
- No client-side form validation (TUI doesn't use forms)

### Server-Side Implementation

From `server/modules/user/form.py:220-242`:
- `_validate_item()` validates required fields
- Happens after client submission
- Errors thrown as ModuleExecutionError

## Root Cause Analysis

### Why Not Documented

1. **Focus on Server Logic**: Architecture documents focused on server-side workflow execution
2. **Client Implementation Detail**: Client validation seen as implementation detail
3. **Incremental Development**: Added as needed during WebUI development

### Why It Matters

1. **Consistency**: WebUI and TUI should validate consistently
2. **UX Quality**: Users should get immediate feedback, not after submission
3. **Schema Reuse**: Same validation schema should work client and server
4. **Error Handling**: Client and server errors should look the same to user

## Impact

### Current Impact

**Medium**:
- WebUI has ad-hoc validation
- TUI has pattern-based validation for text input
- No unified validation strategy
- Server catches what client misses

### UX Impact

1. **Delayed Feedback**: Some errors only appear after server round-trip
2. **Inconsistent Messages**: Client and server may show different error formats
3. **Incomplete Validation**: Client may miss validations that server catches

## Proposed Solution(s)

<!--I dont like these custom solutions. Can we use libraries in server and client side to use commonly used validation schema like https://json-schema.org/draft/2020-12/schema which we should be able to find i think, and probably wrap it around our module to normalize outputs? this will give us best capabilities without worrying about mismatches in how validation has been done. dig deep into how this schema works and how it can make things easier or harder for us.-->

### Solution 1: Document Client Validation Contract (Recommended)

Add to architecture documentation:

**Client Validation Requirements**

1. **Form Interactions (`user.form`)**
   - Client MUST validate against `input_schema` before submission
   - Validation runs on field blur and form submit
   - Errors displayed inline near fields
   - Submit button disabled while validation errors exist

2. **Text Input Interactions (`user.text_input`)**
   - Client SHOULD validate against `validation_pattern` if provided
   - Show error message from `validation_error` field
   - Allow submission to let server do final validation

3. **Schema Source**
   - InteractionRequest includes validation schema
   - Same schema used by server's io.validate

4. **Error Format**
   ```typescript
   interface ValidationError {
     field: string;      // Field path (e.g., "items[0].count")
     message: string;    // Human-readable error
     code?: string;      // Error type for i18n
   }
   ```

### Solution 2: Create Shared Validation Library

Create validation utilities that work in both:
- Python (server)
- TypeScript (WebUI)
- Python (TUI, if needed)

```typescript
// webui/src/lib/validation.ts
export function validateAgainstSchema(
  data: unknown,
  schema: JSONSchema
): ValidationError[] {
  // JSON Schema validation
  // Returns array of errors (empty if valid)
}
```

```python
# contracts/validation.py
def validate_against_schema(data: Any, schema: dict) -> list[ValidationError]:
    """Validate data against JSON schema."""
    # Same logic as TypeScript version
```

### Solution 3: Server-Provided Validation Endpoint

Add endpoint for client to validate without submitting:

```
POST /workflow/{run_id}/validate
{
  "module_name": "aesthetic_form",
  "data": {...}
}

Response:
{
  "valid": true/false,
  "errors": [...]
}
```

**Benefits:**
- Single source of truth (server)
- No duplicate validation logic

**Drawbacks:**
- Network latency for every validation
- Not suitable for real-time validation

## Files Affected

### Documentation
1. **architecture/2026_01_XX_client_validation.md** - New architecture document

### Implementation (if Solution 2)
1. **webui/src/lib/validation.ts** - Shared validation utilities
2. **contracts/validation.py** - Python validation utilities
3. **webui/src/components/interactions/FormInteraction.tsx** - Use shared validation

### Implementation (if Solution 3)
1. **server/api/routes/workflow.py** - Add validation endpoint
2. **webui/src/lib/api.ts** - Add validate API call

## Priority

**Medium**

**Justification:**
- Current WebUI has working validation (ad-hoc)
- Not blocking functionality
- Improves UX and code quality
- Should be addressed before adding more form types

## Testing Plan

1. Document validation requirements
2. Review current WebUI validation against spec
3. Add/update WebUI validation to match spec
4. Test form validation with various error scenarios
5. Verify error messages match between client and server
6. Test validation with edge cases (empty, max values, etc.)
