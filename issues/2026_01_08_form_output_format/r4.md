# Issue: user.form Output Format Missing `_item` and `_index`

## Summary

The `user.form` module does not include `_item` (original data item) and `_index` (position in source array) in its output, as specified in the architecture documents. This causes the webui_path in aesthetic selection to require 5+ modules instead of the expected 2 modules.

## Architecture Reference

- [R5 Part 4](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Generic `user.form` Module" - Output structure specification
- [R5 Part 7](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Complete Example" - Shows webui_path with only 2 modules
- [R9](../architecture/2026_01_06_aesthetic_selection_ux/r9.md): References user.form module design from R5

## Before/After JSON Examples

### Example: Aesthetic Selection Form

#### Module Input (data + schema)

```json
{
  "data": [
    {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
    {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
    {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"}
  ],
  "schema": {
    "type": "object",
    "properties": {
      "label": {"type": "string", "display": "title"},
      "description": {"type": "string", "display": "subtitle"}
    },
    "input_schema": {
      "type": "object",
      "properties": {
        "count": {"type": "number", "minimum": 0, "maximum": 10, "default": 0},
        "mode": {"type": "string", "enum": ["q", "w", "e"], "default": "e"}
      }
    }
  },
  "prompt": "Select aesthetics and specify count"
}
```

#### Client Response Options

**Option A: Client returns ALL items (current assumption)**

Client returns one entry per data item, even if user didn't modify it:

```json
{
  "form_data": [
    {"count": 2, "mode": "w"},
    {"count": 0, "mode": "e"},
    {"count": 4, "mode": "q"}
  ]
}
```

Server enriches by position: `form_data[i]` → `data[i]`

**Option B: Client returns ONLY selected items (>= 1 required)**

Client only returns items where user made a selection (e.g., count > 0):

```json
{
  "form_data": [
    {"_index": 0, "count": 2, "mode": "w"},
    {"_index": 2, "count": 4, "mode": "q"}
  ]
}
```

Client includes `_index` so server knows which data item it refers to.

### Design Question: Which approach?

| Aspect | Option A (All Items) | Option B (Selected Only) |
|--------|---------------------|--------------------------|
| Client sends | All rows, even unchanged | Only modified/selected rows |
| Correlation | By position (implicit) | By `_index` field (explicit) |
| Filtering | Server filters count=0 | Already filtered |
| Payload size | Larger | Smaller |
| Client complexity | Simpler | Must track indices |

**Recommendation**: Option A (All Items) is simpler because:
1. Position-based correlation is straightforward
2. Filtering can be done in transform.reshape with `_include`
3. Client doesn't need to track which indices were modified
4. Consistent with current implementation

#### Expected Output (With `_item` and `_index`)

Assuming Option A (all items returned):

```json
{
  "form_data": [
    {
      "_item": {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
      "_index": 0,
      "count": 2,
      "mode": "w"
    },
    {
      "_item": {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
      "_index": 1,
      "count": 0,
      "mode": "e"
    },
    {
      "_item": {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"},
      "_index": 2,
      "count": 4,
      "mode": "q"
    }
  ]
}
```

Then `transform.reshape` filters out count=0 items:

```json
{
  "template": {
    "_for_each": "$item",
    "_output": {
      "aesthetic": "{{ $item._item }}",
      "count": "{{ $item.count }}",
      "_include": "{{ $item.count > 0 }}"
    }
  }
}
```

### Workflow Impact: Before vs After

#### BEFORE: 5 Modules in webui_path

```
1. user.form           → outputs raw form_data (no context)
2. transform.reshape   → manually correlate with aesthetics[$index]
3. transform.extract   → filter items where count > 0
4. io.write_state      → set validation flags
5. transform.render_template_array → render prompt sections
```

#### AFTER: 2 Modules in webui_path

```
1. user.form           → outputs form_data with _item, _index
2. transform.reshape   → transform to final format (filter with _include)
```

## Proposed Solution

### Implementation in user.form Module

```python
def execute_with_response(
    self,
    inputs: Dict[str, Any],
    context,
    response: InteractionResponse
) -> Dict[str, Any]:
    """Process form response."""
    if response.cancelled:
        raise ModuleExecutionError(
            self.module_id,
            "User cancelled form input",
            None
        )

    form_data = response.form_data
    data = inputs.get('data', [])

    # Normalize form_data to list format
    if isinstance(form_data, dict):
        form_data = [form_data.get(str(i), {}) for i in range(len(data))]
    elif not isinstance(form_data, list):
        raise ModuleExecutionError(
            self.module_id,
            f"Invalid form_data type: expected list or dict, got {type(form_data).__name__}",
            None
        )

    # Validate at least one item
    if len(form_data) == 0:
        raise ModuleExecutionError(
            self.module_id,
            "Form data is empty: at least one item required",
            None
        )

    # Handle partial submissions (Option B) if client sends fewer items with _index
    # Or full submissions (Option A) if client sends all items by position
    if len(form_data) < len(data) and all('_index' in item for item in form_data):
        # Option B: Client sent selected items with explicit _index
        merged_form_data = []
        for item_data in form_data:
            idx = item_data.get('_index')
            if idx is None or idx < 0 or idx >= len(data):
                raise ModuleExecutionError(
                    self.module_id,
                    f"Invalid _index value: {idx}",
                    None
                )
            merged_item = {
                "_item": data[idx],
                "_index": idx,
                **{k: v for k, v in item_data.items() if k != '_index'}
            }
            merged_form_data.append(merged_item)
    else:
        # Option A: Client sent all items, correlate by position
        # Validate length matches
        if len(form_data) != len(data):
            raise ModuleExecutionError(
                self.module_id,
                f"Form data length mismatch: expected {len(data)} items, got {len(form_data)}",
                None
            )

        # Validate each item
        schema = inputs.get('schema', {})
        input_schema = schema.get('input_schema', {})
        if input_schema:
            for i, item_data in enumerate(form_data):
                self._validate_item(item_data, input_schema, i, context)

        # Merge by position
        merged_form_data = []
        for i, item_data in enumerate(form_data):
            merged_item = {
                "_item": data[i],
                "_index": i,
                **item_data
            }
            merged_form_data.append(merged_item)

    if hasattr(context, 'logger'):
        context.logger.debug(f"Form submitted with {len(merged_form_data)} items")

    return {
        "form_data": merged_form_data
    }
```

**This implementation supports both approaches:**
- Option A: Client sends all items → correlate by position
- Option B: Client sends selected items with `_index` → correlate by explicit index

## Files Affected

1. **server/modules/user/form.py** - Add `_item` and `_index` to output
2. **workflows/oms/steps/1_user_input/modules/07_aesthetic_selection_group.json** - Simplify webui_path after fix

## Priority

**Critical**

## Testing Plan

1. Test Option A: Client sends all items, verify position-based correlation
2. Test Option B: Client sends selected items with `_index`, verify explicit correlation
3. Test empty form_data → should raise error
4. Test invalid `_index` values → should raise error
5. Update aesthetic_selection_group.json to use simplified structure
6. End-to-end test WebUI aesthetic selection flow
