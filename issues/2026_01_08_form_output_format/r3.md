# Issue: user.form Output Format Missing `_item` and `_index`

## Summary

The `user.form` module does not include `_item` (original data item) and `_index` (position in source array) in its output, as specified in the architecture documents. This causes the webui_path in aesthetic selection to require 5+ modules instead of the expected 2 modules.

## Architecture Reference

- [R5 Part 4](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Generic `user.form` Module" - Output structure specification
- [R5 Part 7](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Complete Example" - Shows webui_path with only 2 modules
- [R9](../architecture/2026_01_06_aesthetic_selection_ux/r9.md): References user.form module design from R5

## Before/After JSON Examples

### Example: Aesthetic Selection Form

#### Module Input (data + schema)

```json
{
  "data": [
    {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
    {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
    {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"}
  ],
  "schema": {
    "type": "object",
    "properties": {
      "label": {"type": "string", "display": "title"},
      "description": {"type": "string", "display": "subtitle"}
    },
    "input_schema": {
      "type": "object",
      "properties": {
        "count": {"type": "number", "minimum": 0, "maximum": 10, "default": 0},
        "mode": {"type": "string", "enum": ["q", "w", "e"], "default": "e"}
      }
    }
  },
  "prompt": "Select aesthetics and specify count"
}
```

#### Client Response (form_data from WebUI)

What the client submits after user fills the form:

```json
{
  "form_data": [
    {"count": 2, "mode": "w"},
    {"count": 0, "mode": "e"},
    {"count": 4, "mode": "q"}
  ]
}
```

#### Current Output (BEFORE - Missing `_item` and `_index`)

```json
{
  "form_data": [
    {"count": 2, "mode": "w"},
    {"count": 0, "mode": "e"},
    {"count": 4, "mode": "q"}
  ]
}
```

**Problem**: No way to know which aesthetic each entry refers to. Workflow must manually correlate by index using extra transform modules.

#### Expected Output (AFTER - With `_item` and `_index`)

```json
{
  "form_data": [
    {
      "_item": {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
      "_index": 0,
      "count": 2,
      "mode": "w"
    },
    {
      "_item": {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
      "_index": 1,
      "count": 0,
      "mode": "e"
    },
    {
      "_item": {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"},
      "_index": 2,
      "count": 4,
      "mode": "q"
    }
  ]
}
```

**Benefit**: Each entry is self-contained. transform.reshape can directly access `$item._item.id` without needing external context.

### Workflow Impact: Before vs After

#### BEFORE: 5 Modules in webui_path

```
1. user.form           → outputs raw form_data (no context)
2. transform.reshape   → manually correlate with aesthetics[$index]
3. transform.extract   → filter items where count > 0
4. io.write_state      → set validation flags
5. transform.render_template_array → render prompt sections
```

#### AFTER: 2 Modules in webui_path

```
1. user.form           → outputs form_data with _item, _index
2. transform.reshape   → transform to final format (can filter inline)
```

## Proposed Solution

### Implementation in user.form Module

Modify `server/modules/user/form.py` in `execute_with_response()`:

```python
def execute_with_response(
    self,
    inputs: Dict[str, Any],
    context,
    response: InteractionResponse
) -> Dict[str, Any]:
    """Process form response."""
    # Handle cancellation
    if response.cancelled:
        raise ModuleExecutionError(
            self.module_id,
            "User cancelled form input",
            None
        )

    # Get form data from response
    form_data = response.form_data
    data = inputs.get('data', [])

    # Normalize form_data to list format
    # Client may send: list (normal), dict keyed by index, or invalid type
    if isinstance(form_data, dict):
        # Dict format: {"0": {...}, "1": {...}} - convert to list
        form_data = [form_data.get(str(i), {}) for i in range(len(data))]
    elif not isinstance(form_data, list):
        # Invalid type (None, string, etc.) - raise error instead of silently continuing
        raise ModuleExecutionError(
            self.module_id,
            f"Invalid form_data type: expected list or dict, got {type(form_data).__name__}",
            None
        )

    # Validate length matches
    #
    # The form displays exactly len(data) rows (one per aesthetic).
    # The client should return exactly len(data) items in form_data.
    #
    # Example: If data has 8 aesthetics, form_data should have 8 items.
    # Each form_data[i] corresponds to data[i] by position.
    <!--this is not correct, client doesnt have to add data for all 
        aesthetics, only rule is it has to be >=1, thats it. -->
    #
    # Mismatch indicates client bug:
    # - Too few: Client didn't include all rows
    # - Too many: Client added extra data somehow
    #
    # This check ensures we can safely do data[i] in the merge loop below.
    if len(form_data) != len(data):
        raise ModuleExecutionError(
            self.module_id,
            f"Form data length mismatch: expected {len(data)} items, got {len(form_data)}",
            None
        )

    # Validate each item against input_schema
    # If validation fails, _validate_item raises ModuleExecutionError
    # which stops workflow execution and shows error to user
    schema = inputs.get('schema', {})
    input_schema = schema.get('input_schema', {})
    if input_schema:
        for i, item_data in enumerate(form_data):
            self._validate_item(item_data, input_schema, i, context)

    # Merge original data items with user input
    merged_form_data = []
    for i, item_data in enumerate(form_data):
        merged_item = {
            "_item": data[i],  # Original data object
            "_index": i,       # Position in array
            **item_data        # User input fields
        }
        merged_form_data.append(merged_item)

    if hasattr(context, 'logger'):
        context.logger.debug(f"Form submitted with {len(merged_form_data)} items")

    return {
        "form_data": merged_form_data
    }
```

### Key Changes from Current Implementation

| Aspect | Current Behavior | Proposed Behavior |
|--------|------------------|-------------------|
| Invalid type | Silently set to `[]`, continue with empty data | Raise `ModuleExecutionError` with clear message |
| Length mismatch | No check, may cause index errors later | Validate upfront, raise error if mismatch |
| Validation failure | Raises `ModuleExecutionError`, stops workflow | Same - this is correct behavior |
| Output format | Raw user input only | Enriched with `_item` and `_index` |

### Validation Failure Behavior

When `_validate_item` fails (e.g., missing required field):

```python
# Current _validate_item raises:
raise ModuleExecutionError(
    self.module_id,
    f"Item {index + 1}: Missing required fields: {', '.join(missing)}",
    None
)
```

This:
1. Stops workflow execution immediately
2. Returns error to client via SSE `workflow_error` event
3. Client displays error message to user
4. User can fix and resubmit (if module has `retryable` config)

This is the **correct behavior** - validation errors should halt execution, not silently continue.

### Naming Convention Rationale

Looking at existing modules:
- `transform.enrich` → outputs `enriched_data`
- `transform.reshape` → outputs `result`
- `user.form` → outputs `form_data`

The `_item` and `_index` naming follows the convention from R5 architecture and is consistent with:
- `_group_origin` in flattened modules
- `_include` filter field in transform.reshape
- Underscore prefix for system/metadata fields

## Files Affected

1. **server/modules/user/form.py** - Add `_item` and `_index` to output, improve error handling
2. **workflows/oms/steps/1_user_input/modules/07_aesthetic_selection_group.json** - Simplify webui_path after fix

## Priority

**Critical**

**Justification:**
- Direct violation of architecture specification (R5)
- Causes 2.5x module bloat in workflows (5 modules instead of 2)
- Foundation issue that affects all user.form usage
- Fixing this enables proper workflow simplification

## Testing Plan

1. Unit test user.form module with sample data
2. Verify output contains `_item` and `_index` for each item
3. Verify user input fields are preserved
4. Test with empty data array → should return empty form_data
5. Test with mismatched form_data length → should raise error
6. Test with invalid form_data type (None, string) → should raise error
7. Test validation failure → should raise ModuleExecutionError
8. Update aesthetic_selection_group.json to use simplified structure
9. End-to-end test WebUI aesthetic selection flow
