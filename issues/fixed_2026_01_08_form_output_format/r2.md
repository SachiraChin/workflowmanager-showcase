# Issue: user.form Output Format Missing `_item` and `_index`

## Summary

The `user.form` module does not include `_item` (original data item) and `_index` (position in source array) in its output, as specified in the architecture documents. This causes the webui_path in aesthetic selection to require 5+ modules instead of the expected 2 modules.

## Architecture Reference

- [R5 Part 4](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Generic `user.form` Module" - Output structure specification
- [R5 Part 7](../architecture/2026_01_06_aesthetic_selection_ux/r5.md): "Complete Example" - Shows webui_path with only 2 modules
- [R9](../architecture/2026_01_06_aesthetic_selection_ux/r9.md): References user.form module design from R5

## Before/After JSON Examples

### Example: Aesthetic Selection Form

#### Module Input (data + schema)

```json
{
  "data": [
    {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
    {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
    {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"}
  ],
  "schema": {
    "type": "object",
    "properties": {
      "label": {"type": "string", "display": "title"},
      "description": {"type": "string", "display": "subtitle"}
    },
    "input_schema": {
      "type": "object",
      "properties": {
        "count": {"type": "number", "minimum": 0, "maximum": 10, "default": 0},
        "mode": {"type": "string", "enum": ["q", "w", "e"], "default": "e"}
      }
    }
  },
  "prompt": "Select aesthetics and specify count"
}
```

#### Client Response (form_data from WebUI)

What the client submits after user fills the form:

```json
{
  "form_data": [
    {"count": 2, "mode": "w"},
    {"count": 0, "mode": "e"},
    {"count": 4, "mode": "q"}
  ]
}
```

#### Current Output (BEFORE - Missing `_item` and `_index`)

```json
{
  "form_data": [
    {"count": 2, "mode": "w"},
    {"count": 0, "mode": "e"},
    {"count": 4, "mode": "q"}
  ]
}
```

**Problem**: No way to know which aesthetic each entry refers to. Workflow must manually correlate by index using extra transform modules.

#### Expected Output (AFTER - With `_item` and `_index`)

```json
{
  "form_data": [
    {
      "_item": {"id": "futuristic", "label": "Futuristic", "description": "Forward-looking environments"},
      "_index": 0,
      "count": 2,
      "mode": "w"
    },
    {
      "_item": {"id": "mystical", "label": "Mystical", "description": "Ethereal, dreamlike realms"},
      "_index": 1,
      "count": 0,
      "mode": "e"
    },
    {
      "_item": {"id": "nature", "label": "Nature", "description": "Big landscapes and elemental forces"},
      "_index": 2,
      "count": 4,
      "mode": "q"
    }
  ]
}
```

**Benefit**: Each entry is self-contained. transform.reshape can directly access `$item._item.id` without needing external context.

### Workflow Impact: Before vs After

#### BEFORE: 5 Modules in webui_path

```
1. user.form           → outputs raw form_data (no context)
2. transform.reshape   → manually correlate with aesthetics[$index]
3. transform.extract   → filter items where count > 0
4. io.write_state      → set validation flags
5. transform.render_template_array → render prompt sections
```

#### AFTER: 2 Modules in webui_path

```
1. user.form           → outputs form_data with _item, _index
2. transform.reshape   → transform to final format (can filter inline)
```

The `_item` field allows transform.reshape to access the original aesthetic directly:

```json
{
  "template": {
    "_for_each": "$item",
    "_output": {
      "aesthetic": "{{ $item._item }}",
      "mode": "{{ {'q': 'without_person', 'w': 'with_person', 'e': 'both'}[$item.mode] }}",
      "count": "{{ $item.count }}",
      "_include": "{{ $item.count > 0 }}"
    }
  }
}
```

## Proposed Solution

### Implementation in user.form Module

Modify `server/modules/user/form.py` in `execute_with_response()`:

```python
def execute_with_response(
    self,
    inputs: Dict[str, Any],
    context,
    response: InteractionResponse
) -> Dict[str, Any]:
    """Process form response."""
    # Handle cancellation
    if response.cancelled:
        raise ModuleExecutionError(
            self.module_id,
            "User cancelled form input",
            None
        )

    # Get form data from response
    form_data = response.form_data
    data = inputs.get('data', [])

    # Ensure form_data is a list
    if isinstance(form_data, dict):
        form_data = [form_data.get(str(i), {}) for i in range(len(data))]
    elif not isinstance(form_data, list):
        <!--whats purpose of setting this continuing, by the looks of rest of the code, it looks like nothing gonna happen if this the case is is not? looks like if form_data is a list, we override it, is that how it meant to work? -->
        form_data = []

    # Validate each item against input_schema
    schema = inputs.get('schema', {})
    input_schema = schema.get('input_schema', {})
    if input_schema:
        for i, item_data in enumerate(form_data):
            <!--what would happen if validation fails?-->
            self._validate_item(item_data, input_schema, i, context)

    # Merge original data items with user input
    merged_form_data = []
    for i, item_data in enumerate(form_data):
        merged_item = {
            "_item": data[i] if i < len(data) else None,
            "_index": i,
        }
        # Add user input fields
        merged_item.update(item_data)
        merged_form_data.append(merged_item)

    if hasattr(context, 'logger'):
        context.logger.debug(f"Form submitted with {len(merged_form_data)} items")

    return {
        "form_data": merged_form_data
    }
```

**Key changes:**
- Output name remains `form_data` (consistent with current interface)
- Each item gets `_item` (original data object) and `_index` (position)
- User input fields are merged after the metadata fields
- Uses underscore prefix (`_item`, `_index`) to distinguish metadata from user input

### Naming Convention Rationale

Looking at existing modules:
- `transform.enrich` → outputs `enriched_data`
- `transform.reshape` → outputs `result`
- `user.form` → outputs `form_data`

The `_item` and `_index` naming follows the convention from R5 architecture and is consistent with:
- `_group_origin` in flattened modules
- `_include` filter field in transform.reshape
- Underscore prefix for system/metadata fields

## Files Affected

1. **server/modules/user/form.py** - Add `_item` and `_index` to output
2. **workflows/oms/steps/1_user_input/modules/07_aesthetic_selection_group.json** - Simplify webui_path after fix

## Priority

**Critical**

**Justification:**
- Direct violation of architecture specification (R5)
- Causes 2.5x module bloat in workflows (5 modules instead of 2)
- Foundation issue that affects all user.form usage
- Fixing this enables proper workflow simplification

## Testing Plan

1. Unit test user.form module with sample data
2. Verify output contains `_item` and `_index` for each item
3. Verify user input fields are preserved
4. Test with empty data array
5. Test with mismatched form_data length (edge case)
6. Update aesthetic_selection_group.json to use simplified structure
7. End-to-end test WebUI aesthetic selection flow
