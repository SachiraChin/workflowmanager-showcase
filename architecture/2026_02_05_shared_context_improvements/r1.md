# Shared/WebUI Context Architecture Improvements

## Summary

During the migration to the `@wfm/shared` package, several type safety and
architectural issues were introduced. This document identifies the problems
and proposes improvements to make the context sharing more robust.

## Current Architecture

```
ui/webui/                          ui/shared/
├── adapters/                      ├── contexts/
│   ├── WebUIMediaAdapter.tsx      │   ├── MediaAdapterContext.tsx
│   ├── WebUIRenderProvider.tsx    │   ├── interaction-context.tsx
│   └── WebUISubActionExecutor.ts  │   ├── sub-action-context.tsx
│                                  │   └── validation-context.tsx
└── state/                         │
    └── workflow-store.ts          └── interactions/types/media-generation/
                                       ├── ImageGeneration.tsx
                                       ├── VideoGeneration.tsx
                                       └── AudioGeneration.tsx
```

The pattern is: `webui` provides concrete implementations via adapters,
`shared` defines abstract interfaces and components that consume them.

## Identified Issues

### Issue 1: Inconsistent Nullability (null vs undefined)

**Location**: `MediaAdapter` interface and implementations

```typescript
// MediaAdapterContext.tsx
getWorkflowRunId: () => string | null;
getSelectedProvider: () => string | undefined;
getSelectedModel: () => string | undefined;

// WebUIMediaAdapter.tsx - workflow store uses null
const workflowRunId = useWorkflowStore((s) => s.workflowRunId);  // string | null
const selectedProvider = useWorkflowStore((s) => s.selectedProvider);  // string | null

// Adapter converts null to undefined for provider/model but not workflowRunId
getWorkflowRunId: () => workflowRunId,  // passes null
getSelectedProvider: () => selectedProvider ?? undefined,  // converts to undefined
```

**Problem**: Inconsistent handling creates confusion. Consumers must handle
both `null` and `undefined` depending on which method they call.

**Recommendation**: Standardize on `null` for "not available" state since
that's what the workflow store uses. Update the interface:

```typescript
getWorkflowRunId: () => string | null;
getSelectedProvider: () => string | null;
getSelectedModel: () => string | null;
```

### Issue 2: Inconsistent Error Handling in Adapter

**Location**: `WebUIMediaAdapter.tsx`

```typescript
// getInteractionGenerations - silent fallback
if (!workflowRunId) {
  return { generations: [] };
}

// getMediaPreview - throws
if (!workflowRunId) {
  throw new Error("No active workflow");
}

// streamSubAction - error callback
if (!workflowRunId) {
  onError(new Error("No active workflow"));
  return;
}
```

**Problem**: Three different error handling strategies for the same condition.

**Recommendation**: Standardize on one approach per method type:
- Async methods that return data: throw Error (caller can catch)
- Streaming methods with callbacks: use error callback
- Methods where empty is valid: return empty (document clearly)

### Issue 3: Context Object Instability Causing Re-renders

**Location**: `InputSchemaComposer.tsx` -> `ImageGeneration.tsx`

The `inputContext` object is recreated when any value changes because
`values` is in the `useMemo` dependency array:

```typescript
// InputSchemaComposer.tsx
const contextValue = useMemo(() => ({
  values,
  getValue,
  setValue,
  // ...
}), [sourceData, values, errors, ...]);  // values triggers recreation
```

When `ImageGeneration` calls `inputContext.setValue()` inside a `useEffect`,
it changes `values`, which recreates `contextValue`, which changes the
`inputContext` reference, which re-triggers the effect → infinite loop.

**Fixed in this session**: Removed `inputContext` from dependency array with
eslint-disable comment.

**Better long-term solution**: Split context into stable functions vs
reactive values:

```typescript
// Stable context (never changes)
interface InputSchemaActions {
  getValue: (key: string) => unknown;
  setValue: (key: string, value: unknown) => void;
  getMappedValues: () => Record<string, unknown>;
  // ... other functions
}

// Reactive context (changes when values change)
interface InputSchemaState {
  values: Record<string, unknown>;
  errors: Record<string, string>;
  // ... other state
}

// Two separate contexts
const InputSchemaActionsContext = createContext<InputSchemaActions | null>(null);
const InputSchemaStateContext = createContext<InputSchemaState | null>(null);
```

Components that only need to call functions use `useInputSchemaActions()` -
they won't re-render when values change. Components that need reactive
values use `useInputSchemaState()`.

### Issue 4: Optional Fields Used Without Guards

**Location**: `MediaGrid.tsx`

```typescript
// Line 95, 140 - non-null assertion on optional field
gen.content_ids!.map((contentId, idx) => {...}
```

The `content_ids` field is optional in `GenerationResult`:

```typescript
interface GenerationResult {
  urls: string[];
  metadata_id?: string;
  content_ids?: string[];
}
```

**Problem**: While there's a filter before this that checks
`gen.content_ids && gen.content_ids.length > 0`, TypeScript doesn't narrow
through `filter()`, so the assertion is needed. But if the filter logic
changes, the assertion becomes unsafe.

**Recommendation**: Use defensive coding:

```typescript
// Instead of:
gen.content_ids!.map(...)

// Use:
(gen.content_ids ?? []).map(...)
```

### Issue 5: Missing Required Field Guarantees

**Location**: Various components consuming `InteractionRequest`

The `InteractionRequest` type has many optional fields:

```typescript
interface InteractionRequest {
  interaction_id: string;  // Required
  interaction_type: InteractionType;  // Required
  title?: string;  // Optional
  display_data?: Record<string, unknown>;  // Optional
  // ... many more optional fields
}
```

Components often access these without guards:

```typescript
const displayData = request.display_data || {};
const data = displayData.data as Record<string, unknown>;  // Unsafe cast
```

**Recommendation**: Create discriminated unions for different interaction
types with their required fields:

```typescript
interface BaseInteractionRequest {
  interaction_id: string;
  interaction_type: InteractionType;
}

interface MediaGenerationRequest extends BaseInteractionRequest {
  interaction_type: "media_generate";
  display_data: {
    data: Record<string, unknown>;
    schema: SchemaProperty;
    sub_actions: SubActionConfig[];
  };
}

interface SelectRequest extends BaseInteractionRequest {
  interaction_type: "select";
  options: SelectOption[];
  display_data: {
    data: Record<string, unknown>;
    schema: SchemaProperty;
  };
}

type InteractionRequest = 
  | MediaGenerationRequest 
  | SelectRequest 
  | TextInputRequest 
  | ...;
```

This makes TypeScript enforce that required fields exist for each type.

### Issue 6: Adapter Methods Not Validating Inputs

**Location**: `WebUIMediaAdapter.tsx`

```typescript
getInteractionGenerations: async (
  interactionId: string,  // Could be empty string
  mediaType?: string
) => {
  if (!workflowRunId) {
    return { generations: [] };
  }
  // interactionId not validated!
  const response = await api.getInteractionGenerations(...);
}
```

**Recommendation**: Validate all required parameters:

```typescript
getInteractionGenerations: async (interactionId, mediaType) => {
  if (!workflowRunId) {
    return { generations: [] };
  }
  if (!interactionId) {
    console.error("[MediaAdapter] interactionId is required");
    return { generations: [] };
  }
  // ...
}
```

## Proposed Improvements Priority

1. **High - Fix immediately**:
   - Issue 4: Replace non-null assertions with nullish coalescing
   - Issue 6: Add input validation to adapter methods

2. **Medium - Address in next refactor**:
   - Issue 1: Standardize nullability (null everywhere)
   - Issue 2: Standardize error handling patterns

3. **Low - Consider for future architecture**:
   - Issue 3: Split contexts into actions/state
   - Issue 5: Discriminated unions for request types

## Questions for Review

1. Should we prioritize fixing the non-null assertions now?

2. For Issue 3 (context splitting), is the complexity worth the benefit?
   The eslint-disable approach works but is a code smell.

3. For Issue 5 (discriminated unions), this would be a significant type
   refactor. Is it worth the effort given the current stability?
