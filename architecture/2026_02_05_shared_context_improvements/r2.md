# Shared/WebUI Context Architecture Improvements

## Summary

During the migration to the `@wfm/shared` package, several type safety and
architectural issues were introduced. This document identifies the problems
and proposes improvements to make the context sharing more robust.

## Migration Context

The migration moved interaction components from `ui/webui/src/interactions/`
to `ui/shared/src/interactions/`. The key architectural change was
introducing the **adapter pattern** to abstract webui-specific dependencies:

**Before (webui - direct access):**
```typescript
import { useWorkflowStore } from "@/state/workflow-store";
import { api } from "@/core/api";
import { toMediaUrl } from "@/core/config";

const workflowRunId = useWorkflowStore((s) => s.workflowRunId);
const response = await api.getInteractionGenerations(workflowRunId, ...);
```

**After (shared - via adapter):**
```typescript
import { useMediaAdapter } from "../../../contexts/MediaAdapterContext";

const adapter = useMediaAdapter();
const workflowRunId = adapter.getWorkflowRunId();
const response = await adapter.getInteractionGenerations(...);
```

## Current Architecture

```
ui/webui/                          ui/shared/
├── adapters/                      ├── contexts/
│   ├── WebUIMediaAdapter.tsx      │   ├── MediaAdapterContext.tsx
│   ├── WebUIRenderProvider.tsx    │   ├── interaction-context.tsx
│   └── WebUISubActionExecutor.ts  │   ├── sub-action-context.tsx
│                                  │   └── validation-context.tsx
└── state/                         │
    └── workflow-store.ts          └── interactions/types/media-generation/
                                       ├── ImageGeneration.tsx
                                       ├── VideoGeneration.tsx
                                       └── AudioGeneration.tsx
```

## Issue 1: Dependency Array Expansion Causing Infinite Loop

### Root Cause

During migration, ImageGeneration.tsx had its useEffect dependency array
incorrectly expanded with `inputContext`:

**Original (webui) - line 147:**
```typescript
}, [mediaContext, workflowRunId, request.interaction_id, readonly, provider, promptId]);
```

**Migrated (shared) - line 144:**
```typescript
}, [mediaContext, workflowRunId, request.interaction_id, readonly, provider, promptId, 
    adapter, inputContext, promptKey, registerGeneration]);
```

The addition of `inputContext` caused infinite loops because:
1. Effect runs and calls `inputContext.setValue()` to restore saved params
2. `setValue()` changes `values` state in InputSchemaComposer
3. `values` is in useMemo deps, so `contextValue` is recreated
4. `inputContext` reference changes
5. Effect re-runs → goto step 1

### Comparison with Video/Audio

VideoGeneration and AudioGeneration kept the **original** dependency arrays
and did NOT have this issue:

| Component | Original deps | Migrated deps | Issue? |
|-----------|--------------|---------------|--------|
| ImageGeneration | 6 deps | 10 deps (added adapter, inputContext, promptKey, registerGeneration) | YES |
| VideoGeneration | 6 deps | 6 deps (unchanged) | NO |
| AudioGeneration | 6 deps | 6 deps (unchanged) | NO |

### Current Fix (Applied This Session)

Removed `inputContext` and `readonly` from the dependency array with
eslint-disable comment:

```typescript
loadGenerations();
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [mediaContext, workflowRunId, request.interaction_id, provider, promptId, 
    adapter, promptKey, registerGeneration]);
```

### Question 1: Alignment Strategy

Should ImageGeneration's deps match VideoGeneration/AudioGeneration?

**Option A - Align with Video/Audio (6 deps):**
```typescript
}, [mediaContext, workflowRunId, request.interaction_id, readonly, provider, promptId]);
```
- Pros: Consistent, matches proven working pattern
- Cons: `adapter`, `promptKey`, `registerGeneration` used inside but not in deps
        (lint violation, though safe since they're stable)

**Option B - Keep current fix (8 deps + eslint-disable):**
```typescript
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [mediaContext, workflowRunId, request.interaction_id, provider, promptId, 
    adapter, promptKey, registerGeneration]);
```
- Pros: More explicit about dependencies
- Cons: eslint-disable is a code smell, still different from Video/Audio

**Option C - Fix Video/Audio to match new pattern:**
- Pros: All three components consistent with explicit deps
- Cons: Risk introducing bugs to working code

**Decision**: Keep current fix (Option B) - explicit deps with eslint-disable.

## Issue 2: Inconsistent Nullability (null vs undefined)

### Original Types (workflow-store.ts)

```typescript
// All three use null in the original store
workflowRunId: string | null;
selectedProvider: string | null;
selectedModel: string | null;
```

### Current Types (MediaAdapter interface)

```typescript
// Inconsistent - workflowRunId is null, others are undefined
getWorkflowRunId: () => string | null;
getSelectedProvider: () => string | undefined;
getSelectedModel: () => string | undefined;
```

### Adapter Implementation (WebUIMediaAdapter.tsx)

```typescript
// Converts null to undefined for provider/model, but not workflowRunId
getWorkflowRunId: () => workflowRunId,              // passes null through
getSelectedProvider: () => selectedProvider ?? undefined,  // null → undefined
getSelectedModel: () => selectedModel ?? undefined,        // null → undefined
```

### Question 2: Nullability Standard

**Option A - Standardize on null (matches original store):**
```typescript
getWorkflowRunId: () => string | null;
getSelectedProvider: () => string | null;
getSelectedModel: () => string | null;
```
- Pros: Matches workflow store, no conversion needed in adapter
- Cons: `null` is less common in JS/TS than `undefined`

**Option B - Standardize on undefined:**
```typescript
getWorkflowRunId: () => string | undefined;
getSelectedProvider: () => string | undefined;
getSelectedModel: () => string | undefined;
```
- Pros: More idiomatic JS/TS
- Cons: Requires conversion from store's null values

**Option C - Leave as-is:**
- Pros: No changes needed, works currently
- Cons: Confusing API, consumers must handle both null and undefined

**Decision**: Option A - Standardize on null (matches original workflow store).
Applied in this PR.

## Issue 3: Inconsistent Error Handling in Adapter

### Current Behavior (WebUIMediaAdapter.tsx)

```typescript
// getInteractionGenerations - silent fallback (returns empty)
if (!workflowRunId) {
  return { generations: [] };
}

// getMediaPreview - throws error
if (!workflowRunId) {
  throw new Error("No active workflow");
}

// streamSubAction - error callback
if (!workflowRunId) {
  onError(new Error("No active workflow"));
  return;
}
```

### Question 3: Error Handling Strategy

**Option A - Standardize per method type:**
- Async data methods: throw Error
- Streaming methods: use error callback
- Query methods where empty is valid: return empty

**Option B - Always throw (let caller decide):**
- All methods throw if workflowRunId missing
- Callers wrap in try/catch

**Option C - Leave as-is:**
- Current behavior is intentional per-method
- Document the differences

**Decision**: Option C - Leave as-is. Current behavior is intentional per-method.

## Issue 4: Non-null Assertions on Optional Fields

### Location: MediaGrid.tsx lines 95, 140

```typescript
// content_ids is optional in GenerationResult
gen.content_ids!.map((contentId, idx) => {...}
```

The filter on line 91 checks `gen.content_ids && gen.content_ids.length > 0`,
but TypeScript doesn't narrow through `filter()`.

### Question 4: Fix Strategy

**Option A - Use nullish coalescing:**
```typescript
(gen.content_ids ?? []).map((contentId, idx) => {...}
```
- Pros: Defensive, survives filter logic changes
- Cons: Slightly more verbose

**Option B - Leave as-is:**
- Technically safe due to filter
- Risk if filter logic changes later

**Decision**: Option A - Use nullish coalescing for defensive coding.
Applied in this PR.

## Issue 5: Context Instability (Long-term)

### Problem

The `inputContext` object is recreated when any value changes because
`values` is in the `useMemo` dependency array:

```typescript
// InputSchemaComposer.tsx
const contextValue = useMemo(() => ({
  values,
  getValue,
  setValue,
  // ...
}), [sourceData, values, errors, ...]);  // values triggers recreation
```

### Long-term Solution (Not for this PR)

Split context into stable functions vs reactive values:

```typescript
// Stable context (never changes)
const InputSchemaActionsContext = createContext<InputSchemaActions | null>(null);

// Reactive context (changes when values change)
const InputSchemaStateContext = createContext<InputSchemaState | null>(null);
```

Components that only need functions use `useInputSchemaActions()` and won't
re-render when values change.

### Effort Estimate

Approximately 2-3 hours of work:
1. `InputSchemaComposer.tsx` - Split into two contexts, create new providers
2. `InputSchemaContext.tsx` - Define new interfaces, create two hooks
3. Update ~5-8 consumer components that use `useInputSchema()`
4. Testing to ensure no regressions

Risk: Medium - touching core context infrastructure

**Decision**: Defer to future PR - current eslint-disable workaround is
acceptable for now.

## Changes Applied

### This PR

1. **Issue 1**: Keep current fix (deps array with eslint-disable)
2. **Issue 2**: Standardized nullability on `null` in MediaAdapter interface
3. **Issue 4**: Fixed non-null assertions with nullish coalescing

### Deferred (Future PR)

4. **Issue 3**: Error handling - left as-is (intentional per-method)
5. **Issue 5**: Context splitting (~2-3 hours, medium risk)

## Files Changed

| File | Changes |
|------|---------|
| `ui/shared/src/interactions/types/media-generation/ImageGeneration.tsx` | Deps array fix (earlier in session) |
| `ui/shared/src/interactions/types/media-generation/MediaGrid.tsx` | `!` → `?? []` for content_ids |
| `ui/shared/src/contexts/MediaAdapterContext.tsx` | `string \| undefined` → `string \| null` |
| `ui/webui/src/adapters/WebUIMediaAdapter.tsx` | Removed `?? undefined` conversions |
