# Server-Side Interaction Validation Architecture

## Summary

The current interaction system has no server-side validation for responses.
Validation logic (like "require image selection before continue") is either
hardcoded in frontend components or missing entirely. This document proposes
a generic, server-side validation system that:

1. Validates interaction responses on the server before proceeding
2. Supports both hard errors (block continue) and soft warnings (confirm popup)
3. Is configured via workflow step.json, not hardcoded in UI components
4. Works for any module type, not just media.generate

**Immediate Use Case**: CC workflow step 3 (images) should disable "Accept and
continue" until user selects an image. Steps 5 & 7 (videos/music) should show
a confirmation popup if user continues without generating content.

## Problem Analysis

### Current State

**MediaGenerationHost.tsx (lines 72-102):**
```typescript
// Register provider with InteractionHost
// Note: isValid is always true - selection is optional for media generation
useEffect(() => {
  updateProvider({
    getState: () => ({
      isValid: true,  // ALWAYS TRUE - no validation!
      selectedCount: selectedContentIdRef.current ? 1 : 0,
    }),
    // ...
  });
}, [updateProvider]);
```

**InteractionHost.tsx (lines 422-427):**
```typescript
const isDisabled =
  disabled ||
  isSubActionRunning ||
  (isContinue && !providerState.isValid) ||  // Uses frontend isValid
  (isRetrySelected && providerState.selectedCount === 0);
```

### Problems

1. **Frontend-Only Validation**: `isValid` is computed in React components,
   not enforced server-side. A malicious client could bypass validation.

2. **Hardcoded Logic**: Each interaction type has its own validation logic
   baked into its React component. No configuration possible.

3. **No Warning Support**: Current system only supports enable/disable button.
   No way to show "are you sure?" confirmations.

4. **Media-Specific Tech Debt**: The comment in MediaGenerationHost says
   "selection is optional" - this was a workaround, not intentional design.

## Design Goals

1. **Server Authority**: Server validates responses. Frontend shows what server
   tells it, but cannot bypass validation.

2. **Generic Rules**: Validation rules should work for any response field, not
   just media-specific ones.

3. **Configurable per Step**: Each workflow step defines its own validation
   requirements in step.json.

4. **Two Severity Levels**:
   - `error`: Block continue, button disabled
   - `warning`: Allow continue after user confirms

5. **Clear Error Messages**: Messages come from config, displayed to user.

## Proposed Design

### Validation Location in Config

Validation is part of `retryable` config since it controls "continue" behavior:

```json
{
  "module_id": "media.generate",
  "retryable": {
    "default_option": "continue",
    "options": [...],
    "validation": {
      "on_continue": [
        {
          "rule": "response_field_required",
          "field": "selected_content_id",
          "severity": "error",
          "message": "Please select an image before continuing"
        }
      ]
    }

    <--I think above is wrong, this will make us pick the validation and add
    additional logic for it. one rule we can follow here is that, individual
    action here (different options in retryables and sub actions) will have its
    own validations. given that, validation should be something like below

      "retryable": {
        "default_option": "continue",
        "options": [
          {
            "id": "continue",
            "mode": "continue",
            "label": "Accept and continue"
             "validations": [
                {
                  "id": "validatio1",
                  "rule": "response_field_required",
                  "field": "selected_content_id",
                  "severity": "error",
                  "message": "Please select an image before continuing"
                }
             ]     
          },
          .. 
        ]
      },

      idea above is that, any action can have any number of validations, server
      will repond with validation response when any of validation fails. added
      `id` field to validation so that it will response validation result with
      id and decision. if client wants to utilize that, they can. -->
  
  }
}
```

### Validation Rules

Generic rules that can be applied to any response field:

| Rule Name                 | Description                              | Params           |
|---------------------------|------------------------------------------|------------------|
| `response_field_required` | Field must be present and non-null       | `field`          |
| `response_field_not_empty`| Field must have length > 0 (array/dict)  | `field`          |
| `response_field_equals`   | Field must equal specific value          | `field`, `value` |
| `min_selections`          | selected_indices length >= N             | `min`            |
| `state_exists`            | Workflow state key must exist            | `key`            |

### Severity Levels

| Severity  | Frontend Behavior                          | Server Behavior        |
|-----------|--------------------------------------------|------------------------|
| `error`   | Button disabled, message shown below       | Reject response        |
| `warning` | Button enabled, popup on click if invalid  | Accept if confirmed    |

### Step Configurations

**Step 3 - Images (require selection):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "validation": {
      "on_continue": [
        {
          "rule": "response_field_required",
          "field": "selected_content_id",
          "severity": "error",
          "message": "Please select an image before continuing"
        }
      ]
    }
  },
  "name": "generate_and_select_images"
}
```

**Step 5 - Videos (warn if no generation):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "validation": {
      "on_continue": [
        {
          "rule": "response_field_not_empty",
          "field": "generations",
          "severity": "warning",
          "message": "You haven't generated any videos. Continue anyway?"
        }
      ]
    }
  },
  "name": "generate_and_select_videos"
}
```

**Step 7 - Music (warn if no generation):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "validation": {
      "on_continue": [
        {
          "rule": "response_field_not_empty",
          "field": "generations",
          "severity": "warning",
          "message": "You haven't generated any music. Continue anyway?"
        }
      ]
    }
  },
  "name": "generate_and_select_music"
}
```

### Server Processing Flow

```
Frontend clicks "Continue"
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  POST /workflow/{id}/stream/respond                                         │
│  Body: { interaction_id, response: {...}, confirmed_warnings: [] }          │
└─────────────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  InteractionHandler.continue_after_interaction()                            │
│                                                                             │
│  1. Get pending interaction event (has display_data.retryable.validation)   │
│  2. Get validation config from retryable                                    │
│  3. Run validation rules against response                                   │
│                                                                             │
│  For each rule in validation.on_continue:                                   │
│    - Evaluate rule against response                                         │
│    - If fails and severity="error" → collect error                          │
│    - If fails and severity="warning":                                       │
│        - If rule.field in confirmed_warnings → pass                         │
│        - Else → collect warning                                             │
│                                                                             │
│  4. If errors exist → return ValidationError response                       │
│  5. If unconfirmed warnings exist → return ValidationWarning response       │
│  6. Else → proceed with execute_with_response()                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### API Contract Changes

**Request - Add confirmed_warnings field:**

```python
# contracts/interactions.py
@dataclass
class InteractionResponse:
    # ... existing fields ...
    <!--following will be ids of validations-->
    confirmed_warnings: List[str] = field(default_factory=list)
    # List of field names where user has confirmed to proceed despite warning
```

**Response - New validation result types:**

```python
# New response type for validation failures
@dataclass
class ValidationResult:
    valid: bool
    errors: List[ValidationMessage] = field(default_factory=list)
    warnings: List[ValidationMessage] = field(default_factory=list)

@dataclass
class ValidationMessage:
    field: str
    rule: str
    message: str
    severity: str  # "error" or "warning"
```

**SSE Event for validation failure:**

```python
# When validation fails, emit this instead of continuing
event: validation_failed
data: {
    "errors": [
        {"field": "selected_content_id", "message": "Please select an image"}
    ],
    "warnings": [
        {"field": "generations", "message": "No videos generated. Continue?"}
    ]
}
```

### Frontend Flow

**For errors (severity="error"):**
1. Server returns `validation_failed` with errors
2. Frontend disables "Continue" button
3. Frontend shows error messages below button or near relevant field
4. When user fixes issue (e.g., selects image), frontend re-enables button
5. Note: Frontend can optimistically compute `isValid` to avoid round-trip,
   but server is source of truth

**For warnings (severity="warning"):**
1. User clicks "Continue"
2. Server returns `validation_failed` with warnings (no errors)
3. Frontend shows confirmation popup with warning message
4. If user confirms, frontend re-submits with `confirmed_warnings: ["field"]`
5. Server sees confirmation, proceeds

### Validation Rule Implementations

```python
# backend/server/workflow/validation.py

class ValidationRule(ABC):
    @abstractmethod
    def evaluate(self, response: dict, params: dict) -> bool:
        """Return True if valid, False if invalid."""
        pass

class ResponseFieldRequired(ValidationRule):
    """Field must be present and non-null."""
    def evaluate(self, response: dict, params: dict) -> bool:
        field = params["field"]
        value = response.get(field)
        return value is not None

class ResponseFieldNotEmpty(ValidationRule):
    """Field must have items (for arrays/dicts)."""
    def evaluate(self, response: dict, params: dict) -> bool:
        field = params["field"]
        value = response.get(field)
        if value is None:
            return False
        if isinstance(value, (list, dict)):
            return len(value) > 0
        return bool(value)

class MinSelections(ValidationRule):
    """selected_indices must have at least N items."""
    def evaluate(self, response: dict, params: dict) -> bool:
        indices = response.get("selected_indices", [])
        return len(indices) >= params.get("min", 1)

# Registry
VALIDATION_RULES = {
    "response_field_required": ResponseFieldRequired(),
    "response_field_not_empty": ResponseFieldNotEmpty(),
    "min_selections": MinSelections(),
}
```

### Frontend Changes

**InteractionHost.tsx:**
```typescript
// State for validation
const [validationErrors, setValidationErrors] = useState<ValidationMessage[]>([]);
const [validationWarnings, setValidationWarnings] = useState<ValidationMessage[]>([]);
const [confirmationPopup, setConfirmationPopup] = useState<{
  warnings: ValidationMessage[];
  onConfirm: () => void;
} | null>(null);

// Handle validation_failed event from SSE
const handleValidationFailed = (data: ValidationResult) => {
  setValidationErrors(data.errors);
  setValidationWarnings(data.warnings);
  
  // If only warnings (no errors), show confirmation popup
  if (data.errors.length === 0 && data.warnings.length > 0) {
    setConfirmationPopup({
      warnings: data.warnings,
      onConfirm: () => {
        // Re-submit with confirmed warnings
        const confirmedFields = data.warnings.map(w => w.field);
        respond({...response, confirmed_warnings: confirmedFields});
        setConfirmationPopup(null);
      }
    });
  }
};

// Button disabled if there are errors
const isContinueDisabled = validationErrors.length > 0 || isSubActionRunning;
```

**MediaGenerationHost.tsx:**
```typescript
// Remove isValid: true hack
// Server will validate, frontend just sends response
useEffect(() => {
  updateProvider({
    getState: () => ({
      // Let server validate, but can hint for optimistic UI
      selectedCount: selectedContentIdRef.current ? 1 : 0,
    }),
    getResponse: () => ({
      selected_content_id: selectedContentIdRef.current ?? undefined,
      generations: generationsRef.current,
    }),
  });
}, [updateProvider, selectedContentId]);
```

## Files Affected

| File | Changes |
|------|---------|
| `contracts/interactions.py` | Add `confirmed_warnings` to InteractionResponse |
| `backend/server/models/interaction.py` | Add `confirmed_warnings` to Pydantic model |
| `backend/server/workflow/validation.py` | New file: validation rules and runner |
| `backend/server/workflow/interaction.py` | Call validation before execute_with_response |
| `workflows/cc/steps/3_image_prompts/step.json` | Add validation config |
| `workflows/cc/steps/5_video_generation/step.json` | Add validation config |
| `workflows/cc/steps/7_music/step.json` | Add validation config |
| `ui/webui/src/core/types.ts` | Add ValidationMessage, confirmed_warnings types |
| `ui/webui/src/interactions/InteractionHost.tsx` | Handle validation_failed, show popup |
| `ui/webui/src/interactions/types/media-generation/MediaGenerationHost.tsx` | Remove isValid hack |

## Questions for Review

1. **Validation in retryable vs inputs**: The proposal puts validation under
   `retryable.validation`. An alternative is `inputs.validation` which would
   allow access to resolved input values for conditional validation (e.g.,
   "only require selection if some_input is true"). Do we need this flexibility?
    <!--added notes aove-->

2. **Warning confirmation mechanism**: The proposal uses `confirmed_warnings`
   as a list of field names in the response. Alternative approaches:
   - Boolean `force_continue: true` (simpler but less granular)
   - Separate endpoint for confirmation
   Which approach is preferred?
   <!--lets go with confirmed_warnings -->

3. **Optimistic frontend validation**: Should frontend compute validation
   locally for instant feedback (button enable/disable), or always wait for
   server response? Local computation risks frontend/server disagreement.

   <!--I'd prefer if we can disble continue buttons when there's obvious
   failure of validation. but i dont want to hardcode it either. may be we can
   have validation type for client for basic validations, specially for error
   ones. actually thinking about it, all validations here can be done in client
   side. i understand the need of severside validation, but ux is not the same,
   may be we need some validations in client side too.-->

4. **Custom validation rules**: Should we support custom Python functions as
   validation rules, or only built-in rule types? Custom rules are more
   flexible but harder to maintain.

   <!--lets not do it for this iteration.-->

5. **Validation timing**: Currently proposed to validate on "continue" action
   only (`on_continue`). Should we also support validation on other actions
   like retry or jump? If so, what's the config structure?

   <!--validations should work regardless of the type. my sugestion on top of
   the doc should answe this.-->

6. **Error message localization**: Messages are currently hardcoded in JSON.
   If we need i18n later, should we use message keys instead of raw strings?

   <!--no i18n for now.-->
