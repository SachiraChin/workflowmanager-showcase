# Server-Side Interaction Validation Architecture - Revision 2

## Summary

The current interaction system has no server-side validation for responses.
Validation logic (like "require image selection before continue") is either
hardcoded in frontend components or missing entirely. This document proposes
a generic validation system that:

1. Validates interaction responses on both client and server
2. Supports both hard errors (block action) and soft warnings (confirm popup)
3. Is configured via workflow step.json, not hardcoded in UI components
4. Works for any module type and any action (continue, retry, jump)

**Immediate Use Case**: CC workflow step 3 (images) should disable "Accept and
continue" until user selects an image. Steps 5 & 7 (videos/music) should show
a confirmation popup if user continues without generating content.

## Changes from R1

Based on feedback:

1. **Validation per action**: Moved `validations` array inside each option in
   `retryable.options[]`, not at retryable level. Any action can have
   validations.

2. **Validation IDs**: Added `id` field to each validation rule for reference
   in `confirmed_warnings`.

3. **Client-side validation**: Added design for frontend to evaluate same rules
   locally for instant UX feedback (button disable).

4. **No custom rules**: Only built-in rule types for this iteration.

5. **No i18n**: Messages are plain strings in JSON.

## Design

### Validation Config Structure

Validations are defined per-action inside `retryable.options[]`:

```json
{
  "module_id": "media.generate",
  "retryable": {
    "default_option": "continue",
    "options": [
      {
        "id": "continue",
        "mode": "continue",
        "label": "Accept and continue",
        "validations": [
          {
            "id": "require_image_selection",
            "rule": "response_field_required",
            "field": "selected_content_id",
            "severity": "error",
            "message": "Please select an image before continuing"
          }
        ]
      },
      {
        "id": "retry",
        "mode": "retry",
        "label": "Regenerate prompts",
        "target_module": "generate_image_prompts",
        "validations": []
      }
    ]
  }
}
```

Key points:
- Each option can have zero or more validations
- Validations have unique `id` for reference in responses
- `severity` determines behavior: `error` blocks, `warning` requires confirm
- Server validates on action; client validates for UX feedback

### Validation Rules

Built-in rules for this iteration:

| Rule Name                 | Description                              | Params           |
|---------------------------|------------------------------------------|------------------|
| `response_field_required` | Field must be present and non-null       | `field`          |
| `response_field_not_empty`| Field must have length > 0 (array/dict)  | `field`          |
| `response_field_equals`   | Field must equal specific value          | `field`, `value` |
| `min_selections`          | selected_indices length >= N             | `min`            |

### Severity Levels

| Severity  | Client Behavior                            | Server Behavior        |
|-----------|--------------------------------------------|------------------------|
| `error`   | Button disabled until valid                | Reject response        |
| `warning` | Button enabled, popup on click if invalid  | Accept if confirmed    |

### Step Configurations

**Step 3 - Images (require selection):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "default_option": "continue",
    "options": [
      {
        "id": "continue",
        "mode": "continue",
        "label": "Accept and continue",
        "validations": [
          {
            "id": "require_image_selection",
            "rule": "response_field_required",
            "field": "selected_content_id",
            "severity": "error",
            "message": "Please select an image before continuing"
          }
        ]
      },
      {
        "id": "retry",
        "mode": "retry",
        "label": "Regenerate prompts",
        "hidden": true,
        "target_module": "generate_image_prompts"
      }
    ]
  },
  "name": "generate_and_select_images"
}
```

**Step 5 - Videos (warn if no generation):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "default_option": "continue",
    "options": [
      {
        "id": "continue",
        "mode": "continue",
        "label": "Accept and continue",
        "validations": [
          {
            "id": "warn_no_video_generation",
            "rule": "response_field_not_empty",
            "field": "generations",
            "severity": "warning",
            "message": "You haven't generated any videos. Continue anyway?"
          }
        ]
      }
    ]
  },
  "name": "generate_and_select_videos"
}
```

**Step 7 - Music (warn if no generation):**
```json
{
  "module_id": "media.generate",
  "retryable": {
    "default_option": "continue",
    "options": [
      {
        "id": "continue",
        "mode": "continue",
        "label": "Accept and continue",
        "validations": [
          {
            "id": "warn_no_music_generation",
            "rule": "response_field_not_empty",
            "field": "generations",
            "severity": "warning",
            "message": "You haven't generated any music. Continue anyway?"
          }
        ]
      }
    ]
  },
  "name": "generate_and_select_music"
}
```

### Validation Flow

#### Client-Side (for UX)

```
User interacts with form
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  Frontend evaluates validations for current action                          │
│                                                                             │
│  1. Get validations from retryable.options[actionId].validations            │
│  2. For each validation with severity="error":                              │
│     - Evaluate rule against current response state                          │
│     - If fails → add to errorList                                           │
│  3. If errorList not empty → disable action button                          │
│  4. For severity="warning": button stays enabled (validated on click)       │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Server-Side (source of truth)

```
Frontend clicks action button
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  POST /workflow/{id}/stream/respond                                         │
│  Body: {                                                                    │
│    interaction_id,                                                          │
│    response: {...},                                                         │
│    action_id: "continue",                                                   │
│    confirmed_warnings: ["warn_no_video_generation"]                         │
│  }                                                                          │
└─────────────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  InteractionHandler.continue_after_interaction()                            │
│                                                                             │
│  1. Get action config from retryable.options where id == action_id          │
│  2. Get validations array from action config                                │
│  3. Run validation rules against response                                   │
│                                                                             │
│  For each validation:                                                       │
│    - Evaluate rule against response                                         │
│    - If fails and severity="error" → collect error with validation.id       │
│    - If fails and severity="warning":                                       │
│        - If validation.id in confirmed_warnings → pass                      │
│        - Else → collect warning with validation.id                          │
│                                                                             │
│  4. If errors exist → return validation_failed event                        │
│  5. If unconfirmed warnings exist → return validation_failed event          │
│  6. Else → proceed with execute_with_response()                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### API Contract Changes

**Request - Add action_id and confirmed_warnings:**

```python
# contracts/interactions.py
@dataclass
class InteractionResponse:
    interaction_id: str
    # ... existing fields ...
    
    # NEW: Which action triggered this response
    action_id: Optional[str] = None
    
    # NEW: List of validation IDs user has confirmed to proceed despite warning
    confirmed_warnings: List[str] = field(default_factory=list)
```

**Response - Validation result in SSE:**

```python
@dataclass
class ValidationMessage:
    id: str           # Validation ID from config
    field: str        # Field that failed validation
    rule: str         # Rule name that failed
    message: str      # Human-readable message
    severity: str     # "error" or "warning"

# SSE Event
event: validation_failed
data: {
    "errors": [
        {
            "id": "require_image_selection",
            "field": "selected_content_id",
            "rule": "response_field_required",
            "message": "Please select an image before continuing",
            "severity": "error"
        }
    ],
    "warnings": [
        {
            "id": "warn_no_video_generation",
            "field": "generations",
            "rule": "response_field_not_empty",
            "message": "You haven't generated any videos. Continue anyway?",
            "severity": "warning"
        }
    ]
}
```

### Server Implementation

**New file: backend/server/workflow/validation.py**

```python
"""
Interaction Response Validation

Validates interaction responses against rules defined in retryable config.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass


@dataclass
class ValidationMessage:
    id: str
    field: str
    rule: str
    message: str
    severity: str


@dataclass
class ValidationResult:
    valid: bool
    errors: List[ValidationMessage]
    warnings: List[ValidationMessage]


class ValidationRule(ABC):
    """Base class for validation rules."""
    
    @abstractmethod
    def evaluate(self, response: Dict[str, Any], params: Dict[str, Any]) -> bool:
        """Return True if valid, False if invalid."""
        pass


class ResponseFieldRequired(ValidationRule):
    """Field must be present and non-null."""
    
    def evaluate(self, response: Dict[str, Any], params: Dict[str, Any]) -> bool:
        field = params.get("field", "")
        value = response.get(field)
        return value is not None


class ResponseFieldNotEmpty(ValidationRule):
    """Field must have items (for arrays/dicts) or be truthy."""
    
    def evaluate(self, response: Dict[str, Any], params: Dict[str, Any]) -> bool:
        field = params.get("field", "")
        value = response.get(field)
        if value is None:
            return False
        if isinstance(value, (list, dict)):
            return len(value) > 0
        return bool(value)


class ResponseFieldEquals(ValidationRule):
    """Field must equal a specific value."""
    
    def evaluate(self, response: Dict[str, Any], params: Dict[str, Any]) -> bool:
        field = params.get("field", "")
        expected = params.get("value")
        actual = response.get(field)
        return actual == expected


class MinSelections(ValidationRule):
    """selected_indices must have at least N items."""
    
    def evaluate(self, response: Dict[str, Any], params: Dict[str, Any]) -> bool:
        indices = response.get("selected_indices", [])
        min_count = params.get("min", 1)
        return len(indices) >= min_count


# Registry of available rules
VALIDATION_RULES: Dict[str, ValidationRule] = {
    "response_field_required": ResponseFieldRequired(),
    "response_field_not_empty": ResponseFieldNotEmpty(),
    "response_field_equals": ResponseFieldEquals(),
    "min_selections": MinSelections(),
}


def validate_response(
    response: Dict[str, Any],
    validations: List[Dict[str, Any]],
    confirmed_warnings: List[str]
) -> ValidationResult:
    """
    Validate response against a list of validation configs.
    
    Args:
        response: The interaction response data
        validations: List of validation configs from retryable option
        confirmed_warnings: List of validation IDs user has confirmed
    
    Returns:
        ValidationResult with errors and warnings
    """
    errors: List[ValidationMessage] = []
    warnings: List[ValidationMessage] = []
    
    for validation in validations:
        rule_name = validation.get("rule", "")
        rule = VALIDATION_RULES.get(rule_name)
        
        if not rule:
            # Unknown rule - skip (could log warning)
            continue
        
        # Build params from validation config (field, value, min, etc.)
        params = {k: v for k, v in validation.items() 
                  if k not in ("id", "rule", "severity", "message")}
        
        is_valid = rule.evaluate(response, params)
        
        if not is_valid:
            msg = ValidationMessage(
                id=validation.get("id", ""),
                field=validation.get("field", ""),
                rule=rule_name,
                message=validation.get("message", "Validation failed"),
                severity=validation.get("severity", "error")
            )
            
            if msg.severity == "error":
                errors.append(msg)
            elif msg.severity == "warning":
                # Check if user already confirmed this warning
                if msg.id not in confirmed_warnings:
                    warnings.append(msg)
    
    return ValidationResult(
        valid=len(errors) == 0 and len(warnings) == 0,
        errors=errors,
        warnings=warnings
    )
```

**Update: backend/server/workflow/interaction.py**

Add validation check in `continue_after_interaction()`:

```python
# After getting action config, before execute_with_response:

def continue_after_interaction(self, ...):
    # ... existing code to get module_config, etc. ...
    
    # Get the action that was triggered
    action_id = interaction_response.action_id
    retryable = module_config.get('retryable', {})
    options = retryable.get('options', [])
    
    # Find the action config
    action_config = None
    for opt in options:
        if opt.get('id') == action_id:
            action_config = opt
            break
    
    # Validate if action has validations
    if action_config:
        validations = action_config.get('validations', [])
        if validations:
            from .validation import validate_response
            
            # Convert response to dict for validation
            response_dict = {
                'selected_content_id': interaction_response.selected_content_id,
                'generations': interaction_response.generations or {},
                'selected_indices': interaction_response.selected_indices,
                # ... other fields as needed
            }
            
            result = validate_response(
                response_dict,
                validations,
                interaction_response.confirmed_warnings or []
            )
            
            if not result.valid:
                # Return validation_failed event
                return WorkflowResponse(
                    workflow_run_id=workflow_run_id,
                    status=WorkflowStatus.VALIDATION_FAILED,
                    validation_errors=[asdict(e) for e in result.errors],
                    validation_warnings=[asdict(w) for w in result.warnings]
                )
    
    # ... continue with execute_with_response ...
```

### Frontend Implementation

**Update: ui/webui/src/core/types.ts**

```typescript
// Validation types
export interface ValidationConfig {
  id: string;
  rule: string;
  field: string;
  severity: "error" | "warning";
  message: string;
  value?: unknown;  // For response_field_equals
  min?: number;     // For min_selections
}

export interface ValidationMessage {
  id: string;
  field: string;
  rule: string;
  message: string;
  severity: "error" | "warning";
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationMessage[];
  warnings: ValidationMessage[];
}

// Update InteractionResponseData
export interface InteractionResponseData {
  // ... existing fields ...
  action_id?: string;
  confirmed_warnings?: string[];
}
```

**New: ui/webui/src/utils/validation.ts**

```typescript
/**
 * Client-side validation for instant UX feedback.
 * Mirrors server-side validation logic.
 */

import type { ValidationConfig, ValidationResult, ValidationMessage } from "@/core/types";

type ResponseData = Record<string, unknown>;

// Validation rule implementations
const RULES: Record<string, (response: ResponseData, params: ValidationConfig) => boolean> = {
  response_field_required: (response, params) => {
    const value = response[params.field];
    return value !== null && value !== undefined;
  },
  
  response_field_not_empty: (response, params) => {
    const value = response[params.field];
    if (value === null || value === undefined) return false;
    if (Array.isArray(value)) return value.length > 0;
    if (typeof value === "object") return Object.keys(value).length > 0;
    return Boolean(value);
  },
  
  response_field_equals: (response, params) => {
    const value = response[params.field];
    return value === params.value;
  },
  
  min_selections: (response, params) => {
    const indices = (response.selected_indices as unknown[]) || [];
    return indices.length >= (params.min || 1);
  },
};

export function validateResponse(
  response: ResponseData,
  validations: ValidationConfig[],
  confirmedWarnings: string[] = []
): ValidationResult {
  const errors: ValidationMessage[] = [];
  const warnings: ValidationMessage[] = [];
  
  for (const validation of validations) {
    const rule = RULES[validation.rule];
    if (!rule) continue;
    
    const isValid = rule(response, validation);
    
    if (!isValid) {
      const msg: ValidationMessage = {
        id: validation.id,
        field: validation.field,
        rule: validation.rule,
        message: validation.message,
        severity: validation.severity,
      };
      
      if (validation.severity === "error") {
        errors.push(msg);
      } else if (validation.severity === "warning") {
        if (!confirmedWarnings.includes(validation.id)) {
          warnings.push(msg);
        }
      }
    }
  }
  
  return {
    valid: errors.length === 0 && warnings.length === 0,
    errors,
    warnings,
  };
}
```

**Update: ui/webui/src/interactions/InteractionHost.tsx**

```typescript
// Add validation state and logic

import { validateResponse } from "@/utils/validation";
import type { ValidationConfig, ValidationMessage, ValidationResult } from "@/core/types";

// Inside InteractionHost component:

// Get validations for current action
const getValidationsForAction = (actionId: string): ValidationConfig[] => {
  const options = retryable.options || [];
  const option = options.find(opt => opt.id === actionId);
  return (option?.validations || []) as ValidationConfig[];
};

// Compute validation state for action button
const computeValidationState = (actionId: string): {
  hasErrors: boolean;
  errors: ValidationMessage[];
} => {
  const validations = getValidationsForAction(actionId);
  if (validations.length === 0) {
    return { hasErrors: false, errors: [] };
  }
  
  const response = providerRef.current?.getResponse() || {};
  const result = validateResponse(response, validations);
  
  // Only consider errors for button disable (warnings handled on click)
  return {
    hasErrors: result.errors.length > 0,
    errors: result.errors,
  };
};

// Handle action click with warning confirmation
const handleActionClick = async (actionId: string, mode: string) => {
  const validations = getValidationsForAction(actionId);
  const response = providerRef.current?.getResponse() || {};
  const result = validateResponse(response, validations);
  
  // If there are unconfirmed warnings, show popup
  if (result.warnings.length > 0) {
    setConfirmationPopup({
      warnings: result.warnings,
      onConfirm: () => {
        const confirmedIds = result.warnings.map(w => w.id);
        submitResponse(actionId, confirmedIds);
        setConfirmationPopup(null);
      },
      onCancel: () => setConfirmationPopup(null),
    });
    return;
  }
  
  // No warnings, submit directly
  submitResponse(actionId, []);
};

const submitResponse = (actionId: string, confirmedWarnings: string[]) => {
  const response = providerRef.current?.getResponse() || {};
  onSubmit({
    ...response,
    action_id: actionId,
    confirmed_warnings: confirmedWarnings,
  });
};

// In render, for each action button:
const { hasErrors } = computeValidationState(option.id);
const isDisabled = disabled || isSubActionRunning || hasErrors;
```

## Files Affected

| File | Changes |
|------|---------|
| `contracts/interactions.py` | Add `action_id`, `confirmed_warnings` fields |
| `backend/server/models/interaction.py` | Add fields to Pydantic model |
| `backend/server/workflow/validation.py` | New file: validation rules and runner |
| `backend/server/workflow/interaction.py` | Call validation before execute |
| `backend/server/models/workflow.py` | Add VALIDATION_FAILED status |
| `workflows/cc/steps/3_image_prompts/step.json` | Add validations to continue option |
| `workflows/cc/steps/5_video_generation/step.json` | Add validations to continue option |
| `workflows/cc/steps/7_music/step.json` | Add validations to continue option |
| `ui/webui/src/core/types.ts` | Add validation types |
| `ui/webui/src/utils/validation.ts` | New file: client-side validation |
| `ui/webui/src/interactions/InteractionHost.tsx` | Add validation logic, confirmation popup |

## Open Questions

1. **Validation error display**: Where should validation errors be shown in UI?
   - Below the action button?
   - Toast notification?
   - Inline near the field that failed?

   <!--for now, lets add it in footer, there must area which has validation, we
   can use that.-->

2. **Client-server sync**: If client and server validation disagree (e.g., due
   to a bug), what should happen? Currently server is source of truth and will
   reject, but client might have allowed the action.

   <!--we can keep it as is. i'd add new filed called "validator": ["webui",
   "server] so we can clearly identify what rules validated by which, etc.-->

3. **Validation on mode="retry"**: Should retry actions also support
   validations? Example: "must provide feedback" before retry?

   <!--lets only focus on ones we are targetting for now. most retries are
   hidden atm due to broken implemenration. we can add validations once we fix
   them-->
