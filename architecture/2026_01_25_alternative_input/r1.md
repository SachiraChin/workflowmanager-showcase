# Alternative Input Schema

## Summary

Add support for alternative input mechanisms for schema fields. This allows a single logical field (e.g., `resolution`) to have multiple input modes:
1. **Primary mode**: Standard input (e.g., dropdown select from API-provided options)
2. **Alternative mode**: Custom input (e.g., separate width/height number inputs)

## Use Case

In the CC workflow's Stable Diffusion tab, `resolution` is currently a dropdown populated from the SD API. Users want the option to specify custom width/height values that may not be in the predefined list.

## Design Questions

### Q1: Mode Switching UI

How does the user switch between primary and alternative modes?

**Options:**
- **A) Toggle button/icon** next to the field label
- **B) Segmented control** showing both options (Preset / Custom)
- **C) "Custom" option in the dropdown** that expands to show alternative inputs
- **D) Always visible** - show both, user fills in one or the other

**Recommendation:** Option A or B. Toggle keeps UI clean; segmented control is more discoverable.

<!--It'll be A here-->

### Q2: Value Storage

When user enters custom width=512, height=768, what gets stored in the context?

**Options:**
- **A) Combined string**: Store as `"512x768"` in the `resolution` field
- **B) Structured object**: Store as `{ width: 512, height: 768, mode: "custom" }`
- **C) Separate fields**: Store in `resolution_width` and `resolution_height`, leave `resolution` empty

**Recommendation:** Option A (combined string) maintains compatibility with existing `destination_field` mapping and downstream processing. The alternative inputs are just a different UI for entering the same logical value.

<!--itd be A here-->

### Q3: Value Composition

How are multiple alternative fields combined into the primary field's value?

Your example uses `source_data: "{resolution.split('x')[0]}"` but:
- This is JavaScript syntax; codebase uses Jinja2 templates
- `source_data` is for *reading* initial values, not *writing* composed values

**Proposed approach:**
- `source_data` (or `initial_value`): Template for extracting initial value from primary field → alternative field
- `compose`: Template for combining alternative fields → primary field value

<!--
i think we are thinking at this wrong way. what if server do resolve the issue formatting for us, by server i mean sd api I have control over. what if I change

```
{
  "value": "512x512",
  "count": 10
}
```

to 

```
{
  "value": "512x512",
  "height": 512,
  "width": 512,
  "count": 10
}
```

this would remove issue with reading, on writing, i want to be able to handle
this in client side and send data format expected by server. 

i would like something like this,
```
{
  "resolution": {
    "type": "string",
    "title": "Resolution",
    "required": true,
    "_ux": {
      "input_type": "select"
    },
    "alternative": {
      "compose": "{height}x{width}",
      "fields": [
        ... 
      ]
    }
  }
}
```

but i dont like all the parsing we have to do here as well. I want to digg more
into this
-->

### Q4: Static Elements

Your example has a static "x" text between width and height inputs. How to handle?

**Options:**
- **A) Dedicated field type**: `{ "type": "static", "text": "x" }`
- **B) Render directive**: `{ "_ux.render_as": "text", "content": "x" }`
- **C) Layout-based**: Use CSS/layout to add separator

**Recommendation:** Option A is cleanest - explicit static field type.

<!--tbh, this one is weird one, i feel like #B is the better approach as it
utilize existing tooling. the "type" has very specific purpose, adding "static"
there wouldnt give give us any value-->

### Q5: Validation

How to validate custom inputs?

- Alternative fields should support `minimum`, `maximum`, `step` for numbers
- Should we validate the composed value against any constraints?
- What happens if user enters invalid values?

<!--input type has to be numbers, for there's already component for this which
has validations built in, check component for #95-102 in same schema json.-->

---

## Proposed Schema Design

```json
{
  "resolution": {
    "type": "string",
    "title": "Resolution",
    "required": true,
    "_ux": {
      "input_type": "select"
    },
    "alternative": {
      "label": "Custom",
      "compose": "{{ width }}x{{ height }}",
      "layout": "inline",
      "fields": {
        "width": {
          "type": "integer",
          "title": "Width",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "initial_value": "{{ value.split('x')[0] | int if value and 'x' in value else 512 }}",
          "_ux": {
            "input_type": "text"
          }
        },
        "_separator": {
          "type": "static",
          "content": "x"
        },
        "height": {
          "type": "integer",
          "title": "Height",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "initial_value": "{{ value.split('x')[1] | int if value and 'x' in value else 768 }}",
          "_ux": {
            "input_type": "text"
          }
        }
      }
    }
  }
}
```

### Schema Changes

| Field | Type | Description |
|-------|------|-------------|
| `alternative` | object | Container for alternative input configuration |
| `alternative.label` | string | Label for toggle/tab (e.g., "Custom") |
| `alternative.compose` | string | Jinja2 template to combine field values into primary value |
| `alternative.layout` | string | Layout mode: "inline" (horizontal), "stack" (vertical) |
| `alternative.fields` | object | Map of field key → field schema |
| `initial_value` | string | Jinja2 template with `value` = current primary field value |
| `type: "static"` | - | New type for non-input display elements |

---

## Implementation Approach

### 1. Context Changes

The `InputSchemaContext` needs to track:
- **Active mode** per field: `"primary"` or `"alternative"`
- **Alternative field values**: Stored separately, composed on mode switch or submission

```typescript
interface InputSchemaContextValue {
  // Existing...
  values: Record<string, unknown>;

  // New...
  alternativeMode: Record<string, boolean>;  // fieldKey → isAlternativeActive
  alternativeValues: Record<string, Record<string, unknown>>;  // fieldKey → { subfield: value }

  setAlternativeMode: (fieldKey: string, isAlternative: boolean) => void;
  getAlternativeValue: (fieldKey: string, subfield: string) => unknown;
  setAlternativeValue: (fieldKey: string, subfield: string, value: unknown) => void;
}
```

### 2. Rendering Changes

Create `AlternativeInputRenderer` component:

```
┌─────────────────────────────────────────────────────┐
│ Resolution                          [Preset|Custom] │
├─────────────────────────────────────────────────────┤
│ Primary mode:                                       │
│   ┌─────────────────────────────────┐              │
│   │ 512x768 (Portrait)          ▼  │              │
│   └─────────────────────────────────┘              │
│                                                     │
│ Alternative mode:                                   │
│   ┌─────────┐     ┌─────────┐                      │
│   │   512   │  x  │   768   │                      │
│   └─────────┘     └─────────┘                      │
└─────────────────────────────────────────────────────┘
```

### 3. Value Flow

**Primary → Alternative (mode switch):**
1. User clicks "Custom" toggle
2. Run `initial_value` template for each alternative field with `value` = current primary value
3. Populate alternative field values

**Alternative → Primary (mode switch or on-change):**
1. Run `compose` template with alternative field values
2. Update primary field value in context

### 4. Submission

`getMappedValues()` should:
- If field is in alternative mode, ensure composed value is up-to-date
- Return only the primary field value (alternatives are just UI)

---

## Questions for Review

1. **Mode switching UI**: Toggle button (A) or segmented control (B)?
<--answered above-->

2. **Composition timing**: Should alternative fields update the primary value:
   - On every keystroke (live compose)?
   - On blur/mode switch only?
   - Only on form submission?
   <!--every keystroke-->

3. **Validation feedback**: Where to show errors for alternative fields?
<--answered above-->

4. **Backwards compatibility**: Should fields without `alternative` work exactly as before? (Yes, assumed)
<!--i am okay with not having backwards compatibility, if we can have it, its good, we we cant, i can live with it.-->

5. **Controls interaction**: If `resolution` has `controls` that depend on its value, should those trigger when alternative mode composes a new value?
<!--for now we can say that only one of these is available for given fields..-->

6. **Persistence**: Should the active mode (primary/alternative) be remembered across sessions or reset to primary?
<!--it will reset when page refresh, but when use proceed it will remember this choice and show readonly fields as needed-->
