# Alternative Input Schema - R3

## Corrected Data Flow Understanding

The controls cascade works as follows:

```
model_category (enum from state.sd_model_categories)
    │
    ├── controls.checkpoint
    │   enum_path: "models"
    │   value_key: "checkpoint_name"
    │
    └── checkpoint (dynamic options from selected category)
            │
            ├── controls.resolution
            │   enum_path: "params.resolution"
            │   value_key: "value"
            │   label_format: "{value} (count: {count})"
            │
            └── resolution (dynamic options from selected checkpoint)
```

**Current API data for resolution options:**
```json
[
  { "value": "512x768", "count": 10 },
  { "value": "1024x1024", "count": 5 }
]
```

**Proposed API data (your change):**
```json
[
  { "value": { "text": "512x768", "width": 512, "height": 768 }, "count": 10 },
  { "value": { "text": "1024x1024", "width": 1024, "height": 1024 }, "count": 5 }
]
```

With this change:
- `value_key: "value"` stores the whole object `{ text: "512x768", width: 512, height: 768 }`
- `label_format` changes to `"{value.text} (count: {count})"`
- The `sourceItem` in `DynamicOption` contains the full option object

---

## Key Insight

The alternative fields don't need a separate data source - they read from the **same value** that the primary select stores. Since the value is now a structured object with `text`, `width`, `height`, the alternative fields just reference different parts of this object.

**Primary mode (select):** Shows dropdown, displays `value.text`, stores full object
**Alternative mode (inputs):** Shows width/height inputs, edits `value.width`/`value.height`, composes to update `value.text`

---

## Revised Schema Design

```json
{
  "resolution": {
    "type": "string",
    "title": "Resolution",
    "required": true,
    "_ux": {
      "input_type": "select"
    },
    "alternative": {
      "compose": {
        "text": "{width}x{height}"
      },
      "layout": "inline",
      "fields": [
        {
          "key": "width",
          "type": "integer",
          "title": "W",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "default": 512,
          "_ux": {
            "input_type": "number"
          }
        },
        {
          "content": "x",
          "_ux": {
            "render_as": "text"
          }
        },
        {
          "key": "height",
          "type": "integer",
          "title": "H",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "default": 768,
          "_ux": {
            "input_type": "number"
          }
        }
      ]
    }
  }
}
```

### Schema Changes

| Property | Type | Description |
|----------|------|-------------|
| `alternative.compose` | object | Template object - keys are fields to update, values are `{fieldKey}` templates |
| `alternative.layout` | string | `"inline"` or `"stack"`. Default: `"inline"` |
| `alternative.fields` | array | Ordered list of alternative input definitions |

### Field Properties

| Property | Type | Description |
|----------|------|-------------|
| `key` | string | Path into the stored value object (e.g., `"width"` reads/writes `value.width`) |
| `type` | string | `"integer"`, `"number"`, `"string"` |
| `title` | string | Label for the input |
| `content` | string | For static text elements (no `key` = static) |
| `default` | any | Default value when entering alternative mode with no prior selection |
| `minimum`, `maximum`, `step` | number | Validation constraints |
| `_ux.input_type` | string | `"number"`, `"text"` |
| `_ux.render_as` | string | `"text"` for static elements |

---

## Value Structure

The stored value for `resolution` is now an object:

```typescript
interface ResolutionValue {
  text: string;    // "512x768" - used for display and submission
  width: number;   // 512
  height: number;  // 768
}
```

**Primary mode:** Select stores entire object from `value_key`
**Alternative mode:** Inputs edit `width`/`height`, compose updates `text`

<!--there's nothing like that in code, whole purpose of this to not to have it
in code and generate on the go by schema. just make sure you understand
that.-->

---

## Data Flow

### 1. Initial Load (Primary Mode)

```
User selects "512x768" from dropdown
    │
    ▼
SelectInputRenderer stores: { text: "512x768", width: 512, height: 768 }
    │
    ▼
context.setValue("resolution", { text: "512x768", width: 512, height: 768 })
```

### 2. Switch to Alternative Mode

```
User clicks toggle icon
    │
    ▼
Read current value: { text: "512x768", width: 512, height: 768 }
    │
    ▼
Populate alternative inputs:
  - width input: 512 (from value.width)
  - height input: 768 (from value.height)
```

### 3. Edit in Alternative Mode

```
User changes width to 640
    │
    ▼
Run compose template: { text: "{width}x{height}" } → { text: "640x768" }
    │
    ▼
Update value: { text: "640x768", width: 640, height: 768 }
    │
    ▼
context.setValue("resolution", { text: "640x768", width: 640, height: 768 })
```

### 4. Switch Back to Primary Mode

```
Current value: { text: "640x768", width: 640, height: 768 }
    │
    ▼
Check if "640x768" matches any option in dropdown
    │
    ├── YES: Show that option as selected
    │
    └── NO: Reset to default option (per your decision)
            │
            ▼
        context.setValue("resolution", defaultOption.value)
```

<!--same as last comment, dont be suprised later when half of this is not there on code. -->

---

## Implementation Components

### 1. AlternativeInputWrapper

Wraps any input field that has `alternative` config:

```
┌─────────────────────────────────────────────────────────┐
│ Resolution                                    [⇄]      │
├─────────────────────────────────────────────────────────┤
│ PRIMARY MODE:                                           │
│   ┌─────────────────────────────────────────┐          │
│   │ 512x768 (Portrait)                   ▼  │          │
│   └─────────────────────────────────────────┘          │
│                                                         │
│ ALTERNATIVE MODE:                                       │
│   ┌────────┐     ┌────────┐                            │
│   │  512   │  x  │  768   │                            │
│   └────────┘     └────────┘                            │
│   W              H                                      │
└─────────────────────────────────────────────────────────┘
```

### 2. Context Additions

```typescript
interface InputSchemaContextValue {
  // Existing
  values: Record<string, unknown>;
  getValue: (key: string) => unknown;
  setValue: (key: string, value: unknown) => void;

  // New for alternatives
  alternativeMode: Record<string, boolean>;
  isAlternativeMode: (key: string) => boolean;
  setAlternativeMode: (key: string, active: boolean) => void;
}
```

### 3. Rendering Flow

1. `TerminalRenderer` checks if schema has `alternative`
2. If yes, wraps the input with `AlternativeInputWrapper`
3. `AlternativeInputWrapper` renders:
   - Toggle button in label area
   - Primary input OR alternative fields (based on mode)
4. Alternative fields read from `value[key]` and compose back to `value`

---

## Questions for Review

1. **Object value type**: The `resolution` field has `type: "string"` but now stores an object. Should we:
   - A) Change type to `"object"` with properties schema
   - B) Keep as `"string"` and handle object values implicitly
   - C) Add new type like `"composite"` for this pattern

   <!--this is fine is it not? type here means what it means for overall
   picture, means what is the selected value type, which is a string. i dont
   think we use type=object anywhere-->

2. **Submission mapping**: When submitting, should `getMappedValues()`:
   - A) Return `value.text` (the string) for `resolution`
   - B) Return the full object
   - C) Use a `submission_path` config like `"text"` to extract
   <!--A-->

3. **Compose timing refinement**: You said "every keystroke" - should we debounce to avoid excessive updates, or is immediate fine?
    <!--this is valid concern, what is the industry standard here?-->
