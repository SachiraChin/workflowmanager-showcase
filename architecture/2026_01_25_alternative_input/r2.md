# Alternative Input Schema - R2

## Decisions from R1

| Question | Decision |
|----------|----------|
| Mode switching UI | **A) Toggle button/icon** |
| Value storage | **A) Combined string** in primary field |
| Static elements | **B) Render directive** (`_ux.render_as: "text"`) - reuse existing tooling |
| Validation | Use number input type with built-in validation (`minimum`, `maximum`, `step`) |
| Composition timing | Every keystroke |
| Controls interaction | Mutually exclusive - field has either `controls` OR `alternative`, not both |
| Persistence | Reset on refresh, remember within session when proceeding |

---

## Server-Side Data Approach

You raised a good point: instead of parsing `"512x768"` on the client, have the server provide pre-parsed values:

**Current API response:**
```json
{
  "value": "512x512",
  "count": 10
}
```

**Proposed API response:**
```json
{
  "value": "512x512",
  "width": 512,
  "height": 512,
  "count": 10
}
```

This eliminates client-side parsing for **reading**. For **writing**, the client composes `"{width}x{height}"` and sends back the combined string.

### Benefits
- No Jinja2 parsing templates needed for initial values
- Alternative fields just reference sibling data fields directly
- Simpler, more predictable

### Trade-off
- Server must provide parsed fields for every alternative-capable field
- But you control the SD API, so this is fine

---

## Revised Schema Design

Given server provides `width` and `height` alongside `value`:

```json
{
  "resolution": {
    "type": "string",
    "title": "Resolution",
    "required": true,
    "_ux": {
      "input_type": "select"
    },
    "alternative": {
      "compose": "{width}x{height}",
      "layout": "inline",
      "fields": [
        {
          "key": "width",
          "type": "integer",
          "title": "W",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "_ux": {
            "input_type": "number"
          }
        },
        {
          "type": "string",
          "content": "x",
          "_ux": {
            "render_as": "text"
          }
        },
        {
          "key": "height",
          "type": "integer",
          "title": "H",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "_ux": {
            "input_type": "number"
          }
        }
      ]
    }
  }
}
```

### Schema Properties

| Property | Type | Description |
|----------|------|-------------|
| `alternative` | object | Container for alternative input config |
| `alternative.compose` | string | Template with `{fieldKey}` placeholders to build primary value |
| `alternative.layout` | string | `"inline"` (horizontal) or `"stack"` (vertical). Default: `"inline"` |
| `alternative.fields` | array | Ordered list of field definitions |

### Field Properties

| Property | Type | Description |
|----------|------|-------------|
| `key` | string | **Required for inputs.** Maps to sibling data field AND used in compose template |
| `type` | string | `"integer"`, `"number"`, `"string"` |
| `title` | string | Short label (inline layout = compact labels like "W", "H") |
| `content` | string | For static text elements (when no `key`) |
| `minimum`, `maximum`, `step` | number | Validation for number inputs |
| `_ux.input_type` | string | `"number"`, `"text"`, etc. |
| `_ux.render_as` | string | `"text"` for static display elements |

---

## Data Flow

### Initial Load

```
Server data: { value: "512x768", width: 512, height: 768, count: 10 }
                    │                │           │
                    ▼                ▼           ▼
Primary field: resolution = "512x768"
Alternative fields: width = 512, height = 768
```

Alternative fields read their initial values from **sibling keys in the same data object**.

### User Edits (Alternative Mode)

```
User changes width to 640
    │
    ▼
Compose: "{width}x{height}" → "640x768"
    │
    ▼
Update primary field: resolution = "640x768"
    │
    ▼
Context.setValue("resolution", "640x768")
```

### Submission

Only the primary field value is submitted. Alternative fields are UI-only.

---

## Open Question: Where Does Alternative Field Data Come From?

The `resolution` field is inside `input_schema`, and its data comes from the parent object being rendered. But where do `width` and `height` live?

**Option A: Sibling fields in the same data object**

If the data object for the tab is:
```json
{
  "prompt": "...",
  "resolution": "512x768",
  "width": 512,
  "height": 768
}
```

Then alternative fields with `key: "width"` and `key: "height"` read from this object.

**Option B: Nested in the enum option object**

The resolution dropdown options come from dynamic enum (controlled by `checkpoint`):
```json
[
  { "value": "512x768", "width": 512, "height": 768, "count": 10 },
  { "value": "1024x1024", "width": 1024, "height": 1024, "count": 5 }
]
```

When user selects "512x768", we have access to the full option object including `width` and `height`.

<!--i think you misundetood the data flow there, resolution is not part of
original fields from server, its part of large object which is drilled down to
current value. if you see the schema, model_category ->controls-> checkpint
->controls-> resolution. checkpoint sets params.resolutiion (ex: {"value": "512x512", "count": 10}) to resolition field

with the change I add, resolution object will be as this: {"value": {"text":
"512x512", "height": 512, "width": 512}, "count": 10}, so checkpoint control of
resolution will look like "label_format": "{value.text}". since "enum_path" is
"params.resolution", the dropdown of resolutions will have all the data it
needs to show alternative.

question here is not how we get data, its about how we control alternative(s)
just by relying on schema. 

also, please read full schema next time, it should have most answers you need.
-->

**Question:** Which data source should alternative fields use?
- Option A requires server to include `width`/`height` at the top level of the data
- Option B uses the already-available option object from the dropdown

---

## Questions for Review

1. **Data source**: Should alternative fields read from:
   - A) Top-level sibling data (server adds `width`, `height` to main data object)
   - B) Selected option object (already has `width`, `height` from enum)
   <!--answered above-->

2. **Default values**: When user clicks toggle to alternative mode but no option is selected yet, what values should show?
   - Empty fields?
   - Default values from schema (`default` property)?
   - Last known values?

   <--for this specific use case, it will always have data. but we can rely on
   default value of parent. for example, parent had default_index, means parent
   have a default value. if not, i think our controls we are going to use here
   support default values anyways.-->

3. **Toggle behavior**: When user switches from alternative back to primary mode:
   - Keep the composed value in the dropdown (may not match any option)?
   - Reset to previously selected option?
   - Show "Custom" as the selected label?
   
   <!--hmmm, this is a good one, for now, lets say that if provided combo is
   not there on parent value list, it will go to default, which reset
   alternative data. we added item to TECHNICAL_DEBT to address this.-->
