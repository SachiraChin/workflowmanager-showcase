# Alternative Input Schema - R4 (Final)

## Summary

Add schema-driven alternative input mechanism allowing fields to have multiple input modes (e.g., dropdown OR custom width/height inputs). Everything is driven by schema - no hardcoded TypeScript types for specific value shapes.

---

## Decisions Summary

| Decision | Choice |
|----------|--------|
| Mode switching UI | Toggle button/icon |
| Value storage | Combined in primary field as object |
| Static elements | `_ux.render_as: "text"` with `content` |
| Validation | Number input type with min/max/step |
| Composition timing | Every keystroke, no debounce (local state only) |
| Controls interaction | Mutually exclusive with `alternative` |
| Type field | Keep as `"string"` - refers to submission type |
| Submission | Extract `value.text` (the string part) |
| Toggle back behavior | Reset to default if composed value not in options |

---

## Server API Change

Resolution options change from:
```json
[
  { "value": "512x768", "count": 10 }
]
```

To:
```json
[
  { "value": { "text": "512x768", "width": 512, "height": 768 }, "count": 10 }
]
```

Schema's `label_format` changes to: `"{value.text} (count: {count})"`

---

## Schema Design

### Resolution Field with Alternative

```json
{
  "resolution": {
    "type": "string",
    "title": "Resolution",
    "required": true,
    "_ux": {
      "input_type": "select"
    },
    "alternative": {
      "compose": {
        "text": "{width}x{height}"
      },
      "layout": "inline",
      "fields": [
        {
          "key": "width",
          "type": "integer",
          "title": "W",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "default": 512,
          "_ux": {
            "input_type": "number"
          }
        },
        {
          "content": "x",
          "_ux": {
            "render_as": "text"
          }
        },
        {
          "key": "height",
          "type": "integer",
          "title": "H",
          "minimum": 64,
          "maximum": 2048,
          "step": 64,
          "default": 768,
          "_ux": {
            "input_type": "number"
          }
        }
      ]
    }
  }
}
```

### Alternative Config Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `compose` | object | Yes | Map of field paths to template strings. Templates use `{key}` syntax. |
| `layout` | string | No | `"inline"` (horizontal) or `"stack"` (vertical). Default: `"inline"` |
| `fields` | array | Yes | Ordered list of field definitions |

### Field Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `key` | string | For inputs | Path into stored value object (e.g., `"width"` → `value.width`) |
| `content` | string | For static | Text to display (field without `key` = static element) |
| `type` | string | For inputs | `"integer"`, `"number"`, `"string"` |
| `title` | string | No | Label for input |
| `default` | any | No | Default when no prior value exists |
| `minimum` | number | No | Min constraint for number inputs |
| `maximum` | number | No | Max constraint for number inputs |
| `step` | number | No | Step increment for number inputs |
| `_ux.input_type` | string | For inputs | `"number"`, `"text"` |
| `_ux.render_as` | string | For static | `"text"` |

---

## Implementation Plan

### 1. Context Changes (InputSchemaContext)

Add alternative mode tracking:

```typescript
// New state
alternativeMode: Record<string, boolean>  // fieldKey → isAlternativeActive

// New methods
isAlternativeMode: (key: string) => boolean
setAlternativeMode: (key: string, active: boolean) => void
```

### 2. New Component: AlternativeInputWrapper

Location: `ui/webui/src/components/workflow/interactions/schema-interaction/renderers/AlternativeInputWrapper.tsx`

Responsibilities:
- Render toggle button in field label area
- Conditionally render primary input OR alternative fields
- Handle mode switching logic
- Run compose template when alternative fields change

### 3. Rendering Integration

Modify `TerminalRenderer` to check for `alternative` in schema:
- If present, wrap the input component with `AlternativeInputWrapper`
- Pass through all existing props

<!--i dont think this is the mechanism for this. TerminalRenderer is only based input or type, nothing else. check one more specific data to inputs is not a concern of TerminalRenderer. tbh, i didnt like adding inputs in TerminalRenderer anyways, lets create new component InputRenderer which will routed by SchemaRenderer if schema is for input (we probably need to clean that too later, add this also to tech debpt, btw, you didnt add tech debt item i ask you add before). In InputRenderer, we can do all the checks we want to do for inputs, which include alternative.
-->

### 4. Compose Logic

When alternative field changes:
1. Get current value object from context
2. Update the changed field (e.g., `value.width = newWidth`)
3. For each key in `compose`:
   - Run template substitution: `"{width}x{height}"` → `"640x768"`
   - Update `value[key]` with result
4. Call `context.setValue(fieldKey, updatedValue)`

### 5. Submission (getMappedValues)

When building submission values:
- If value is object with `text` property, extract `value.text`
- Otherwise use value as-is

This handles both:
- Regular string values: `"512x768"` → `"512x768"`
- Object values from alternative: `{ text: "512x768", ... }` → `"512x768"`

---

## UI Mockup

```
┌─────────────────────────────────────────────────────────┐
│ Resolution                                    [⇄]      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ PRIMARY MODE (toggle off):                              │
│   ┌─────────────────────────────────────────┐          │
│   │ 512x768 (count: 10)                  ▼  │          │
│   └─────────────────────────────────────────┘          │
│                                                         │
│ ALTERNATIVE MODE (toggle on):                           │
│   ┌────────┐     ┌────────┐                            │
│   │  512   │  x  │  768   │                            │
│   └────────┘     └────────┘                            │
│   W              H                                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

Toggle icon: `⇄` or similar swap/switch icon

---

## Files to Modify/Create

| File | Change |
|------|--------|
| `InputSchemaContext.tsx` | Add `alternativeMode`, `isAlternativeMode`, `setAlternativeMode` |
| `InputSchemaComposer.tsx` | Initialize `alternativeMode` state, provide in context |
| `TerminalRenderer.tsx` | Check for `alternative`, wrap with `AlternativeInputWrapper` |
| `AlternativeInputWrapper.tsx` | **NEW** - Toggle + conditional rendering + compose logic |
| `types.ts` | Add `AlternativeConfig` and `AlternativeField` interfaces |
| `cc_image_prompts_display_schema.json` | Add `alternative` to resolution field |

### Server-side
| File | Change |
|------|--------|
| SD API | Return `{ value: { text, width, height }, count }` for resolution options |

---

## Edge Cases

1. **No selection yet**: Use `default` values from alternative field schemas
2. **Toggle back with custom value**: Reset to default option if composed value doesn't match any dropdown option
3. **Value is string (not object)**: For backwards compatibility, if value is string, alternative mode extracts via compose pattern in reverse (or uses defaults)

---

## Technical Debt (Future)

- When toggling back to primary mode with custom value, could add "Custom" as a virtual option instead of resetting
- Could support nested key paths like `"dimensions.width"` if needed
