 CardStackRenderer Refactoring Architecture

## Summary

CardStackRenderer has grown to 732 lines through incremental patches, becoming difficult to maintain. This document analyzes the root causes and proposes a sustainable refactoring strategy that leverages existing SchemaRenderer capabilities.

---

## SchemaRenderer Capability Analysis

Before proposing changes, we must understand what SchemaRenderer already handles:

### What SchemaRenderer Provides

| Capability | Implementation | Used by CardStackRenderer? |
|------------|---------------|---------------------------|
| Recursive object/array traversal | Lines 245-380 | ❌ Re-implements manually |
| `display_format` → template rendering | Lines 185-201 | ✅ Delegates via SchemaRenderer |
| `display_order` field sorting | Lines 329-333 | ❌ Re-implements manually |
| `display: true` enforcement (strictMode) | Lines 291-300, 388-390 | ✅ Passes through |
| `selectable` → SelectableItem wrapping | Lines 154-180 | ❌ Re-implements manually |
| Container type routing | Lines 206-216 | N/A (CardStackRenderer IS a container) |
| Role type detection | Lines 234-240 | ❌ Re-implements in discovery |
| Field labels via TerminalRenderer | TextRenderer:26-28 | ❌ Re-implements manually |
| Computed fields | Lines 309-325 | ✅ Inherits |
| Decorator support | Via SelectableItem | ❌ Re-implements partially |

### Key Finding: SelectableItem Already Has Card Variant

`SelectableItem` (lines 72-118) provides a "cards" variant with:
- Card wrapper with selection styling
- Selection indicator in top-right corner
- Click handling for toggle
- Decorator support (border colors, swatches, badges)
- Disabled/readonly states

**But CardStackRenderer doesn't use it.** Instead, it manually implements selection logic (CardStackRenderer lines 295-348):

```typescript
// CardStackRenderer re-implements what SelectableItem already does:
const selection = useSelectionOptional();
const isSelectable = itemSchema.selectable === true && selection !== null;
const isSelected = isSelectable && selection.isSelected(path);
const canSelectThis = isSelectable && selection.canSelect(path);
const isReadonly = interactionMode.type === "readonly";
const disabled = isSelectable && !canSelectThis && !isSelected;
// ... 50+ more lines of selection handling
```

### What CardStackRenderer Actually Adds

Features that SchemaRenderer/SelectableItem DON'T provide:

1. **Index badge** - Shows "1", "2", "3" in card header
2. **Role type consumption** - Extracts `card-title`, `card-subtitle` from properties BEFORE rendering
3. **Header positioning** - Places role types in structured header section
4. **Highlight field styling** - Special colored background for `highlight: true`
5. **Smart grid layout** - Short fields in responsive grid, long fields full-width
6. **Object mode discovery** - Scans properties for `render_as: "card-content"`
7. **Stack-level header** - Object mode shows title/subtitle at stack level

---

## Workflow Schema Usage Patterns

Analysis of OMS and CC workflows reveals 5 usage patterns:

### Pattern 1: Array Mode with card-title/card-subtitle
```json
{
  "type": "array",
  "render_as": "card-stack",
  "items": {
    "selectable": true,
    "properties": {
      "label": { "render_as": "card-title" },
      "description": { "render_as": "card-subtitle" },
      "other_field": { "display": true }
    }
  }
}
```
**Used in:** `pet_type_display_schema.json`, `scene_display_schema.json`

### Pattern 2: Object Mode with card-content
```json
{
  "type": "object",
  "render_as": "card-stack",
  "properties": {
    "prompt_a": { "render_as": "card-content", "display_label": "Prompt A" },
    "prompt_b": { "render_as": "card-content", "display_label": "Prompt B" }
  }
}
```
**Used in:** `midjourney_display_schema.json`, `leonardo_display_schema.json`

### Pattern 3: Nested in section-list (Array)
```json
{
  "render_as": "section-list",
  "items": {
    "properties": {
      "title": { "render_as": "section-title" },
      "ideas": {
        "render_as": "card-stack",
        "items": { "selectable": true, "properties": { ... } }
      }
    }
  }
}
```
**Used in:** `aesthetic_display_schema.json`, `cc_text_overlays_display_schema.json`

### Pattern 4: Nested in section-list (Object)
```json
{
  "render_as": "section-list",
  "properties": {
    "scene_title": { "render_as": "section-title" },
    "prompts": {
      "properties": {
        "midjourney": { "render_as": "card-stack", "properties": { ... } },
        "leonardo": { "render_as": "card-stack", "properties": { ... } }
      }
    }
  }
}
```
**Used in:** `cc_image_prompts_display_schema.json`, `cc_video_prompts_display_schema.json`

### Pattern 5: Object Mode with card-subtitle as header
```json
{
  "render_as": "card-stack",
  "properties": {
    "prompt": { "render_as": "card-content" },
    "strength": { "render_as": "card-subtitle", "highlight": true }
  }
}
```
**Role semantics differ by mode:**
- Array mode: `card-subtitle` → per-card subtitle
- Object mode: `card-subtitle` → stack-level header metadata

---

## Root Cause Analysis

### Why CardStackRenderer Is 732 Lines

| Issue | Lines | Root Cause |
|-------|-------|------------|
| Manual selection logic | ~60 | Doesn't use SelectableItem |
| Field discovery functions | ~90 | Re-implements SchemaRenderer's traversal |
| Manual field iteration | ~80 | Doesn't delegate to SchemaRenderer |
| Duplicated utilities | ~40 | Same as SectionListRenderer |
| Dual-mode handling | ~100 | Array vs Object not separated |
| Header rendering | ~90 | Duplicated from SectionListRenderer |
| Smart layout logic | ~50 | Unique to CardStackRenderer |

**Total duplicated/re-implemented: ~460 lines (63%)**

---

## Proposed Refactoring Strategy

### Design Principle: Maximize SchemaRenderer Delegation

Instead of re-implementing what SchemaRenderer does, CardStackRenderer should:
1. **Extract role types** from schema (card-title, card-subtitle, card-content)
2. **Render header section** with extracted role types
3. **Delegate body rendering** to SchemaRenderer with filtered schema
4. **Use shared selection hook** instead of manual implementation

### New Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                      CardStackRenderer                          │
│  - Routes to ArrayMode or ObjectMode based on data type         │
│  - ~30 lines                                                    │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────┐
│   ArrayModeCardStack    │     │   ObjectModeCardStack   │
│  - Iterates items       │     │  - Discovers cards      │
│  - Renders Card per item│     │  - Renders stack header │
│  - ~40 lines            │     │  - Renders Card per card│
└─────────────────────────┘     │  - ~60 lines            │
              │                 └─────────────────────────┘
              │                               │
              └───────────────┬───────────────┘
                              ▼
                    ┌─────────────────┐
                    │      Card       │
                    │  - Uses shared  │
                    │    selection    │
                    │  - CardHeader   │
                    │  - CardBody     │
                    │  - ~50 lines    │
                    └─────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
     ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
     │ CardHeader  │  │  CardBody   │  │  Shared     │
     │ - Title     │  │ - Delegates │  │  Selection  │
     │ - Subtitle  │  │   to Schema │  │  Hook       │
     │ - Highlights│  │   Renderer  │  │             │
     │ - ~60 lines │  │ - ~30 lines │  │ - ~40 lines │
     └─────────────┘  └─────────────┘  └─────────────┘
```

### Core Changes

#### 1. Shared Selection Hook (`shared/useItemSelection.ts`)

Extract selection logic used by both SelectableItem and Card:

```typescript
export function useItemSelection(
  schema: SchemaProperty,
  path: string[],
  data: unknown
) {
  const selection = useSelectionOptional();
  const { mode: interactionMode } = useInteraction();

  const isSelectable = schema.selectable === true && selection !== null;
  const isSelected = isSelectable && selection.isSelected(path);
  const canSelectThis = isSelectable && selection.canSelect(path);
  const isReadonly = interactionMode.type === "readonly";
  const isReviewMode = selection?.mode === "review";
  const disabled = isSelectable && !canSelectThis && !isSelected;

  const handleClick = useCallback(() => {
    if (!isSelectable || isReviewMode || isReadonly || disabled) return;
    selection?.toggleSelection(path, data);
  }, [isSelectable, isReviewMode, isReadonly, disabled, selection, path, data]);

  return {
    isSelectable,
    isSelected,
    canSelectThis,
    isReadonly,
    isReviewMode,
    disabled,
    selectionMode: selection?.mode,
    handleClick,
  };
}
```

**Impact:** Eliminates ~60 lines from CardStackRenderer, ~40 lines from SelectableItem.

#### 2. CardBody Delegates to SchemaRenderer

Instead of manually iterating body fields:

```typescript
// BEFORE (CardStackRenderer lines 480-521):
{shortFields.map((field) => (
  <div key={field.key}>
    <div className="text-xs font-semibold...">{label}</div>
    <SchemaRenderer data={field.value} schema={...} path={...} />
  </div>
))}
{longFields.map((field) => (
  <div key={field.key}>
    <div className="text-xs font-semibold...">{label}</div>
    <SchemaRenderer data={field.value} schema={...} path={...} />
  </div>
))}

// AFTER:
function CardBody({ data, schema, path, strictMode }: CardBodyProps) {
  // Filter out role types - they're rendered in CardHeader
  const bodySchema = useMemo(() => filterRoleTypes(schema), [schema]);

  return (
    <div className="px-5 pb-5 pt-0">
      <div className="border-t border-border pt-4">
        <SchemaRenderer
          data={data}
          schema={bodySchema}
          path={path}
          strictMode={strictMode}
        />
      </div>
    </div>
  );
}
```

**Trade-off:** Loses smart grid layout for short fields.

**Mitigation options:**
- Accept simpler layout (most fields are text anyway)
- Add `render_as: "field-grid"` container type for smart layout
- Keep smart layout in CardBody but use SchemaRenderer per-field

#### 3. Role Type Extraction Utility (`shared/extractRoleTypes.ts`)

```typescript
interface ExtractedRoles {
  titles: FieldInfo[];
  subtitles: FieldInfo[];
  highlights: FieldInfo[];
  body: SchemaProperty;  // Schema with role types removed
}

export function extractCardRoles(
  data: Record<string, unknown>,
  schema: SchemaProperty
): ExtractedRoles {
  const titles: FieldInfo[] = [];
  const subtitles: FieldInfo[] = [];
  const highlights: FieldInfo[] = [];
  const bodyProperties: Record<string, SchemaProperty> = {};

  for (const [key, propSchema] of Object.entries(schema.properties || {})) {
    const value = data[key];

    if (propSchema.render_as === "card-title") {
      titles.push({ key, value, schema: propSchema });
    } else if (propSchema.render_as === "card-subtitle") {
      subtitles.push({ key, value, schema: propSchema });
    } else if (propSchema.display === true && propSchema.highlight === true) {
      highlights.push({ key, value, schema: propSchema });
    } else {
      bodyProperties[key] = propSchema;
    }
  }

  return {
    titles,
    subtitles,
    highlights,
    body: { ...schema, properties: bodyProperties },
  };
}
```

#### 4. Simplified Card Component

```typescript
function Card({ data, schema, path, index, strictMode, title }: CardProps) {
  const {
    isSelectable,
    isSelected,
    isReadonly,
    disabled,
    selectionMode,
    handleClick,
  } = useItemSelection(schema, path, data);

  const isObjectData = typeof data === "object" && data !== null;
  const roles = useMemo(
    () => isObjectData ? extractCardRoles(data, schema) : null,
    [data, schema, isObjectData]
  );

  return (
    <div
      className={cn(
        "relative rounded-lg border-2 bg-card/80 transition-all",
        isSelectable && !isReadonly && "cursor-pointer",
        isSelected ? "border-primary bg-primary/5" : "border-border",
        disabled && "opacity-50 cursor-not-allowed"
      )}
      onClick={handleClick}
    >
      <SelectionIndicator show={isSelectable && selectionMode === "select"} isSelected={isSelected} />

      <CardHeader
        index={index}
        title={title}
        roles={roles}
        path={path}
        isSelectable={isSelectable}
      />

      <CardBody
        data={data}
        schema={roles?.body || schema}
        path={path}
        strictMode={strictMode}
      />
    </div>
  );
}
```

---

## File Structure

```
renderers/containers/
├── shared/
│   ├── types.ts              # FieldInfo, ExtractedRoles
│   ├── useItemSelection.ts   # Shared selection hook
│   ├── extractRoleTypes.ts   # Role extraction utilities
│   ├── utils.ts              # toArray, singleValueSchema
│   └── HeaderFields.tsx      # Reusable header rendering
│
├── card-stack/
│   ├── index.ts              # Public export
│   ├── CardStackRenderer.tsx # Router (~30 lines)
│   ├── ArrayModeCardStack.tsx
│   ├── ObjectModeCardStack.tsx
│   ├── Card.tsx              # Composition wrapper (~50 lines)
│   ├── CardHeader.tsx        # Title/subtitle/highlights
│   ├── CardBody.tsx          # Delegates to SchemaRenderer
│   ├── SelectionIndicator.tsx
│   └── config.ts             # Colors, role mappings
│
├── section-list/             # Same pattern
│   └── ...
│
├── TableRenderer.tsx
└── ContainerRenderer.tsx
```

---

## Migration Phases

### Phase 1: Extract Shared Selection Hook (Low Risk)
1. Create `shared/useItemSelection.ts`
2. Refactor SelectableItem to use it
3. Refactor Card in CardStackRenderer to use it
4. **Test:** Selection behavior unchanged

### Phase 2: Extract Role Type Utilities (Low Risk)
1. Create `shared/extractRoleTypes.ts`
2. Create `shared/types.ts` with FieldInfo
3. Update CardStackRenderer to use extraction
4. **Test:** Role types still render correctly

### Phase 3: Separate Array/Object Modes (Medium Risk)
1. Create ArrayModeCardStack.tsx
2. Create ObjectModeCardStack.tsx
3. Slim CardStackRenderer to router
4. **Test:** All 5 usage patterns work

### Phase 4: CardBody Delegates to SchemaRenderer (Medium Risk)
1. Create CardBody that filters role types and delegates
2. Decide on smart grid layout (keep/remove/new container)
3. **Test:** Body fields render with labels, sorting, templates

### Phase 5: Apply to SectionListRenderer (Medium Risk)
1. Same pattern as CardStackRenderer
2. Reuse shared utilities
3. **Test:** Section expand/collapse, nested card-stacks

---

## Expected Outcomes

| Metric | Before | After |
|--------|--------|-------|
| CardStackRenderer.tsx | 732 lines | ~30 lines (router) |
| Total card-stack/ folder | 732 lines | ~250 lines |
| SectionListRenderer.tsx | 700 lines | ~30 lines (router) |
| Shared utilities | 0 lines | ~150 lines |
| Selection code duplication | 100+ lines | 0 |
| SchemaRenderer delegation | Partial | Full (for body) |

---

<!--

I got the gist of your proposal, but I feel like we are working on same constraints as before, and still can lead to some issues we have now (for example feature creap). given that, let me ask you a differnt question, how can we update SchemaRenderer to render containers in different way, right now we just do a render_as check and send whole context to router, where SchemaRenderer looses control over it completely. How can we change this? for example, something like below

<SchemaRenderer container={SectionListRender} ...>
    {{
        obj.forEach((key, value) => {
            return <SchemaRenderer renderer={SectionListRender.Field} ... />
        })
    }}
</SchemaRenderer>

In above case, container/renderer only can provide style for content, but it cant render value itself. this is not a 100% accurate picture implementation, its just a mind map I thought of. I am unsure about the complexity or feasibility of the idea, i just want to entertain it.
-->

## Questions for Review

1. **Smart grid layout:** Should we:
   - (A) Remove it - let SchemaRenderer handle all body fields simply
   - (B) Keep it - maintain current short/long categorization in CardBody
   - (C) New container - create `render_as: "field-grid"` for reuse

2. **SelectableItem refactor:** Should we also update SelectableItem to use `useItemSelection`, or just CardStackRenderer for now?

3. **Phase priority:** Start with selection hook extraction (safest) or mode separation (biggest structural improvement)?

4. **Testing:** Should we add unit tests for `extractCardRoles` and `useItemSelection` before refactoring?

5. **SectionListRenderer:** Refactor simultaneously or after CardStackRenderer proves the pattern?
