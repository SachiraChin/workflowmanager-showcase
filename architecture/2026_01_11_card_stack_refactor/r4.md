# CardStackRenderer Refactoring Architecture - Revision 4

## Summary

This revision finalizes the approach based on operator feedback. The core idea: **SchemaRenderer is a pure data extractor** that knows nothing about specific containers. Renderers receive only `schema` (for styling hints) and `children` (pre-rendered), never raw data. Renderers declare their slot configuration, and SchemaRenderer groups and renders children into those slots.

---

## Final Approach: Renderer-Owned Slot Components

After evaluating 7 options in R3, the operator proposed a hybrid that combines the best aspects:

- **Renderer declares slotConfigs** - array of `{ match, Slot }` pairs
- **SchemaRenderer iterates slotConfigs** - filters data, wraps in Slot component
- **Slots are owned by renderer** - renderer controls presentation completely
- **SchemaRenderer stays generic** - just iterates and wraps

### Implementation

```tsx
// Renderer definition
const CardStackRenderer: Renderer = {
  slotConfigs: [
    { match: (s) => s.render_as === "card-title", Slot: CardTitleSlot },
    { match: (s) => s.render_as === "card-subtitle", Slot: CardSubtitleSlot },
    { match: (s) => s.highlight === true, Slot: CardHighlightSlot },
    { match: () => true, Slot: CardBodySlot },  // fallback catches rest
  ],

  Render: CardStackWrapper,
  Field: CardRenderer,  // Can itself be a Renderer for nested objects
};

// SchemaRenderer usage
if (renderer) {
  const { slotConfigs, Render, Field } = renderer;

  return (
    <Render schema={schema} index={index}>
      {slotConfigs.map((slotConfig, slotIdx) => {
        const filtered = innerData.filter(d => slotConfig.match(d.schema));

        if (filtered.length === 0) return null;

        return (
          <slotConfig.Slot key={slotIdx}>
            {filtered.map((item) => (
              <SchemaRenderer
                key={item.key}
                data={item.value}
                schema={item.schema}
                renderer={Field}
                path={[...path, String(item.key)]}
                index={item.key}
              />
            ))}
          </slotConfig.Slot>
        );
      })}
    </Render>
  );
}
```

### Why This Approach

| Aspect | Benefit |
|--------|---------|
| **Renderer owns slots** | No slot knowledge in SchemaRenderer |
| **Match functions** | Flexible filtering logic per renderer |
| **Slot components** | Renderer controls all styling |
| **Fallback slot** | `match: () => true` catches unmatched fields |
| **Order matters** | First matching slot wins (like CSS cascade) |
| **Type-safe** | SlotConfig interface is strict |

### Complexity Assessment

- **Implementation**: Low-medium. SchemaRenderer adds ~20 lines for slot iteration
- **Maintainability**: High. All renderer logic lives in renderer files
- **Type Safety**: High. SlotConfig and Renderer interfaces are well-defined
- **Testing**: Easy. Each slot component testable in isolation

---

## Renderer Interface (Final)

```tsx
interface SlotConfig {
  /** Filter function - receives schema, returns true if field belongs in this slot */
  match: (schema: SchemaProperty) => boolean;

  /** Component to wrap matched fields */
  Slot: React.FC<{ children: ReactNode }>;
}

interface Renderer {
  /** Slot configuration - order matters, first match wins */
  slotConfigs?: SlotConfig[];

  /** Wrapper component for the entire container */
  Render: React.FC<{
    schema: SchemaProperty;
    index?: number;
    children: ReactNode;
  }>;

  /** Per-item renderer - can be a component or nested Renderer */
  Field?: React.FC<{ schema: SchemaProperty; children: ReactNode }> | Renderer;
}
```

### Default Renderer (No Slots)

```tsx
const DefaultRenderer: Renderer = {
  // No slotConfigs - all children rendered flat
  Render: ({ children }) => <div className="space-y-2">{children}</div>,
  Field: ({ children }) => <>{children}</>,
};
```

---

## CardStack Renderer Implementation

### File: `renderers/CardStackRenderer.tsx`

```tsx
import { Renderer, SlotConfig } from "./types";

// Slot Components
const CardTitleSlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="flex-1 min-w-0">{children}</div>
);

const CardSubtitleSlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="text-sm text-muted-foreground mt-1">{children}</div>
);

const CardHighlightSlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="mt-3 space-y-2">{children}</div>
);

const CardBodySlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="border-t border-border mt-4 pt-4 space-y-3">{children}</div>
);

// Card wrapper (for each array item)
const CardWrapper: React.FC<{
  schema: SchemaProperty;
  index?: number;
  children: ReactNode;
}> = ({ schema, index, children }) => {
  return (
    <div className="relative rounded-lg border-2 border-border bg-card/80">
      <div className="p-5">
        {index !== undefined && (
          <div className="absolute -left-3 -top-3 w-7 h-7 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-bold">
            {index + 1}
          </div>
        )}
        {children}
      </div>
    </div>
  );
};

// Stack wrapper (for the array container)
const CardStackWrapper: React.FC<{
  schema: SchemaProperty;
  children: ReactNode;
}> = ({ children }) => (
  <div className="flex flex-col gap-3">{children}</div>
);

// Field renderer for properties inside card
const CardField: React.FC<{
  schema: SchemaProperty;
  children: ReactNode;
}> = ({ schema, children }) => {
  const label = schema.display_label || "";
  const highlightColor = schema.highlight_color;

  return (
    <div
      className={cn(
        "rounded-md",
        schema.highlight && "px-3 py-2",
      )}
      style={schema.highlight && highlightColor ? { backgroundColor: `${highlightColor}20` } : undefined}
    >
      {label && (
        <div className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mb-1">
          {label}
        </div>
      )}
      {children}
    </div>
  );
};

// The Renderer definition
export const CardStackRenderer: Renderer = {
  // Stack level - wraps all cards
  Render: CardStackWrapper,

  // Each array item becomes a card
  Field: {
    // Card level - has slots for title/subtitle/body
    slotConfigs: [
      { match: (s) => s.render_as === "card-title", Slot: CardTitleSlot },
      { match: (s) => s.render_as === "card-subtitle", Slot: CardSubtitleSlot },
      { match: (s) => s.highlight === true, Slot: CardHighlightSlot },
      { match: () => true, Slot: CardBodySlot },
    ],
    Render: CardWrapper,
    Field: CardField,
  },
};
```

### Estimated Lines: ~100

Compare to current CardStackRenderer.tsx: **732 lines** (86% reduction)

---

## SectionList Renderer Implementation

### File: `renderers/SectionListRenderer.tsx`

```tsx
// Slot Components
const SectionTitleSlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="flex items-center gap-2">{children}</div>
);

const SectionSummarySlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="text-sm text-muted-foreground mt-1">{children}</div>
);

const SectionContentSlot: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="mt-4 space-y-4">{children}</div>
);

// Section wrapper with expand/collapse
const SectionWrapper: React.FC<{
  schema: SchemaProperty;
  index?: number;
  children: ReactNode;
}> = ({ schema, index, children }) => {
  const [isExpanded, setIsExpanded] = useState(true);

  return (
    <div className="border-l-4 border-primary/30 pl-4">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="flex items-center gap-2 w-full text-left"
      >
        <ChevronIcon className={cn("transition-transform", isExpanded && "rotate-90")} />
        {/* Title slot content injected here via children */}
      </button>
      {isExpanded && children}
    </div>
  );
};

// Stack wrapper
const SectionListWrapper: React.FC<{ children: ReactNode }> = ({ children }) => (
  <div className="space-y-6">{children}</div>
);

export const SectionListRenderer: Renderer = {
  Render: SectionListWrapper,

  Field: {
    slotConfigs: [
      { match: (s) => s.render_as === "section-title", Slot: SectionTitleSlot },
      { match: (s) => s.render_as === "section-summary", Slot: SectionSummarySlot },
      { match: () => true, Slot: SectionContentSlot },
    ],
    Render: SectionWrapper,
    Field: DefaultFieldRenderer,
  },
};
```

### Estimated Lines: ~80

Compare to current SectionListRenderer.tsx: **700 lines** (89% reduction)

---

## Simplified SchemaRenderer

### Core Logic (~150 lines total)

```tsx
function SchemaRenderer({
  data,
  schema,
  renderer,
  path = [],
  strictMode = false,
  index,
}: SchemaRendererProps) {
  // 1. Handle null/undefined
  if (data == null) {
    return null;
  }

  // 2. Handle selectable - wrap and recurse
  if (schema.selectable) {
    return (
      <SelectableItem path={path} data={data} schema={schema}>
        <SchemaRenderer
          data={data}
          schema={{ ...schema, selectable: undefined }}
          renderer={renderer}
          path={path}
          strictMode={strictMode}
          index={index}
        />
      </SelectableItem>
    );
  }

  // 3. Handle display_format (template collapsing)
  if (schema.display_format && !schema.render_as) {
    const formatted = renderTemplate(schema.display_format, data);
    return <TerminalRenderer value={formatted} schema={schema} />;
  }

  // 4. Handle container - switch renderer
  if (isContainer(schema.render_as)) {
    const containerRenderer = getRenderer(schema.render_as);
    return (
      <SchemaRenderer
        data={data}
        schema={schema}
        renderer={containerRenderer}
        path={path}
        strictMode={strictMode}
        index={index}
      />
    );
  }

  // 5. Extract inner data
  const innerData = extractInnerData(data, schema, strictMode);

  // 6. If no inner data and no renderer, terminal render
  if (innerData.length === 0) {
    return <TerminalRenderer value={data} schema={schema} />;
  }

  // 7. Render with renderer
  if (renderer) {
    return renderWithSlots(renderer, schema, innerData, path, index);
  }

  // 8. Default: render children flat
  return (
    <div className="space-y-2">
      {innerData.map((item) => (
        <SchemaRenderer
          key={item.key}
          data={item.value}
          schema={item.schema}
          path={[...path, String(item.key)]}
          strictMode={item.strictMode}
        />
      ))}
    </div>
  );
}

// Slot rendering helper
function renderWithSlots(
  renderer: Renderer,
  schema: SchemaProperty,
  innerData: InnerDataItem[],
  path: string[],
  index?: number
) {
  const { slotConfigs, Render, Field } = renderer;
  const usedKeys = new Set<string | number>();

  return (
    <Render schema={schema} index={index}>
      {slotConfigs?.map((slotConfig, slotIdx) => {
        // Filter to matching items not yet used
        const filtered = innerData.filter(
          (d) => !usedKeys.has(d.key) && slotConfig.match(d.schema)
        );

        // Mark as used
        filtered.forEach((d) => usedKeys.add(d.key));

        if (filtered.length === 0) return null;

        return (
          <slotConfig.Slot key={slotIdx}>
            {filtered.map((item) => (
              <SchemaRenderer
                key={item.key}
                data={item.value}
                schema={item.schema}
                renderer={typeof Field === "function" ? undefined : Field}
                path={[...path, String(item.key)]}
                strictMode={item.strictMode}
                index={typeof item.key === "number" ? item.key : undefined}
              />
            ))}
          </slotConfig.Slot>
        );
      }) ?? (
        // No slots - render flat
        innerData.map((item) => (
          <SchemaRenderer
            key={item.key}
            data={item.value}
            schema={item.schema}
            renderer={typeof Field === "function" ? undefined : Field}
            path={[...path, String(item.key)]}
            strictMode={item.strictMode}
          />
        ))
      )}
    </Render>
  );
}
```

---

## Resolved Questions from R3

### 1. Highlight Styling
**Resolution:** Renderer handles it. `CardField` reads `schema.highlight` and `schema.highlight_color` and applies the appropriate background styling. This is purely presentational logic that belongs in the renderer.

### 2. Object Mode Discovery
**Resolution:** SchemaRenderer converts objects into arrays via `extractInnerData`. Properties with `render_as: "card-content"` become array items with their schema intact. The card's slot config handles positioning: fields matching `card-content` go to the content slot.

### 3. Empty States
**Resolution:** SchemaRenderer doesn't render anything directly for empty arrays. Empty data flows through:
1. `innerData` is empty array
2. `renderWithSlots` renders `<Render>` with no slot children
3. Renderer's `Render` component can check `!children` and show empty state
4. Or it passes through to TerminalRenderer which can show "No items"

```tsx
const CardStackWrapper: React.FC<{ children: ReactNode }> = ({ children }) => {
  if (!React.Children.count(children)) {
    return <div className="text-muted-foreground italic">No items</div>;
  }
  return <div className="flex flex-col gap-3">{children}</div>;
};
```

### 4. Error Boundaries
**Resolution:** Each renderer can wrap its `Render` component in an error boundary if needed. Primitives (TerminalRenderer) already handle error cases for malformed data. For now, we rely on existing error handling and add boundaries as needed.

### 5. React.Children.toArray
**Resolution:** This was from Option A (rejected). It's a React utility that converts the `children` prop to a flat array for inspection. We don't need it with the slot approach since SchemaRenderer does the grouping, not the renderer.

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx              # Simplified (~150 lines)
├── SelectableItem.tsx              # Unchanged
├── TerminalRenderer.tsx            # Unchanged
├── helpers/
│   ├── extractInnerData.ts         # Data extraction logic (~60 lines)
│   ├── renderTemplate.ts           # Template string rendering
│   ├── isContainer.ts              # Container detection
│   └── getRenderer.ts              # Renderer registry
├── renderers/
│   ├── types.ts                    # Renderer, SlotConfig interfaces (~30 lines)
│   ├── DefaultRenderer.tsx         # Basic fallback (~20 lines)
│   ├── CardStackRenderer.tsx       # Card stack (~100 lines)
│   ├── SectionListRenderer.tsx     # Section list (~80 lines)
│   └── TableRenderer.tsx           # Table renderer (~60 lines)
└── (DELETE old containers/)
```

### Line Count Comparison

| Component | Before | After | Reduction |
|-----------|--------|-------|-----------|
| SchemaRenderer.tsx | 404 | ~150 | 63% |
| CardStackRenderer.tsx | 732 | ~100 | 86% |
| SectionListRenderer.tsx | 700 | ~80 | 89% |
| New helpers/ | 0 | ~100 | (new) |
| New types.ts | 0 | ~30 | (new) |
| **Total** | **1836** | **~460** | **75%** |

---

## Detailed Plan of Action

### Phase 1: Foundation (Day 1)

**Goal:** Create the new structure without breaking existing functionality.

#### Step 1.1: Create Types
- [ ] Create `renderers/types.ts`
  - Define `SlotConfig` interface
  - Define `Renderer` interface
  - Export all types

#### Step 1.2: Create Helpers
- [ ] Create `helpers/extractInnerData.ts`
  - Move data extraction logic from SchemaRenderer
  - Handle object type (with display_order sorting)
  - Handle array type
  - Apply strictMode filtering
- [ ] Create `helpers/isContainer.ts`
  - Simple check for known container render_as values
- [ ] Create `helpers/getRenderer.ts`
  - Registry mapping render_as to Renderer
  - Returns undefined for non-containers

#### Step 1.3: Create DefaultRenderer
- [ ] Create `renderers/DefaultRenderer.tsx`
  - Simple wrapper with spacing
  - No slots (flat rendering)

### Phase 2: CardStack Renderer (Day 2)

**Goal:** Implement CardStackRenderer following new pattern.

#### Step 2.1: Create Slot Components
- [ ] Create slot components in `renderers/CardStackRenderer.tsx`:
  - `CardTitleSlot` - flex container for title
  - `CardSubtitleSlot` - muted text styling
  - `CardHighlightSlot` - highlighted field container
  - `CardBodySlot` - body with border separator

#### Step 2.2: Create Card Components
- [ ] Create `CardWrapper` component
  - Index badge (absolute positioned)
  - Card border and background styling
  - Receives children (pre-slotted)
- [ ] Create `CardField` component
  - Display label rendering
  - Highlight background with color
  - Wraps terminal content

#### Step 2.3: Create Stack Components
- [ ] Create `CardStackWrapper` component
  - Flex column with gap
  - Empty state handling

#### Step 2.4: Assemble Renderer
- [ ] Define `CardStackRenderer` constant
  - `Render`: CardStackWrapper
  - `Field`: nested Renderer with slotConfigs

### Phase 3: SectionList Renderer (Day 3)

**Goal:** Implement SectionListRenderer following same pattern.

#### Step 3.1: Create Slot Components
- [ ] Create slot components in `renderers/SectionListRenderer.tsx`:
  - `SectionTitleSlot` - header with expand button
  - `SectionSummarySlot` - muted summary text
  - `SectionContentSlot` - content container

#### Step 3.2: Create Section Components
- [ ] Create `SectionWrapper` component
  - Expand/collapse state
  - Left border accent
  - Click handler for toggle
- [ ] Create `SectionListWrapper` component
  - Vertical spacing between sections

#### Step 3.3: Assemble Renderer
- [ ] Define `SectionListRenderer` constant
  - `Render`: SectionListWrapper
  - `Field`: nested Renderer with slotConfigs

### Phase 4: SchemaRenderer Integration (Day 4)

**Goal:** Modify SchemaRenderer to use new renderer pattern.

#### Step 4.1: Add Renderer Prop
- [ ] Add `renderer?: Renderer` prop to SchemaRenderer
- [ ] Update Props interface

#### Step 4.2: Add Slot Rendering
- [ ] Create `renderWithSlots` helper function
  - Iterate slotConfigs
  - Filter innerData by match function
  - Track used keys to prevent duplicates
  - Wrap in Slot components

#### Step 4.3: Integrate Container Detection
- [ ] Add container detection in render flow
  - Check `isContainer(schema.render_as)`
  - Get renderer via `getRenderer()`
  - Recurse with renderer prop

#### Step 4.4: Remove Old Container Logic
- [ ] Remove direct container routing
- [ ] Remove container-specific imports
- [ ] Keep display_format, selectable, strictMode logic

### Phase 5: Testing (Day 5)

**Goal:** Verify all workflow schemas render correctly.

#### Step 5.1: Unit Tests
- [ ] Test `extractInnerData` with various schemas
- [ ] Test slot matching logic
- [ ] Test nested renderer handling

#### Step 5.2: Integration Tests
- [ ] Test each workflow schema:
  - [ ] CC Step 1: pet_type_display_schema (array card-stack)
  - [ ] CC Step 3: cc_image_prompts_display_schema (section-list with card-stacks)
  - [ ] CC Step 4: cc_video_prompts_display_schema (similar pattern)
  - [ ] OMS Step 1: aesthetic_display_schema (section-list with card-stack)
  - [ ] OMS Step 2: midjourney_display_schema (object card-stack)

#### Step 5.3: Visual Regression
- [ ] Compare before/after screenshots for each schema
- [ ] Verify selection behavior works
- [ ] Verify highlight styling works
- [ ] Verify expand/collapse works

### Phase 6: Cleanup (Day 6)

**Goal:** Remove old code and finalize.

#### Step 6.1: Delete Old Files
- [ ] Delete `containers/CardStackRenderer.tsx`
- [ ] Delete `containers/SectionListRenderer.tsx`
- [ ] Delete `containers/shared/` if no longer needed
- [ ] Update `containers/index.ts` exports

#### Step 6.2: Update Imports
- [ ] Update any imports pointing to old containers
- [ ] Update ContainerRenderer if still used
- [ ] Remove unused imports from SchemaRenderer

#### Step 6.3: Documentation
- [ ] Add JSDoc comments to Renderer interface
- [ ] Add usage examples in types.ts
- [ ] Update any existing documentation

### Phase 7: Final Validation (Day 7)

**Goal:** Full regression testing and sign-off.

- [ ] Run full application
- [ ] Test all CC workflow steps
- [ ] Test all OMS workflow steps
- [ ] Test selection in all contexts
- [ ] Test empty states
- [ ] Test error handling
- [ ] Performance check (no render loops)

---

## Risk Mitigation

### Risk 1: Nested Container Switching
**Risk:** When a card-stack is inside a section-list, renderer switching might break.
**Mitigation:** The `isContainer` check happens at each SchemaRenderer call. When we hit a nested container, we switch renderers cleanly. Test this path explicitly.

### Risk 2: Selection Context
**Risk:** SelectableItem context might not propagate correctly through new structure.
**Mitigation:** Selection wrapping happens at the top of SchemaRenderer, before any renderer logic. Context should flow down naturally. Test selection in nested containers.

### Risk 3: Slot Ordering Edge Cases
**Risk:** First-match-wins might cause unexpected behavior if slots overlap.
**Mitigation:** Order slotConfigs from most specific to least specific. Always end with `match: () => true` fallback. Document this pattern.

### Risk 4: Breaking Existing Schemas
**Risk:** Some workflow schemas might depend on current behavior quirks.
**Mitigation:** Run all workflows during Phase 5. Document any behavioral differences. Adjust schemas if needed (prefer code fix over schema change).

---

## Success Criteria

1. **All existing workflow schemas render identically** (or better)
2. **Total codebase reduction of 70%+** for affected components
3. **No feature regressions** - selection, highlights, expand/collapse all work
4. **Clean separation** - renderer logic lives in renderer files only
5. **Easy to add new renderers** - follow the pattern, no SchemaRenderer changes needed
