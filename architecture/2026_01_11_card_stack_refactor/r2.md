# CardStackRenderer Refactoring Architecture - Revision 2

## Summary

This revision explores an alternative approach based on operator feedback: instead of refactoring containers to delegate more to SchemaRenderer, **invert the control** so SchemaRenderer never loses control in the first place. Containers become pure layout shells that can't add features because they never receive raw data.

---

## Operator Feedback on R1

> "I feel like we are working on same constraints as before, and still can lead to some issues we have now (for example feature creep). How can we update SchemaRenderer to render containers in different way? Right now we just do a render_as check and send whole context to router, where SchemaRenderer loses control over it completely."

The core insight: **the current architecture hands off control to containers, which enables feature creep.** Any refactoring that keeps this pattern will eventually face the same problem.

---

## The Core Problem: Control Handoff

### Current Architecture

```
SchemaRenderer
  │
  ├─ detects render_as: "card-stack"
  │
  └─ calls ContainerRenderer(type, data, schema, ...)
       │
       └─ calls CardStackRenderer(data, schema, ...)
            │
            └─ CardStackRenderer has FULL CONTROL
                 ├─ Re-implements traversal
                 ├─ Re-implements role handling
                 ├─ Re-implements display_order
                 ├─ Adds index badges
                 ├─ Adds smart grid layout
                 ├─ Adds selection logic
                 └─ ... anything it wants (feature creep)
```

**Once CardStackRenderer receives `data` and `schema`, nothing constrains what it can do.**

### Why This Leads to Feature Creep

| Version | What Got Added | Lines |
|---------|---------------|-------|
| v1 | Basic card rendering | ~200 |
| v2 | Object mode discovery | +100 |
| v3 | Selection handling | +60 |
| v4 | Smart grid layout | +50 |
| v5 | Highlight styling | +40 |
| v6 | Header fields for object mode | +100 |
| Current | All of the above | 732 |

Each feature made sense in isolation, but the architecture allowed unlimited growth.

---

## Alternative: Inversion of Control

### New Architecture

```
SchemaRenderer (ALWAYS in control)
  │
  ├─ detects render_as: "card-stack"
  │
  ├─ SchemaRenderer KEEPS iterating
  │
  ├─ SchemaRenderer categorizes fields by role
  │
  └─ uses CardStack.* compound components for LAYOUT ONLY
       │
       ├─ CardStack.Container  (div with gap-3)
       ├─ CardStack.Card       (border, selection styling)
       ├─ CardStack.Header     (padding, font-semibold)
       └─ CardStack.Body       (padding, border-top)
            │
            └─ CardStack components receive pre-rendered ReactNode
                 └─ They CAN'T add features - no access to raw data
```

### Key Principle: Containers Only Receive ReactNode

```tsx
// CardStack.Header receives children, NOT data
function Header({ children }: { children: ReactNode }) {
  return <div className="p-5 font-semibold">{children}</div>;
}
```

**The container can style the children, but it cannot:**
- Iterate over data differently
- Add new fields
- Change display order
- Implement custom logic

All of that stays in SchemaRenderer.

<!--
 i read through what you said, and i just checked SchemaRenderer, i just checked SchemaRenderer, it has become a bigger mess that i even have hoped of. :( it seems like it has become subject of feature creep as well, and this wasnt how i envisioned it at all. Schema renderer simply meant to render data recursive until it gets to leaf node. now there's so much conditions creeped into it, i dont want even want to try parse it. i see your proposal and i am still not 100% agree to it simply because it starts with <CardStack.Container> think of this situation, there are like 3 other containers already, we will have put this logic you added to each of them, which not much different from what we have now. that's why I proposed the way i did earlier. the idea would be, SchemaRenderder simply prvider to extract data AND schema based on type and route it correct place, nothing more, nothing less. right now SchemaRenderer has become amalgamation of many things. below is how i envisioned it, i know it doesnt have everything, but this is the simplicity I wanted. try think around this and how we can make this happen.

const SchemaRenderer = (data, schema, renderer, selectable, ....) => { 
    if (data == null || data == undefined) {
        return <></>
    }

    if (seletable) {
        <SelectableItem ...>
            <SchemaRenderer ... />
        </SelectableItem>
    }

    if (isContainer(schema.render_as)) {
        const container = getContainer(schema.render_as)
        return (
            <SchemaRenderer renderer={container} ... /> 
        )
    }
 
    const innerData = [];
    if (schema.type === "object") {
        if (typeof data !== "object") {
            return <ErrorRenderer ... />
        }

        obj.forEach((key, value) => {
            innerData.push({
                ...
            })
        })
        
    }

    if (schema.type === "array") {
        if (typeof data !== "array") {
            return <ErrorRenderer ... />
        }

        obj.forEach((key, value) => {
            innerData.push({
                ...
            })
        })
    }
    
    if (renderer) {
        return <renderer.Render schema={schema}> <-- no data
            {{
                innerData.forEach((id) => {
                    return <SchemaRenderer renderer={renderer.Field} ... />
                })
            }}
        </renderer.Render>
    }
  
    return <TerminalRenderer />
}
 -->
---

## Implementation: Compound Components

### What SchemaRenderer Does

```tsx
// Inside SchemaRenderer, when render_as === "card-stack"
if (schema.render_as === "card-stack" && Array.isArray(data)) {
  const itemSchema = schema.items || { type: "object" };

  return (
    <CardStack.Container>
      {data.map((item, idx) => {
        const itemPath = [...path, String(idx)];

        // SchemaRenderer categorizes fields - NOT the container
        const roles = categorizeByRole(item, itemSchema);

        return (
          <CardStack.Card
            key={idx}
            index={idx}
            path={itemPath}
            data={item}
            schema={itemSchema}
          >
            {/* Header slot - SchemaRenderer renders the content */}
            <CardStack.Header>
              {roles.titles.map(f => (
                <SchemaRenderer
                  key={f.key}
                  data={f.value}
                  schema={f.schema}
                  path={[...itemPath, f.key]}
                />
              ))}
              {roles.subtitles.map(f => (
                <SchemaRenderer
                  key={f.key}
                  data={f.value}
                  schema={{ ...f.schema, render_as: undefined }}
                  path={[...itemPath, f.key]}
                />
              ))}
            </CardStack.Header>

            {/* Body slot - SchemaRenderer renders the content */}
            <CardStack.Body>
              {roles.body.map(f => (
                <SchemaRenderer
                  key={f.key}
                  data={f.value}
                  schema={f.schema}
                  path={[...itemPath, f.key]}
                  strictMode={true}
                />
              ))}
            </CardStack.Body>
          </CardStack.Card>
        );
      })}
    </CardStack.Container>
  );
}
```

### What CardStack Components Provide

```tsx
// card-stack/CardStack.tsx - THE ENTIRE CONTAINER (~100 lines)

import { createContext, useContext, type ReactNode } from "react";
import { cn } from "@/lib/utils";
import { Check } from "lucide-react";
import { useItemSelection } from "../shared/useItemSelection";

// Context for selection state (used by Header for indicator positioning)
const CardContext = createContext<{
  index: number;
  isSelectable: boolean;
  isSelected: boolean;
  selectionMode: string | undefined;
} | null>(null);

// ============================================================
// Container - just a flex column with gap
// ============================================================
export function Container({ children }: { children: ReactNode }) {
  return <div className="flex flex-col gap-3">{children}</div>;
}

// ============================================================
// Card - border, selection, click handling
// ============================================================
interface CardProps {
  children: ReactNode;
  index: number;
  path: string[];
  data: unknown;
  schema: { selectable?: boolean };
}

export function Card({ children, index, path, data, schema }: CardProps) {
  const {
    isSelectable,
    isSelected,
    isReadonly,
    disabled,
    selectionMode,
    handleClick,
  } = useItemSelection(schema, path, data);

  return (
    <CardContext.Provider value={{ index, isSelectable, isSelected, selectionMode }}>
      <div
        className={cn(
          "relative rounded-lg border-2 bg-card/80 transition-all",
          isSelectable && !isReadonly && "cursor-pointer",
          isSelected ? "border-primary bg-primary/5" : "border-border hover:border-muted-foreground/50",
          disabled && "opacity-50 cursor-not-allowed"
        )}
        onClick={handleClick}
      >
        {children}
      </div>
    </CardContext.Provider>
  );
}

// ============================================================
// Header - padding, index badge, selection indicator
// ============================================================
export function Header({ children }: { children: ReactNode }) {
  const ctx = useContext(CardContext);
  if (!ctx) throw new Error("CardStack.Header must be inside CardStack.Card");

  return (
    <div className={cn("p-5", ctx.isSelectable && "pr-14")}>
      {/* Selection indicator */}
      {ctx.isSelectable && ctx.selectionMode === "select" && (
        <div className="absolute top-4 right-4">
          <div
            className={cn(
              "w-6 h-6 rounded-full border-2 flex items-center justify-center",
              ctx.isSelected ? "border-primary bg-primary" : "border-muted-foreground/30"
            )}
          >
            {ctx.isSelected && <Check className="h-4 w-4 text-primary-foreground" />}
          </div>
        </div>
      )}

      <div className="flex items-start gap-3">
        {/* Index badge */}
        <div className="shrink-0 w-7 h-7 rounded-md bg-muted flex items-center justify-center">
          <span className="text-sm font-semibold text-muted-foreground">{ctx.index + 1}</span>
        </div>

        {/* Content slot */}
        <div className="flex-1 min-w-0">{children}</div>
      </div>
    </div>
  );
}

// ============================================================
// Body - border-top, padding
// ============================================================
export function Body({ children }: { children: ReactNode }) {
  return (
    <div className="px-5 pb-5 pt-0">
      <div className="border-t border-border pt-4">{children}</div>
    </div>
  );
}

// ============================================================
// Export as compound component
// ============================================================
export const CardStack = { Container, Card, Header, Body };
```

### What Shared Utilities Provide

```tsx
// shared/categorizeByRole.ts
export interface CategorizedFields {
  titles: FieldInfo[];
  subtitles: FieldInfo[];
  highlights: FieldInfo[];
  body: FieldInfo[];
}

export function categorizeByRole(
  data: Record<string, unknown>,
  schema: SchemaProperty
): CategorizedFields {
  const result: CategorizedFields = {
    titles: [],
    subtitles: [],
    highlights: [],
    body: [],
  };

  const properties = schema.properties || {};

  for (const [key, propSchema] of Object.entries(properties)) {
    const value = data[key];
    const field = { key, value, schema: propSchema };

    switch (propSchema.render_as) {
      case "card-title":
        result.titles.push(field);
        break;
      case "card-subtitle":
        result.subtitles.push(field);
        break;
      default:
        if (propSchema.display === true) {
          if (propSchema.highlight) {
            result.highlights.push(field);
          } else {
            result.body.push(field);
          }
        }
    }
  }

  // Sort by display_order
  const sortByOrder = (a: FieldInfo, b: FieldInfo) =>
    (a.schema.display_order ?? 999) - (b.schema.display_order ?? 999);

  result.titles.sort(sortByOrder);
  result.subtitles.sort(sortByOrder);
  result.highlights.sort(sortByOrder);
  result.body.sort(sortByOrder);

  return result;
}
```

---

## Comparison: R1 vs R2 Approach

| Aspect | R1 (Delegate More) | R2 (Inversion of Control) |
|--------|-------------------|--------------------------|
| Who iterates data? | Container (but delegates body) | SchemaRenderer |
| Who handles roles? | Container extracts, delegates rendering | SchemaRenderer categorizes and renders |
| Container receives | `data`, `schema` (full access) | `ReactNode` children (no data access) |
| Can container add features? | Yes (still has data) | No (only has pre-rendered nodes) |
| Container complexity | ~250 lines total | ~100 lines total |
| SchemaRenderer changes | Minimal | Adds container-specific rendering |
| Feature creep risk | Reduced but possible | Eliminated by design |

---

## Trade-offs

### Advantages of R2

1. **Feature creep impossible** - Containers can't add logic without data
2. **Single source of truth** - SchemaRenderer handles ALL rendering decisions
3. **Simpler containers** - Just styled wrappers (~100 lines vs 732)
4. **Consistent behavior** - display_order, strictMode, etc. always respected
5. **Easier testing** - Containers are pure visual components

### Disadvantages of R2

1. **SchemaRenderer grows** - Adds ~100-150 lines for container handling
2. **More code in one place** - SchemaRenderer becomes the "god" component
3. **Container-specific logic in SchemaRenderer** - Role categorization per container type
4. **Refactoring effort** - Need to change how containers are called

### Is SchemaRenderer Growth Acceptable?

SchemaRenderer is already the "smart" component (404 lines). Adding ~150 lines for proper container handling is acceptable because:

- It's the RIGHT place for rendering logic
- It prevents 600+ lines of duplicated logic in containers
- It enables consistent behavior across all containers
- It's easier to test one smart component than many

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx           # +150 lines for container handling
├── shared/
│   ├── useItemSelection.ts      # Shared selection hook
│   ├── categorizeByRole.ts      # Role categorization utility
│   └── types.ts                 # FieldInfo, CategorizedFields
├── layouts/                     # NEW: Pure layout components
│   ├── CardStack.tsx            # ~100 lines
│   ├── SectionList.tsx          # ~120 lines
│   └── Table.tsx                # (existing, may not need changes)
├── SelectableItem.tsx           # Uses shared useItemSelection
├── ArrayContainer.tsx           # (may become obsolete)
├── ObjectContainer.tsx          # (may become obsolete)
└── renderers/
    └── containers/              # DELETE after migration
        ├── CardStackRenderer.tsx
        ├── SectionListRenderer.tsx
        └── ...
```

---

## Migration Strategy

### Phase 1: Create Shared Utilities
1. Create `shared/useItemSelection.ts`
2. Create `shared/categorizeByRole.ts`
3. Create `shared/types.ts`
4. **Test:** Unit tests for utilities

### Phase 2: Create Layout Components
1. Create `layouts/CardStack.tsx` (compound components)
2. Create `layouts/SectionList.tsx`
3. **Test:** Visual storybook tests for layouts

### Phase 3: Update SchemaRenderer
1. Add container-specific rendering paths
2. Use categorizeByRole for field extraction
3. Use CardStack/SectionList compound components
4. **Test:** All 5 workflow patterns still work

### Phase 4: Remove Old Containers
1. Delete `containers/CardStackRenderer.tsx`
2. Delete `containers/SectionListRenderer.tsx`
3. Update `ContainerRenderer.tsx` to route to SchemaRenderer (or remove)
4. **Test:** Regression testing

---

## Open Questions

1. **Object mode handling:** How should SchemaRenderer handle object mode discovery (`render_as: "card-content"`)? Should this also move to SchemaRenderer?

2. **Nested containers:** When section-list contains card-stack, SchemaRenderer will handle both. Is the nesting handled correctly?

3. **Highlight styling:** Currently CardStackRenderer applies highlight colors. Should this be:
   - (A) In the layout component (Header receives highlight config)
   - (B) In SchemaRenderer (passes className to rendered field)
   - (C) In TerminalRenderer (reads highlight from schema)

4. **Smart grid layout:** R1 asked about this too. In R2, where should short/long field categorization live?
   - (A) Drop it - SchemaRenderer renders fields vertically
   - (B) Add it to SchemaRenderer's container handling
   - (C) Create a separate layout component for field grids

5. **Breaking change or gradual?** Should we:
   - (A) Big bang - replace all at once
   - (B) Gradual - support both old and new patterns during migration

---

## Appendix: Full Example Flow

### Schema
```json
{
  "type": "array",
  "render_as": "card-stack",
  "items": {
    "selectable": true,
    "properties": {
      "name": { "render_as": "card-title", "display": true },
      "desc": { "render_as": "card-subtitle", "display": true },
      "details": { "display": true, "display_label": "Details" }
    }
  }
}
```

### Data
```json
[
  { "name": "Card 1", "desc": "Description 1", "details": "Some details" },
  { "name": "Card 2", "desc": "Description 2", "details": "More details" }
]
```

### What SchemaRenderer Does

1. Detects `render_as: "card-stack"` and `Array.isArray(data)`
2. For each item, calls `categorizeByRole(item, itemSchema)`:
   - `titles: [{ key: "name", value: "Card 1", schema: {...} }]`
   - `subtitles: [{ key: "desc", value: "Description 1", schema: {...} }]`
   - `body: [{ key: "details", value: "Some details", schema: {...} }]`
3. Renders compound components with SchemaRenderer for each field

### Rendered Output

```tsx
<CardStack.Container>
  <CardStack.Card index={0} path={["0"]} data={item0} schema={itemSchema}>
    <CardStack.Header>
      {/* SchemaRenderer rendered these */}
      <span className="font-semibold">Card 1</span>
      <span className="text-muted-foreground">Description 1</span>
    </CardStack.Header>
    <CardStack.Body>
      {/* SchemaRenderer rendered this */}
      <div>
        <span className="font-medium">Details:</span> Some details
      </div>
    </CardStack.Body>
  </CardStack.Card>
  {/* Card 2 similar */}
</CardStack.Container>
```

### What CardStack Components See

- `CardStack.Container`: Just `children` (two Card elements)
- `CardStack.Card`: `children`, `index`, `path`, `data`, `schema` (for selection only)
- `CardStack.Header`: Just `children` (pre-rendered name and desc)
- `CardStack.Body`: Just `children` (pre-rendered details)

**The layout components never iterate data, never extract fields, never make rendering decisions.**
