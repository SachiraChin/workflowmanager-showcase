# CardStackRenderer Refactoring Architecture - Revision 3

## Summary

This revision refines the approach based on operator feedback: SchemaRenderer itself has become bloated with feature creep. The goal is to make SchemaRenderer a **simple recursive data extractor** that knows nothing about specific containers. Renderers receive only `schema` (for styling hints) and `children` (pre-rendered), never raw data.

---

## Operator Feedback on R2

> "SchemaRenderer has become a bigger mess than I even hoped. It seems like it has become subject of feature creep as well. My proposal would be: SchemaRenderer simply provides to extract data AND schema based on type and route it to correct place, nothing more, nothing less."

Key insight: **Both containers AND SchemaRenderer have suffered feature creep.** The solution must simplify both.

---

## The Vision: SchemaRenderer as Pure Data Extractor

### Operator's Pseudocode (Annotated)

```tsx
const SchemaRenderer = (data, schema, renderer, selectable, ....) => {
    // 1. Handle null/undefined
    if (data == null || data == undefined) {
        return <></>
    }

    // 2. Handle selectable - wrap and recurse
    if (selectable) {
        return (
            <SelectableItem ...>
                <SchemaRenderer ... />
            </SelectableItem>
        )
    }

    // 3. Handle containers - get renderer and continue
    if (isContainer(schema.render_as)) {
        const container = getContainer(schema.render_as)
        return <SchemaRenderer renderer={container} ... />
    }

    // 4. Extract inner data based on type
    const innerData = [];

    if (schema.type === "object") {
        if (typeof data !== "object") {
            return <ErrorRenderer ... />
        }
        Object.entries(data).forEach(([key, value]) => {
            innerData.push({ key, value, schema: schema.properties[key] })
        })
    }

    if (schema.type === "array") {
        if (!Array.isArray(data)) {
            return <ErrorRenderer ... />
        }
        data.forEach((item, idx) => {
            innerData.push({ key: idx, value: item, schema: schema.items })
        })
    }

    // 5. If renderer provided, use it - renderer gets NO DATA
    if (renderer) {
        return (
            <renderer.Render schema={schema}>  {/* <-- schema only, no data */}
                {innerData.map((item) => (
                    <SchemaRenderer
                        key={item.key}
                        data={item.value}
                        schema={item.schema}
                        renderer={renderer.Field}
                        ...
                    />
                ))}
            </renderer.Render>
        )
    }

    // 6. Leaf node - terminal rendering
    return <TerminalRenderer schema={schema} value={data} />
}
```

### Key Principles

1. **SchemaRenderer extracts, doesn't render** - It extracts `innerData` from objects/arrays
2. **Renderer is passed DOWN** - Not hard-coded per container type
3. **Renderer receives NO data** - Only `schema` and `children`
4. **Renderer has two parts**: `Render` (wrapper) and `Field` (per-item)
5. **Recursive composition** - `renderer.Field` can itself have `Render` and `Field`

---

## Renderer Interface

### Base Interface

```tsx
interface Renderer {
  /** Wrapper component - receives schema (for styling) and children (pre-rendered) */
  Render: React.FC<{ schema: SchemaProperty; children: ReactNode }>;

  /** Per-item component - receives schema and children */
  Field: React.FC<{ schema: SchemaProperty; children: ReactNode }> | Renderer;
}
```

### Default Renderer (No Styling)

```tsx
const DefaultRenderer: Renderer = {
  Render: ({ children }) => <div className="space-y-1">{children}</div>,
  Field: ({ children }) => <>{children}</>,
};
```

### CardStack Renderer

```tsx
const CardStackRenderer: Renderer = {
  // Container for the stack
  Render: ({ schema, children }) => (
    <div className="flex flex-col gap-3">{children}</div>
  ),

  // Each array item becomes a Card
  // Field is itself a Renderer for the object inside the card
  Field: {
    Render: ({ schema, children }) => (
      <CardWrapper schema={schema}>
        {children}
      </CardWrapper>
    ),

    // Each property inside the card
    Field: ({ schema, children }) => (
      <CardField role={schema.render_as}>
        {children}
      </CardField>
    ),
  },
};
```

---

## How Role Types Work: The Challenge

CardStack needs to position fields differently based on role:
- `card-title` → in header section
- `card-subtitle` → below title
- body fields → in body section

But the renderer only receives `children` (pre-rendered), not raw data. How do we achieve positioning without the renderer inspecting data?

---

## Option A: Renderer Inspects Children Props (Fragile)

The `Render` component inspects React children to read their schema prop:

```tsx
function CardWrapper({ schema, children }) {
  const childArray = React.Children.toArray(children);
  const headers = childArray.filter(c => c.props.schema?.render_as === "card-title");
  const body = childArray.filter(c => c.props.schema?.render_as !== "card-title");

  return (
    <div className="card">
      <div className="header">{headers}</div>
      <div className="body">{body}</div>
    </div>
  );
}
```

**Problems:**
- Relies on children having `schema` prop - not guaranteed
- Implicit contract between SchemaRenderer and Renderer
- Fragile if child structure changes
- Type safety is poor

**Verdict:** ❌ Not recommended

---

## Option B: Renderer Declares Slots, SchemaRenderer Fills Them

Renderer declares what slots it needs. SchemaRenderer groups fields and passes as named props:

```tsx
// Renderer declares its slot configuration
const CardStackRenderer = {
  slots: {
    header: ["card-title", "card-subtitle"],  // Role types for header
    body: ["*"],  // Everything else
  },

  Render: ({ schema, slots }) => (
    <div className="card">
      <div className="header">{slots.header}</div>
      <div className="body">{slots.body}</div>
    </div>
  ),

  Field: ({ schema, children }) => (
    <div className={getStyleForRole(schema.render_as)}>{children}</div>
  ),
};

// SchemaRenderer reads slot config and groups accordingly
if (renderer) {
  const grouped = groupBySlots(innerData, renderer.slots);

  return (
    <renderer.Render
      schema={schema}
      slots={{
        header: grouped.header.map(item => (
          <SchemaRenderer key={item.key} data={item.value} schema={item.schema} renderer={renderer.Field} />
        )),
        body: grouped.body.map(item => (
          <SchemaRenderer key={item.key} data={item.value} schema={item.schema} renderer={renderer.Field} />
        )),
      }}
    />
  );
}
```

**Pros:**
- Explicit contract - renderer declares what it needs
- Type-safe - slots are typed
- SchemaRenderer does grouping (it has the data)
- Renderer just receives pre-grouped arrays

**Cons:**
- SchemaRenderer needs generic slot-grouping logic
- Every renderer must declare slots

**Verdict:** ✅ Recommended - explicit and deterministic

---

## Option C: Schema Defines Layout Structure

The schema itself defines how fields are grouped:

```json
{
  "render_as": "card-stack",
  "items": {
    "type": "object",
    "layout": {
      "header": ["title", "subtitle"],
      "body": ["*"]
    },
    "properties": {
      "title": { "render_as": "card-title", ... },
      "subtitle": { "render_as": "card-subtitle", ... },
      "description": { ... }
    }
  }
}
```

SchemaRenderer reads `layout` and groups:

```tsx
if (schema.layout) {
  const grouped = groupByLayout(innerData, schema.layout);
  return (
    <renderer.Render schema={schema} slots={grouped} />
  );
}
```

**Pros:**
- Schema is the single source of truth
- No renderer configuration needed
- Workflow authors control layout

**Cons:**
- Requires schema changes
- More verbose schemas
- Layout tied to specific property names

**Verdict:** ⚠️ Possible but adds schema complexity

---

## Option D: Wrapper Components with Explicit Slots

SchemaRenderer wraps each group in a slot component. Renderer.Render uses React context or composition:

```tsx
// SchemaRenderer groups and wraps in Slot components
if (renderer) {
  const grouped = groupByRole(innerData, roleConfig);

  return (
    <renderer.Render schema={schema}>
      <Slot name="header">
        {grouped.header.map(item => (
          <SchemaRenderer key={item.key} ... renderer={renderer.Field} />
        ))}
      </Slot>
      <Slot name="body">
        {grouped.body.map(item => (
          <SchemaRenderer key={item.key} ... renderer={renderer.Field} />
        ))}
      </Slot>
    </renderer.Render>
  );
}

// Renderer.Render collects slots via context
function CardWrapper({ schema, children }) {
  const slots = useSlots(children);  // Extracts Slot components by name

  return (
    <div className="card">
      <div className="header">{slots.header}</div>
      <div className="body">{slots.body}</div>
    </div>
  );
}
```

**Pros:**
- Explicit slot boundaries
- Renderer doesn't inspect child props
- Type-safe slot collection

**Cons:**
- Extra Slot wrapper components
- Context overhead
- More complex than Option B

**Verdict:** ⚠️ Works but more complex than necessary

---

## Option E: CSS-Based Positioning (No Grouping)

Don't group at all. Render all fields flat, use CSS Grid with named areas:

```tsx
// SchemaRenderer renders all fields flat with data-role attribute
<renderer.Render schema={schema}>
  {innerData.map(item => (
    <renderer.Field
      key={item.key}
      schema={item.schema}
      data-role={item.schema.render_as || "body"}  // HTML attribute
    >
      <SchemaRenderer ... />
    </renderer.Field>
  ))}
</renderer.Render>

// Renderer uses CSS Grid
function CardWrapper({ children }) {
  return (
    <div className="card-grid">
      {children}
    </div>
  );
}

// CSS
.card-grid {
  display: grid;
  grid-template-areas:
    "header"
    "body";
}
.card-grid > [data-role="card-title"],
.card-grid > [data-role="card-subtitle"] {
  grid-area: header;
}
.card-grid > :not([data-role="card-title"]):not([data-role="card-subtitle"]) {
  grid-area: body;
}
```

**Pros:**
- No grouping logic needed
- Renderer receives flat children
- Pure CSS positioning

**Cons:**
- CSS Grid limitations (can't have multiple items in same area easily)
- data-role is implicit contract
- Header items would stack, need additional CSS

**Verdict:** ❌ Doesn't work well for multiple items per section

---

## Option F: Pre-Categorized Content Object

Instead of `children`, renderer receives a structured object with pre-rendered content:

```tsx
// SchemaRenderer groups and renders each group
if (renderer) {
  const grouped = groupByRole(innerData, renderer.roleConfig);

  const content = {
    header: grouped.header.map(item => (
      <SchemaRenderer key={item.key} data={item.value} schema={item.schema} renderer={renderer.Field} />
    )),
    body: grouped.body.map(item => (
      <SchemaRenderer key={item.key} data={item.value} schema={item.schema} renderer={renderer.Field} />
    )),
  };

  return <renderer.Render schema={schema} content={content} />;
}

// Renderer receives structured content, not children
function CardWrapper({ schema, content }) {
  return (
    <div className="card">
      {content.header.length > 0 && (
        <div className="header">{content.header}</div>
      )}
      {content.body.length > 0 && (
        <div className="body">{content.body}</div>
      )}
    </div>
  );
}
```

**Pros:**
- Explicit structure - `content.header`, `content.body`
- No children inspection needed
- Type-safe content shape
- Renderer receives exactly what it needs

**Cons:**
- Different API than standard React children
- Renderer must define roleConfig
- SchemaRenderer needs grouping logic

**Verdict:** ✅ Recommended - most explicit and type-safe

---

## Option G: Renderer Provides Grouping Function

Renderer provides its own grouping function. SchemaRenderer calls it:

```tsx
const CardStackRenderer = {
  // Renderer defines how to group
  group: (items) => ({
    header: items.filter(i => ["card-title", "card-subtitle"].includes(i.schema.render_as)),
    body: items.filter(i => !["card-title", "card-subtitle"].includes(i.schema.render_as)),
  }),

  Render: ({ schema, content }) => (
    <div className="card">
      <div className="header">{content.header}</div>
      <div className="body">{content.body}</div>
    </div>
  ),

  Field: ({ schema, children }) => <div>{children}</div>,
};

// SchemaRenderer uses renderer's group function
if (renderer.group) {
  const grouped = renderer.group(innerData);
  const content = mapGroupedToReactNodes(grouped, renderer.Field);
  return <renderer.Render schema={schema} content={content} />;
}
```

**Pros:**
- Renderer has full control over grouping logic
- SchemaRenderer stays generic
- Complex grouping possible per renderer

**Cons:**
- Group function sees innerData (has schema, not raw data - acceptable?)
- Every renderer must implement group function

**Verdict:** ✅ Flexible but slightly more complex

---

## Comparison Matrix

| Option | Renderer sees data? | Explicit contract? | Type-safe? | Complexity |
|--------|--------------------|--------------------|------------|------------|
| A: Inspect children | No (but fragile) | ❌ Implicit | ❌ Poor | Low |
| B: Declared slots | No | ✅ Explicit | ✅ Yes | Medium |
| C: Schema layout | No | ✅ Explicit | ✅ Yes | Medium (schema changes) |
| D: Slot components | No | ✅ Explicit | ✅ Yes | High |
| E: CSS positioning | No | ❌ Implicit | ❌ Poor | Low (but limited) |
| F: Content object | No | ✅ Explicit | ✅ Yes | Medium |
| G: Grouping function | No (schema only) | ✅ Explicit | ✅ Yes | Medium |

---

## Recommended: Option B or F

### Option B (Slots) - If we want standard children pattern
```tsx
interface Renderer {
  slots: Record<string, string[]>;  // slot name → role types
  Render: FC<{ schema; slots: Record<string, ReactNode[]> }>;
  Field: FC<{ schema; children }>;
}
```

### Option F (Content object) - If we want maximum explicitness
```tsx
interface Renderer {
  roleConfig: Record<string, string[]>;  // group name → role types
  Render: FC<{ schema; content: Record<string, ReactNode[]> }>;
  Field: FC<{ schema; children }>;
}
```

Both keep grouping logic in SchemaRenderer (which has access to innerData schemas) and pass pre-grouped, pre-rendered content to the renderer.

<!--
whats complexity of doing something like this, feels like best of both worlds, not sure how complex it will make implementation wise, and maintainability wise

// SchemaRenderer reads slot config and groups accordingly
if (renderer) {
  const grouped = groupBySlots(innerData, renderer.slots);

  return (
    <renderer.Render
      schema={schema}
    >
        {{
            rendrer.slotConfigs.forEach((slotConfig) => {
                const filtered = innerData.filter(d => slotConfig.match(d.schema));

                if (!filtered) return <></>

                return 
                <slotConfig.Slot>
                    innerData.forEach((id) => {
                        return <SchemaRenderer renderer={renderer.Field} ... />
                    })
                <slotConfig.Slot>
            })
        }}
    </renderer.Render>
  );
}
-->

---

## Complete Renderer Structure

### For CardStack (Array of Objects)

```
SchemaRenderer (data: [...], schema: { render_as: "card-stack", items: {...} })
│
├─ Detects container → gets CardStackRenderer
│
└─ Returns:
    <CardStackRenderer.Render schema={schema}>
      {data.map((item, idx) => (
        <SchemaRenderer
          data={item}
          schema={schema.items}
          renderer={CardStackRenderer.Field}  // This is itself a Renderer
        />
      ))}
    </CardStackRenderer.Render>

    │
    └─ CardStackRenderer.Render = <div className="flex flex-col gap-3">...</div>

    │
    └─ Each child recursively:
        <SchemaRenderer data={item} schema={itemSchema} renderer={CardStackRenderer.Field}>
        │
        └─ Returns:
            <CardStackRenderer.Field.Render schema={itemSchema}>  // CardWrapper
              {Object.entries(item).map(([key, value]) => (
                <SchemaRenderer
                  data={value}
                  schema={itemSchema.properties[key]}
                  renderer={CardStackRenderer.Field.Field}  // CardField
                />
              ))}
            </CardStackRenderer.Field.Render>

            │
            └─ CardWrapper inspects children, groups by role, returns:
                <div className="card">
                  <div className="header">{titles, subtitles}</div>
                  <div className="body">{other fields}</div>
                </div>
```

### Renderer Definition

```tsx
const CardStackRenderer: Renderer = {
  // Level 1: The stack container
  Render: ({ children }) => (
    <div className="flex flex-col gap-3">{children}</div>
  ),

  // Level 2: Each card (is itself a Renderer for the object)
  Field: {
    Render: CardWrapper,  // Groups children by role
    Field: CardField,     // Styles each field by role
  },
};
```

---

## Handling Nested Containers

### Example: SectionList containing CardStack

Schema:
```json
{
  "render_as": "section-list",
  "items": {
    "properties": {
      "title": { "render_as": "section-title" },
      "ideas": {
        "render_as": "card-stack",
        "items": { ... }
      }
    }
  }
}
```

Flow:
1. SchemaRenderer detects `section-list` → uses SectionListRenderer
2. For each section item, recurses with `renderer={SectionListRenderer.Field}`
3. Inside section, encounters `ideas` with `render_as: "card-stack"`
4. Detects container → switches to CardStackRenderer
5. Continues recursively

**Key:** When SchemaRenderer detects a container inside a renderer, it switches renderers. This is the `isContainer` check.

---

## Selection Handling

### Current Problem

CardStackRenderer manually implements selection. We want to keep it in SchemaRenderer.

### Solution: Selectable Check at Top

```tsx
const SchemaRenderer = ({ data, schema, renderer, ... }) => {
  // Handle selectable FIRST
  if (schema.selectable) {
    return (
      <SelectableItem path={path} data={data} schema={schema}>
        <SchemaRenderer
          data={data}
          schema={{ ...schema, selectable: undefined }}  // Prevent infinite loop
          renderer={renderer}
          ...
        />
      </SelectableItem>
    );
  }

  // ... rest of logic
}
```

SelectableItem provides:
- Selection state (via context)
- Click handling
- Visual indicator

The renderer doesn't need to know about selection - it's handled by the wrapper.

---

## Index Badge Problem

### Challenge

CardStack shows index badges ("1", "2", "3"). But SchemaRenderer doesn't know about indices when iterating.

### Solution: Pass Index Through

```tsx
// When iterating array
if (schema.type === "array") {
  return (
    <renderer.Render schema={schema}>
      {data.map((item, idx) => (
        <SchemaRenderer
          key={idx}
          data={item}
          schema={schema.items}
          renderer={renderer.Field}
          index={idx}  // Pass index
          ...
        />
      ))}
    </renderer.Render>
  );
}

// Renderer.Field.Render (CardWrapper) receives index
function CardWrapper({ schema, children, index }: Props) {
  return (
    <div className="card">
      <div className="flex items-start gap-3">
        <IndexBadge index={index} />
        <div>{children}</div>
      </div>
    </div>
  );
}
```

---

## Simplified SchemaRenderer

### What Gets Removed

| Current Feature | Status |
|-----------------|--------|
| Container-specific handling (card-stack, section-list) | REMOVED - use renderer pattern |
| Role type awareness | REMOVED - renderer handles positioning |
| display_order sorting | KEEP - generic data extraction |
| display_format handling | KEEP - generic template rendering |
| strictMode | KEEP - generic traversal control |
| Computed fields | KEEP - generic data extraction |

### Simplified Code Structure

```tsx
function SchemaRenderer({ data, schema, renderer, path, strictMode, index }: Props) {
  // 1. Handle null/undefined
  if (data == null || data == undefined) {
    return null;
  }

  // 2. Handle selectable
  if (schema.selectable) {
    return (
      <SelectableItem path={path} data={data} schema={schema}>
        <SchemaRenderer {...props} schema={{ ...schema, selectable: undefined }} />
      </SelectableItem>
    );
  }

  // 3. Handle display_format (template collapsing)
  if (schema.display_format) {
    const formatted = renderTemplate(schema.display_format, data, state);
    return <TerminalRenderer value={formatted} schema={schema} />;
  }

  // 4. Handle container - switch renderer
  if (isContainer(schema.render_as)) {
    const containerRenderer = getRenderer(schema.render_as);
    return <SchemaRenderer {...props} renderer={containerRenderer} />;
  }

  // 5. Extract inner data
  const innerData = extractInnerData(data, schema, strictMode);

  // 6. Render with renderer or terminal
  if (renderer && innerData.length > 0) {
    const Render = renderer.Render;
    const fieldRenderer = renderer.Field;

    return (
      <Render schema={schema} index={index}>
        {innerData.map((item, idx) => (
          <SchemaRenderer
            key={item.key}
            data={item.value}
            schema={item.schema}
            renderer={typeof fieldRenderer === 'function' ? undefined : fieldRenderer}
            path={[...path, String(item.key)]}
            strictMode={item.strictMode}
            index={idx}
          />
        ))}
      </Render>
    );
  }

  // 7. Terminal rendering
  return <TerminalRenderer value={data} schema={schema} />;
}
```

### Helper: extractInnerData

```tsx
function extractInnerData(
  data: unknown,
  schema: SchemaProperty,
  strictMode: boolean
): InnerDataItem[] {
  const result: InnerDataItem[] = [];

  if (schema.type === "object" && typeof data === "object" && data !== null) {
    const dataObj = data as Record<string, unknown>;
    const properties = schema.properties || {};

    // Sort by display_order
    const sortedKeys = Object.keys(properties).sort((a, b) => {
      const orderA = properties[a].display_order ?? 999;
      const orderB = properties[b].display_order ?? 999;
      return orderA - orderB;
    });

    for (const key of sortedKeys) {
      const propSchema = properties[key];

      // Apply strictMode/display filtering
      if (strictMode && propSchema.display !== true) continue;
      if (!strictMode && !hasDisplayableDescendant(propSchema)) continue;

      result.push({
        key,
        value: dataObj[key],
        schema: propSchema,
        strictMode: strictMode || propSchema.display === true,
      });
    }
  }

  if (schema.type === "array" && Array.isArray(data)) {
    const itemSchema = schema.items || { type: "object" };

    data.forEach((item, idx) => {
      result.push({
        key: idx,
        value: item,
        schema: itemSchema,
        strictMode,
      });
    });
  }

  return result;
}
```

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx          # Simplified (~150 lines)
├── SelectableItem.tsx          # Unchanged
├── TerminalRenderer.tsx        # Unchanged
├── helpers/
│   ├── extractInnerData.ts     # Data extraction logic
│   ├── hasDisplayableDescendant.ts
│   └── renderTemplate.ts
├── renderers/
│   ├── types.ts                # Renderer interface
│   ├── DefaultRenderer.tsx     # Basic wrapper
│   ├── CardStackRenderer.tsx   # ~80 lines
│   ├── SectionListRenderer.tsx # ~100 lines
│   └── TableRenderer.tsx       # ~60 lines
└── (DELETE old containers/)
```

---

## Migration Plan

### Phase 1: Define Renderer Interface
1. Create `renderers/types.ts` with Renderer interface
2. Create `DefaultRenderer` as fallback
3. **Test:** Interface compiles correctly

### Phase 2: Implement CardStack as Renderer
1. Create new `CardStackRenderer` following Renderer interface
2. Create `CardWrapper` with role-based grouping
3. Create `CardField` with role-based styling
4. **Test:** Renders correctly in isolation

### Phase 3: Simplify SchemaRenderer
1. Add `renderer` prop
2. Add `extractInnerData` helper
3. Remove container-specific handling
4. Add container detection → renderer switching
5. **Test:** All existing schemas still render

### Phase 4: Implement Other Renderers
1. Create `SectionListRenderer`
2. Create `TableRenderer` (if needed)
3. **Test:** All workflow schemas render correctly

### Phase 5: Cleanup
1. Delete old `containers/` folder
2. Delete unused code from SchemaRenderer
3. **Test:** Full regression testing

---

## Open Questions

1. **Highlight styling:** How should `highlight: true` fields be styled? Options:
   - (A) CardField reads `schema.highlight` and applies color
   - (B) Separate `HighlightWrapper` component
   - (C) CSS class on parent
<!--not sure what's the issue here is, cant renderer handle this? -->

2. **Object mode discovery:** CardStack object mode scans for `render_as: "card-content"`. Should this:
   - (A) Be handled in extractInnerData
   - (B) Be a separate renderer for object-mode card-stacks
   - (C) Be deprecated in favor of array mode
<!--we need this function, but SchemaRenderer is going to convert objects into arrays anyways right?-->

3. **Empty states:** Who renders "No items" when array is empty?
   - (A) SchemaRenderer checks and renders
   - (B) Renderer.Render receives empty children and handles it
<!--i'm not decided on this. i dont want to implement any direct rendering inside schema renderer. as everything go pass down to terminals, even broken objects, arrays, anyhing unhandled, we can do that check there.-->

4. **Error boundaries:** Should each renderer have error handling, or centralize in SchemaRenderer?
<!--I havent think about it, at the moment Primitives can throw out error messages, but not sure how we handle that given that we use renderers-->

5. **Performance:** React.Children.toArray for role grouping - is this efficient enough for large lists?
<!--I'm not following here, i havent used React.children.toArray before, can you add more context to this?-->
