# Virtual Module Execution - Revision 2

## Summary

Enable running workflow modules in a "virtual context" without a real workflow
run. The server uses mongomock to provide a fully functional in-memory database
that behaves identically to real MongoDB. This allows exact parity with real
workflow execution while remaining completely stateless - the client maintains
and sends back the virtual database state between requests.

## Design Principles

1. **Exact parity with real execution** - Virtual mode uses the same code paths
   as real workflow execution. No module modifications needed.

2. **Mongomock as virtual database** - Instead of mocking individual components,
   we use mongomock to provide a complete in-memory MongoDB that supports all
   operations (events, state, queries, etc.).

3. **Client maintains state** - Server returns the full virtual DB state after
   each request. Client sends it back for subsequent requests. Server is
   completely stateless.

4. **Full Jinja2 support** - All `{{ state.* }}` expressions are resolved
   normally using the virtual database state.

5. **All modules supported** - Every module must work in virtual mode. If a
   module fails, we need to find a solution, not mark it as "unsupported".

6. **Skip addons for now** - Addons are skipped in virtual mode initially.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Client (Editor App)                        │
├─────────────────────────────────────────────────────────────────────┤
│  workflow.json  │  virtual_db (JSON)  │  target step/module         │
└────────┬────────┴─────────┬───────────┴──────────┬──────────────────┘
         │                  │                      │
         ▼                  ▼                      ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     POST /workflow/virtual/execute                   │
├─────────────────────────────────────────────────────────────────────┤
│  1. Create mongomock client                                          │
│  2. Populate from virtual_db JSON (if provided)                      │
│  3. Ensure virtual user exists                                       │
│  4. Create VirtualDatabase wrapper (same interface as Database)      │
│  5. Execute module using normal workflow code paths                  │
│  6. Export mongomock state to JSON                                   │
│  7. Return response + updated virtual_db                             │
└─────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           Response                                   │
├─────────────────────────────────────────────────────────────────────┤
│  WorkflowResponse (same as real execution)                          │
│  + virtual_db: { collections JSON }                                  │
└─────────────────────────────────────────────────────────────────────┘
```

<!--lets assume that server send db as zip file to client, and client will send
it back as is so it wont cause internert connection speed issues-->

## API Design

### Endpoint: `POST /workflow/virtual/execute`

Single endpoint that handles both getting interaction requests and processing
responses. Matches the behavior of real workflow execution.

**Request:**
```json
{
  "workflow": {
    "workflow_id": "my_workflow",
    "name": "My Workflow",
    "steps": [...],
    "config": {...}
  },
  "virtual_db": {
    "users": [{"_id": "virtual_user", "username": "virtual"}],
    "events": [...],
    "workflow_runs": [...]
  },
  "target_step_id": "step_1",
  "target_module_name": "select_options",
  "response": null
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow` | object | Yes | Full resolved workflow JSON |
| `virtual_db` | object | No | Virtual database state from previous request. If null/empty, server creates fresh state with virtual user. |
| `target_step_id` | string | Yes | Step ID containing target module |
| `target_module_name` | string | Yes | Module name to execute |
| `response` | object | No | `InteractionResponseData` if responding to interaction. Null for initial request. |

**Response (awaiting input):**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "awaiting_input",
  "message": "Virtual module interaction",
  "progress": {
    "current_step": "step_1",
    "current_module": "select_options",
    "completed_steps": [],
    "total_steps": 3,
    "step_index": 0
  },
  "interaction_request": {
    "interaction_id": "int_01JKXYZ...",
    "interaction_type": "select_from_structured",
    "title": "Select an option",
    "display_data": {...}
  },
  "result": {
    "virtual_db": {
      "users": [...],
      "events": [...],
      "workflow_runs": [...]
    }
  }
}
```

**Response (module completed):**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "completed",
  "message": "Virtual module executed successfully",
  "result": {
    "module_outputs": {
      "selected_indices": [0, 2],
      "selected_data": [...]
    },
    "virtual_db": {
      "users": [...],
      "events": [...],
      "workflow_runs": [...]
    }
  }
}
```

**Error Response:**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "error",
  "error": "Module 'select_options' not found in step 'step_1'",
  "result": {
    "error_type": "module_not_found",
    "details": {
      "step_id": "step_1",
      "module_name": "select_options",
      "available_modules": ["input_form", "generate_content"]
    },
    "virtual_db": {...}
  }
}
```

## Implementation

### VirtualDatabase Class

Create a `VirtualDatabase` class that wraps mongomock but provides the same
interface as the real `Database` class:

```python
# backend/db/virtual.py

import mongomock
import json
import logging
from typing import Dict, Any, Optional
from datetime import datetime, timezone

from bson import ObjectId
from .database import DbEventType
from .repos import (
    UserRepository,
    EventRepository,
    WorkflowRepository,
    BranchRepository,
    FileRepository,
    StateRepository,
    TokenRepository,
    VersionRepository,
    ContentRepository,
)

logger = logging.getLogger(__name__)

VIRTUAL_USER_ID = "virtual_user_001"


class VirtualDatabase:
    """
    In-memory database using mongomock for virtual workflow execution.
    
    Provides the same interface as Database but uses mongomock instead
    of real MongoDB. State can be exported to JSON and imported back.
    """
    
    def __init__(self, initial_state: Optional[Dict[str, Any]] = None):
        """
        Initialize virtual database.
        
        Args:
            initial_state: Optional dict of {collection_name: [documents]}
                          to populate the database with.
        """
        self.client = mongomock.MongoClient()
        self.db = self.client["virtual_db"]
        
        # Import initial state if provided
        if initial_state:
            self._import_state(initial_state)
        
        # Ensure virtual user exists
        self._ensure_virtual_user()
        
        # Initialize repositories (same as real Database)
        self.user_repo = UserRepository(self.db)
        self.event_repo = EventRepository(self.db)
        self.workflow_repo = WorkflowRepository(self.db)
        self.branch_repo = BranchRepository(self.db)
        self.file_repo = FileRepository(self.db)
        self.state_repo = StateRepository(self.db)
        self.token_repo = TokenRepository(self.db)
        self.version_repo = VersionRepository(self.db)
        self.content_repo = ContentRepository(self.db)
        
        # Direct collection access (for compatibility)
        self.users = self.db.users
        self.access_keys = self.db.access_keys
        self.refresh_tokens = self.db.refresh_tokens
        self.invitation_codes = self.db.invitation_codes
        self.workflow_runs = self.db.workflow_runs
        self.branches = self.db.branches
        self.events = self.db.events
        self.tokens = self.db.tokens
        self.workflow_templates = self.db.workflow_templates
        self.workflow_versions = self.db.workflow_versions
        self.workflow_files = self.db.workflow_files
        self.workflow_run_version_history = self.db.workflow_run_version_history
        self.option_usage = self.db.option_usage
        self.weighted_keywords = self.db.weighted_keywords
        self.config = self.db.config
        self.content_generation_metadata = self.db.content_generation_metadata
        self.generated_content = self.db.generated_content
    
    def _ensure_virtual_user(self):
        """Ensure the virtual user exists in the database."""
        if not self.db.users.find_one({"_id": VIRTUAL_USER_ID}):
            self.db.users.insert_one({
                "_id": VIRTUAL_USER_ID,
                "user_id": VIRTUAL_USER_ID,
                "username": "virtual_user",
                "email": "virtual@example.com",
                "created_at": datetime.now(timezone.utc),
                "is_virtual": True
            })
    
    def _import_state(self, state: Dict[str, Any]):
        """Import state from JSON dict into mongomock."""
        for collection_name, documents in state.items():
            if documents:
                # Handle ObjectId conversion if needed
                for doc in documents:
                    self._convert_ids(doc)
                self.db[collection_name].insert_many(documents)
    
    def _convert_ids(self, doc: Dict):
        """Convert string _id back to proper format if needed."""
        # mongomock handles string IDs fine, no conversion needed
        # But if we stored ObjectId as string, we might want to convert
        pass
    
    def export_state(self) -> Dict[str, Any]:
        """Export all collections to JSON-serializable dict."""
        result = {}
        for collection_name in self.db.list_collection_names():
            docs = list(self.db[collection_name].find())
            # Make JSON serializable
            serialized_docs = []
            for doc in docs:
                serialized_docs.append(self._serialize_doc(doc))
            result[collection_name] = serialized_docs
        return result
    
    def _serialize_doc(self, doc: Dict) -> Dict:
        """Convert document to JSON-serializable format."""
        result = {}
        for key, value in doc.items():
            if isinstance(value, ObjectId):
                result[key] = str(value)
            elif isinstance(value, datetime):
                result[key] = value.isoformat()
            elif isinstance(value, dict):
                result[key] = self._serialize_doc(value)
            elif isinstance(value, list):
                result[key] = [
                    self._serialize_doc(v) if isinstance(v, dict) else
                    str(v) if isinstance(v, ObjectId) else
                    v.isoformat() if isinstance(v, datetime) else v
                    for v in value
                ]
            else:
                result[key] = value
        return result
    
    def close(self):
        """Close the mongomock client (no-op but maintains interface)."""
        pass
```

### API Route Implementation

```python
# backend/server/api/routes/virtual.py

"""
Virtual Workflow Execution API routes.

Provides endpoints for running modules in virtual context using mongomock.
"""

import logging
import uuid6
from fastapi import APIRouter, Depends
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional

from ..dependencies import get_current_user_id
from models import (
    WorkflowResponse,
    WorkflowStatus,
    WorkflowProgress,
    InteractionResponseData,
    ApiInteractionRequest,
)
from backend.db.virtual import VirtualDatabase, VIRTUAL_USER_ID
from engine.module_registry import ModuleRegistry
from engine.jinja2_resolver import Jinja2Resolver as ParameterResolver
from engine.module_interface import (
    InteractiveModule,
    ExecutableModule,
    InteractionResponse as EngineInteractionResponse,
)
from workflow.workflow_context import WorkflowExecutionContext, StateProxy
from workflow.workflow_utils import convert_interaction_request

logger = logging.getLogger('workflow.virtual')

router = APIRouter(prefix="/workflow/virtual", tags=["virtual"])

# Shared module registry
_registry: Optional[ModuleRegistry] = None


def get_registry() -> ModuleRegistry:
    """Get or create the module registry."""
    global _registry
    if _registry is None:
        _registry = ModuleRegistry()
        _registry.discover_modules()
    return _registry


class VirtualExecuteRequest(BaseModel):
    """Request to execute a module in virtual context."""
    workflow: Dict[str, Any] = Field(
        ...,
        description="Full resolved workflow JSON"
    )
    virtual_db: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Virtual database state from previous request"
    )
    target_step_id: str = Field(
        ...,
        description="Step ID containing target module"
    )
    target_module_name: str = Field(
        ...,
        description="Module name to execute"
    )
    response: Optional[InteractionResponseData] = Field(
        default=None,
        description="Response to interaction (if responding)"
    )


class VirtualExecutionError(Exception):
    """Error during virtual module execution."""
    
    def __init__(
        self,
        error_type: str,
        message: str,
        details: Optional[Dict[str, Any]] = None
    ):
        self.error_type = error_type
        self.message = message
        self.details = details or {}
        super().__init__(message)


def find_step_and_module(
    workflow: Dict[str, Any],
    step_id: str,
    module_name: str
) -> tuple:
    """Find step and module in workflow definition."""
    steps = workflow.get("steps", [])
    
    # Find step
    step = None
    step_index = 0
    for i, s in enumerate(steps):
        if s.get("step_id") == step_id:
            step = s
            step_index = i
            break
    
    if not step:
        available_steps = [s.get("step_id") for s in steps]
        raise VirtualExecutionError(
            "step_not_found",
            f"Step '{step_id}' not found in workflow",
            {"step_id": step_id, "available_steps": available_steps}
        )
    
    # Find module
    modules = step.get("modules", [])
    module_config = None
    module_index = 0
    for i, m in enumerate(modules):
        if m.get("name", m.get("module_id")) == module_name:
            module_config = m
            module_index = i
            break
    
    if not module_config:
        available_modules = [
            m.get("name", m.get("module_id")) for m in modules
        ]
        raise VirtualExecutionError(
            "module_not_found",
            f"Module '{module_name}' not found in step '{step_id}'",
            {
                "step_id": step_id,
                "module_name": module_name,
                "available_modules": available_modules
            }
        )
    
    return step, step_index, module_config, module_index


@router.post("/execute")
async def execute_virtual_module(
    request: VirtualExecuteRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Execute a module in virtual context.
    
    If response is None, returns the interaction request.
    If response is provided, processes the response and returns outputs.
    
    The virtual_db in the response contains the updated database state
    that should be sent back in subsequent requests.
    """
    # Generate virtual workflow run ID
    virtual_run_id = f"virtual_{uuid6.uuid7().hex[:16]}"
    
    try:
        # Create virtual database
        vdb = VirtualDatabase(request.virtual_db)
        
        # Find step and module
        step, step_index, module_config, module_index = find_step_and_module(
            request.workflow,
            request.target_step_id,
            request.target_module_name
        )
        
        # Get module from registry
        registry = get_registry()
        module_id = module_config.get("module_id")
        module = registry.get_module(module_id)
        
        if not module:
            raise VirtualExecutionError(
                "module_not_registered",
                f"Module '{module_id}' not found in registry",
                {"module_id": module_id}
            )
        
        # Build context
        config = request.workflow.get("config", {})
        workflow_id = request.workflow.get("workflow_id", "virtual")
        
        # Get current state from virtual DB
        module_outputs = vdb.state_repo.get_module_outputs(virtual_run_id)
        
        # Create state proxy and resolver
        state_proxy = StateProxy(module_outputs, virtual_run_id, "")
        state_proxy.set_step_config(step)
        resolver = ParameterResolver(state_proxy, config=config)
        
        # Resolve module inputs
        raw_inputs = module_config.get("inputs", {}).copy()
        resolved_inputs = resolver.resolve_with_schema(raw_inputs, module_outputs)
        
        # Create execution context
        context = WorkflowExecutionContext(
            workflow_run_id=virtual_run_id,
            db=vdb,
            module_outputs=module_outputs,
            services={
                "workflow_template_name": workflow_id,
                "user_id": VIRTUAL_USER_ID,
            },
            config=config,
            workflow_dir="",
            workflow_path="",
            workflow_template_name=workflow_id,
            workflow_template_id=None,
            user_id=VIRTUAL_USER_ID,
            branch_id=None,
            logger=logger
        )
        context.step_id = request.target_step_id
        context.current_module_name = request.target_module_name
        context.current_module_index = module_index
        context.retryable = module_config.get("retryable")
        context.sub_actions = module_config.get("sub_actions")
        
        # Execute based on module type and whether response provided
        if isinstance(module, InteractiveModule):
            if request.response is None:
                # Get interaction request
                interaction_req = module.get_interaction_request(
                    resolved_inputs, context
                )
                
                if interaction_req:
                    # Convert to API format
                    api_request = convert_interaction_request(interaction_req)
                    
                    # Build progress
                    progress = WorkflowProgress(
                        current_step=request.target_step_id,
                        current_module=request.target_module_name,
                        completed_steps=[],
                        total_steps=len(request.workflow.get("steps", [])),
                        step_index=step_index
                    )
                    
                    return WorkflowResponse(
                        workflow_run_id=virtual_run_id,
                        status=WorkflowStatus.AWAITING_INPUT,
                        message="Virtual module awaiting input",
                        progress=progress,
                        interaction_request=api_request,
                        result={"virtual_db": vdb.export_state()}
                    )
            else:
                # Process response
                engine_response = EngineInteractionResponse(
                    interaction_id=request.response.value or "",
                    value=request.response.value,
                    selected_indices=request.response.selected_indices,
                    selected_options=request.response.selected_options,
                    cancelled=request.response.cancelled,
                    retry_requested=request.response.retry_requested,
                    retry_groups=request.response.retry_groups,
                    retry_feedback=request.response.retry_feedback,
                    jump_back_requested=request.response.jump_back_requested,
                    jump_back_target=request.response.jump_back_target,
                    form_data=request.response.form_data,
                )
                
                outputs = module.execute_with_response(
                    resolved_inputs, context, engine_response
                )
                
                return WorkflowResponse(
                    workflow_run_id=virtual_run_id,
                    status=WorkflowStatus.COMPLETED,
                    message="Virtual module executed successfully",
                    result={
                        "module_outputs": outputs,
                        "virtual_db": vdb.export_state()
                    }
                )
        
        elif isinstance(module, ExecutableModule):
            # Non-interactive module - execute directly
            outputs = module.execute(resolved_inputs, context)
            
            return WorkflowResponse(
                workflow_run_id=virtual_run_id,
                status=WorkflowStatus.COMPLETED,
                message="Virtual module executed successfully",
                result={
                    "module_outputs": outputs,
                    "virtual_db": vdb.export_state()
                }
            )
        
        else:
            raise VirtualExecutionError(
                "unsupported_module_type",
                f"Module type not supported: {type(module).__name__}",
                {"module_id": module_id}
            )
    
    except VirtualExecutionError as e:
        return WorkflowResponse(
            workflow_run_id=virtual_run_id,
            status=WorkflowStatus.ERROR,
            error=e.message,
            result={
                "error_type": e.error_type,
                "details": e.details,
                "virtual_db": vdb.export_state() if 'vdb' in locals() else None
            }
        )
    
    except Exception as e:
        logger.exception(f"Virtual execution failed: {e}")
        return WorkflowResponse(
            workflow_run_id=virtual_run_id,
            status=WorkflowStatus.ERROR,
            error=str(e),
            result={
                "error_type": "execution_failed",
                "details": {"exception": str(e)},
                "virtual_db": vdb.export_state() if 'vdb' in locals() else None
            }
        )
```

### Register Route in App

```python
# In backend/server/api/app.py

from .routes import virtual

# Add to router includes
app.include_router(virtual.router)
```

## Processing Flow

### Initial Request (Get Interaction)

1. Client sends request with `workflow`, `target_step_id`, `target_module_name`
2. `virtual_db` is null or empty
3. Server creates `VirtualDatabase` with empty state
4. Virtual user is created automatically
5. Module inputs are resolved using empty state
6. `get_interaction_request()` is called
7. Response includes `interaction_request` and `virtual_db` state

### Response Request (Process Interaction)

1. Client sends same request but includes `virtual_db` from previous response
2. Client includes `response` with user's selection
3. Server creates `VirtualDatabase` populated from `virtual_db`
4. State is reconstructed from events in virtual DB
5. Module inputs are resolved using reconstructed state
6. `execute_with_response()` is called
7. Module outputs are stored as events in virtual DB
8. Response includes `module_outputs` and updated `virtual_db`

### Non-Interactive Module

1. Client sends request for non-interactive module
2. Server executes `module.execute()` directly
3. Outputs are stored in virtual DB
4. Response includes `module_outputs` and `virtual_db`

## Virtual User

A fixed virtual user is created automatically:

```python
VIRTUAL_USER_ID = "virtual_user_001"

{
    "_id": "virtual_user_001",
    "user_id": "virtual_user_001", 
    "username": "virtual_user",
    "email": "virtual@example.com",
    "created_at": "2026-02-08T00:00:00Z",
    "is_virtual": True
}
```

This ensures any module or repository that needs a user_id has a valid one.

## Error Types

| Error Type | Description |
|------------|-------------|
| `workflow_invalid` | Workflow JSON validation failed |
| `step_not_found` | Target step not in workflow |
| `module_not_found` | Target module not in step |
| `module_not_registered` | Module ID not in registry |
| `unsupported_module_type` | Module is neither Interactive nor Executable |
| `input_validation_failed` | Module input validation failed |
| `resolution_failed` | Jinja2 resolution failed |
| `execution_failed` | Module execution raised exception |

All errors include:
- `error_type`: Machine-readable error category
- `details`: Dict with context (available options, etc.)
- `virtual_db`: Current DB state (for debugging)

## Future: Mock Data Generation

Separate endpoint for generating mock data:

```
POST /workflow/virtual/mock-data
```

```json
{
  "schema": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {"type": "integer"},
        "label": {"type": "string"}
      }
    }
  },
  "count": 5,
  "context": "Generate sample products"
}
```

Uses gpt-4o-mini/nano to generate realistic mock data matching the schema.
This is independent from the virtual execution endpoint.

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `backend/db/virtual.py` | Create | VirtualDatabase class using mongomock |
| `backend/server/api/routes/virtual.py` | Create | Virtual execution endpoint |
| `backend/server/api/app.py` | Modify | Register virtual router |
| `backend/db/__init__.py` | Modify | Export VirtualDatabase |

## Testing

```python
# Test virtual database serialization
def test_virtual_db_roundtrip():
    vdb1 = VirtualDatabase()
    vdb1.db.test.insert_one({"_id": "1", "value": "test"})
    
    state = vdb1.export_state()
    
    vdb2 = VirtualDatabase(state)
    doc = vdb2.db.test.find_one({"_id": "1"})
    
    assert doc["value"] == "test"


# Test virtual module execution
def test_virtual_select_module():
    request = VirtualExecuteRequest(
        workflow={
            "workflow_id": "test",
            "steps": [{
                "step_id": "step1",
                "modules": [{
                    "module_id": "user.select",
                    "name": "test_select",
                    "inputs": {
                        "data": [{"id": 1}, {"id": 2}],
                        "schema": {"type": "array"},
                        "prompt": "Select one"
                    }
                }]
            }]
        },
        target_step_id="step1",
        target_module_name="test_select"
    )
    
    response = execute_virtual_module(request, "test_user")
    
    assert response.status == WorkflowStatus.AWAITING_INPUT
    assert response.interaction_request is not None
    assert "virtual_db" in response.result
```
