# Virtual Module Execution

## Summary

Enable running workflow modules in a "virtual context" without a real workflow
run. This allows the workflow editor app to preview and test module behavior
with user-provided data, returning the same response format as normal workflow
execution.

## Problem Statement

Currently, modules require a full workflow context to execute:
- A real `workflow_run_id` with database records
- `WorkflowExecutionContext` with DB, services, state proxy
- Event persistence for state tracking
- Addons that may need database access

For the editor app, we need to:
1. Test module configurations without creating real workflows
2. Get the same `InteractionRequest` response that WebUI receives
3. Process user responses and get module outputs
4. All without persisting anything to the database

## Design Goals

1. **Exact parity with real execution** - Virtual endpoints return identical
   response formats to real workflow endpoints
2. **Stateless** - No database persistence (for now)
3. **Client provides all data** - No Jinja2 resolution of `{{ state.* }}`
   expressions; client sends resolved data

<!--i want to clarify above, client will send {{ state.* }}, as it will send
module config as it is stored in resolved workflow. only difference is, for
now, client will send pure state which can be used to resolve value. otherwise,
execution of workflow is same. we will be running modules as is, without
touching anything in current modules. if we change a module to do things
differently, it count as failure and we need to reevaluvate the approach.-->

4. **Skip addons** - Addons require DB access; skip them in virtual mode
5. **Verbose errors** - Detailed error messages for debugging

## API Design

### Endpoint: `POST /workflow/virtual/interaction`

Get interaction request for a module in virtual context.

**Request:**
```json
{
  "workflow": {
    "workflow_id": "my_workflow",
    "name": "My Workflow",
    "steps": [...],
    "config": {...}
  },
  "state": {
    "previous_module_output": [...],
    "some_config_value": "abc"
  },
  "target_step_id": "step_1",
  "target_module_name": "select_options"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow` | object | Yes | Full resolved workflow JSON (same as `resolved_workflow` in DB) |
| `state` | object | No | Mock state object for Jinja2 resolution (defaults to `{}`) |
| `target_step_id` | string | Yes | Step ID containing the target module |
| `target_module_name` | string | Yes | Module name (from `name` field) to execute |

**Response:**

Same as `WorkflowResponse` with `status: "awaiting_input"`:
```json
{
  "workflow_run_id": "virtual",
  "status": "awaiting_input",
  "message": "Virtual module interaction",
  "progress": {
    "current_step": "step_1",
    "current_module": "select_options",
    "completed_steps": [],
    "total_steps": 3,
    "step_index": 0
  },
  "interaction_request": {
    "interaction_id": "virtual_select_abc123",
    "interaction_type": "select_from_structured",
    "title": "Select an option",
    "display_data": {
      "data": [...],
      "schema": {...},
      "multi_select": false,
      "mode": "select"
    },
    "context": {
      "module_id": "user.select"
    }
  }
}
```

**Error Response:**
```json
{
  "workflow_run_id": "virtual",
  "status": "error",
  "error": "Module 'select_options' not found in step 'step_1'",
  "result": {
    "error_type": "module_not_found",
    "details": {
      "step_id": "step_1",
      "module_name": "select_options",
      "available_modules": ["input_form", "generate_content"]
    }
  }
}
```

### Endpoint: `POST /workflow/virtual/respond`

Process a response to a virtual interaction.

**Request:**
```json
{
  "workflow": {
    "workflow_id": "my_workflow",
    "steps": [...],
    "config": {...}
  },
  "state": {
    "previous_module_output": [...]
  },
  "target_step_id": "step_1",
  "target_module_name": "select_options",
  "interaction_id": "virtual_select_abc123",
  "response": {
    "selected_indices": [0, 2],
    "selected_options": []
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow` | object | Yes | Same workflow JSON as interaction request |
| `state` | object | No | Same state as interaction request |
| `target_step_id` | string | Yes | Same step ID |
| `target_module_name` | string | Yes | Same module name |
| `interaction_id` | string | Yes | ID from interaction request |
| `response` | object | Yes | `InteractionResponseData` format |

**Response:**

<!--one thing to note here is that, normal workflow will will process modules
until it see next user interaction module. for virtual environment, will only
process modules up to modules client requested. so, lets say client send
non-interaction module, server will process upto that module. actually, now
think about it, lets make all responses contain state as server knows. for
example, when server done with given module, it will full state in the
response, and client can send it back to server. in this way, client gets to
see and maintain state (if needed) and server will be full stateless.-->

For successful execution:
```json
{
  "workflow_run_id": "virtual",
  "status": "completed",
  "message": "Virtual module executed successfully",
  "result": {
    "module_outputs": {
      "selected_indices": [0, 2],
      "selected_data": [
        {"id": 1, "label": "Option A"},
        {"id": 3, "label": "Option C"}
      ],
      "retry_requested": false,
      "jump_back_requested": false
    }
  }
}
```

For modules that would trigger retry/jump:
```json
{
  "workflow_run_id": "virtual",
  "status": "completed",
  "message": "Virtual module executed successfully",
  "result": {
    "module_outputs": {
      "selected_indices": [],
      "retry_requested": true,
      "retry_feedback": "Please regenerate with more detail",
      "retry_groups": ["group_1"]
    },
    "would_retry": true,
    "retry_target": "generate_content"
  }
}
```

## Implementation

### New File: `backend/server/api/routes/virtual.py`

```python
"""
Virtual Workflow Execution API routes.

Provides endpoints for running modules in virtual context without
creating real workflow runs.
"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import Dict, Any, List, Optional

from ..dependencies import get_current_user_id
from models import (
    WorkflowResponse,
    WorkflowStatus,
    WorkflowProgress,
    InteractionResponseData,
)
from engine.module_registry import ModuleRegistry
from engine.jinja2_resolver import Jinja2Resolver as ParameterResolver
from engine.module_interface import (
    InteractiveModule,
    InteractionResponse as EngineInteractionResponse,
)
from workflow.workflow_context import StateProxy
from workflow.workflow_utils import convert_interaction_request

router = APIRouter(prefix="/workflow/virtual", tags=["virtual"])


class VirtualInteractionRequest(BaseModel):
    """Request to get interaction for a module in virtual context."""
    workflow: Dict[str, Any] = Field(
        ...,
        description="Full resolved workflow JSON"
    )
    state: Dict[str, Any] = Field(
        default_factory=dict,
        description="Mock state for Jinja2 resolution"
    )
    target_step_id: str = Field(
        ...,
        description="Step ID containing target module"
    )
    target_module_name: str = Field(
        ...,
        description="Module name to execute"
    )


class VirtualRespondRequest(BaseModel):
    """Request to process response in virtual context."""
    workflow: Dict[str, Any]
    state: Dict[str, Any] = Field(default_factory=dict)
    target_step_id: str
    target_module_name: str
    interaction_id: str
    response: InteractionResponseData


@router.post("/interaction", response_model=WorkflowResponse)
async def get_virtual_interaction(
    request: VirtualInteractionRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Get interaction request for a module in virtual context.
    
    Returns the same response format as real workflow execution,
    but without creating any database records.
    """
    # Implementation details in Technical Specification
    pass


@router.post("/respond", response_model=WorkflowResponse)
async def respond_virtual_interaction(
    request: VirtualRespondRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Process response to a virtual interaction.
    
    Returns module outputs without persisting anything.
    """
    # Implementation details in Technical Specification
    pass
```

### Virtual Context Class

Create a lightweight context that doesn't require database:

```python
class VirtualExecutionContext:
    """
    Minimal execution context for virtual module execution.
    
    Does not require database or real workflow run.
    """
    
    def __init__(
        self,
        module_outputs: Dict[str, Any],
        config: Dict[str, Any],
        step_id: str,
        module_name: str,
        workflow_id: str = "virtual",
    ):
        self.workflow_run_id = "virtual"
        self.db = None  # No database in virtual mode
        self._module_outputs = module_outputs
        self.services = {}
        self.config = config
        self.workflow_dir = ""
        self.workflow_path = ""
        self.workflow_template_name = workflow_id
        self.workflow_template_id = None
        self.user_id = None
        self.branch_id = None
        self.logger = logging.getLogger('virtual')
        self.current_module_name = module_name
        self.current_module_index = 0
        self.step_id = step_id
        self.router = None
        self.retryable = None
        self.sub_actions = None
        self.cancel_event = None
        
        self.state = StateProxy(module_outputs, "virtual", "")
```

### Processing Flow

#### `get_virtual_interaction`:

1. Validate request structure
2. Find target step in workflow
3. Find target module in step
4. Create `StateProxy` with provided `state`
5. Create `ParameterResolver` with state proxy and workflow config
6. Resolve module inputs using resolver
7. Validate resolved inputs against module schema
8. Create `VirtualExecutionContext`
9. Get module instance from registry
10. Skip addon processor setup (virtual mode)
11. Call `module.get_interaction_request(resolved_inputs, context)`
12. Convert to `ApiInteractionRequest`
13. Build and return `WorkflowResponse`

#### `respond_virtual_interaction`:

1. Validate request structure
2. Find target step and module (same as above)
3. Create state proxy and resolver
4. Resolve module inputs
5. Create `VirtualExecutionContext`
6. Get module instance
7. Convert response to `EngineInteractionResponse`
8. Call `module.execute_with_response(resolved_inputs, context, response)`
9. Return module outputs in `WorkflowResponse.result`

### Error Handling

Provide detailed errors for debugging:

```python
class VirtualExecutionError(Exception):
    """Error during virtual module execution."""
    
    def __init__(
        self,
        error_type: str,
        message: str,
        details: Dict[str, Any] = None
    ):
        self.error_type = error_type
        self.message = message
        self.details = details or {}
        super().__init__(message)


# Error types:
# - workflow_invalid: Workflow JSON validation failed
# - step_not_found: Target step not in workflow
# - module_not_found: Target module not in step
# - module_not_interactive: Module doesn't support interactions
# - input_validation_failed: Module input validation failed
# - resolution_failed: Jinja2 resolution failed
# - execution_failed: Module execution raised exception
```

## Module Compatibility

### Fully Compatible (no context dependencies beyond inputs):
- `user.select` - Uses only `context.retryable`, `context.sub_actions`,
  `context.logger` (all optional)
- `user.input` - Uses only logging
- `user.form` - Uses only logging

### Requires Mock Data:
- `llm.generate` - Needs `{{ state.* }}` data for prompt templates
- `db.query` - Needs database connection (skip in virtual mode)

### Not Supported in Virtual Mode:
- `file.write` - Requires file system access
- `media.generate` - Requires external API calls
- Modules with addons - Addons skipped in virtual mode

<!--just to clarify there're not "not supported" modules, all modules has to be
supported. its just that we need to find a way to run them. never assume
otherwise.-->

## Future Enhancements

### Mock Data Generation Endpoint (separate feature)

```
POST /workflow/virtual/mock-data
```

Generate mock data for a given JSON schema using a lightweight LLM:

```json
{
  "schema": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "id": {"type": "integer"},
        "label": {"type": "string"},
        "tags": {"type": "array", "items": {"type": "string"}}
      }
    }
  },
  "count": 5,
  "context": "Generate sample products for an e-commerce store"
}
```

This would use gpt-4o-mini/nano to generate realistic mock data matching
the schema.

## Questions for Review

1. Should `workflow_run_id: "virtual"` be a fixed string, or should we
   generate a unique ID like `virtual_{uuid}` for tracking purposes?

   <!--lets use one with id, just in case we need something in the future-->

2. For modules that check `context.db` existence (e.g., `db.query`), should
   we return a specific error type, or let them fail naturally?

   <!--modules shouldnt return errors unless it failed to process. we need to
   maintain somekind of virtual db for this. but lets not worry about it right
   away. i think we use mockmongo for something like that libray to mock data.
   we can use that. actually now i'm thinking about it, we can simply use that
   library to maintain virtual db, and may be we can simply not worry about all
   issues around db. this also will allow us to capture data, specially events
   stored in db to process workflow. so instead of just sending "state" we will
   send full db back to client, and client can callback with full db which will
   can be used in the process. thoughts? -->

3. Should we support partial Jinja2 resolution where some expressions resolve
   from provided state and others are left as-is for client display?

    <!--we will have 100% jinha2 expression support. nothing is ommited.-->

4. For the respond endpoint, should we validate that `interaction_id` matches
   what was returned from the interaction endpoint, or trust the client?

   <!--trust client, in this case, server isnt going to store any data, server
   will send data back to client, client will send it back to server. if client
   is going to corrupt or do something with data, its on client, not on
   server.-->
