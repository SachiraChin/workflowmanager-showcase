# Virtual Module Execution - Revision 3

## Summary

Enable running workflow modules in a "virtual context" without a real workflow
run. The server uses mongomock to provide a fully functional in-memory database
that behaves identically to real MongoDB. This allows exact parity with real
workflow execution while remaining completely stateless - the client maintains
and sends back the virtual database state between requests.

The virtual database state is transferred as a gzip-compressed payload to
minimize bandwidth usage over slow connections.

## Design Principles

1. **Exact parity with real execution** - Virtual endpoints mirror real workflow
   endpoints 1:1. Same code paths, same response formats, same event flow.

2. **Mongomock as virtual database** - Instead of mocking individual components,
   we use mongomock to provide a complete in-memory MongoDB that supports all
   operations (events, state, queries, etc.).

3. **Client maintains state** - Server returns the full virtual DB state after
   each request. Client sends it back for subsequent requests. Server is
   completely stateless.

4. **Full Jinja2 support** - All `{{ state.* }}` expressions are resolved
   normally using the virtual database state.

5. **All modules supported** - Every module must work in virtual mode. If a
   module fails, we need to find a solution, not mark it as "unsupported".

6. **Skip addons for now** - Addons are skipped in virtual mode initially.

## API Design

Two endpoints matching the real workflow API:

| Real Endpoint | Virtual Endpoint | Purpose |
|---------------|------------------|---------|
| `POST /workflow/start` | `POST /workflow/virtual/start` | Start execution, get first interaction |
| `POST /workflow/respond` | `POST /workflow/virtual/respond` | Process response, continue execution |

### Endpoint: `POST /workflow/virtual/start`

Start virtual execution of a module. Returns interaction request if module
is interactive.

**Request:**
```json
{
  "workflow": {
    "workflow_id": "my_workflow",
    "name": "My Workflow",
    "steps": [...],
    "config": {...}
  },
  "virtual_db": null,
  "target_step_id": "step_1",
  "target_module_name": "select_options"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow` | object | Yes | Full resolved workflow JSON |
| `virtual_db` | string | No | Base64-encoded gzip of virtual database JSON. If null, creates fresh state. |
| `target_step_id` | string | Yes | Step ID containing target module |
| `target_module_name` | string | Yes | Module name to execute |

**Response (interactive module):**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "awaiting_input",
  "message": "Virtual module awaiting input",
  "progress": {
    "current_step": "step_1",
    "current_module": "select_options",
    "completed_steps": [],
    "total_steps": 3,
    "step_index": 0
  },
  "interaction_request": {
    "interaction_id": "int_01JKXYZ...",
    "interaction_type": "select_from_structured",
    "title": "Select an option",
    "display_data": {...}
  },
  "result": {
    "virtual_db": "H4sIAAAAAAAAA6tWKkktLlGyUlAqS8wpTtVRSs7PS..."
  }
}
```

**Response (non-interactive module):**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "completed",
  "message": "Virtual module executed successfully",
  "result": {
    "module_outputs": {
      "result": [...]
    },
    "virtual_db": {...}
  }
}
```

### Endpoint: `POST /workflow/virtual/respond`

Process response to a virtual interaction.

**Request:**
```json
{
  "workflow": {
    "workflow_id": "my_workflow",
    "steps": [...],
    "config": {...}
  },
  "virtual_db": "H4sIAAAAAAAAA6tWKkktLlGyUlAqS8wpTtVRSs7PS...",
  "target_step_id": "step_1",
  "target_module_name": "select_options",
  "interaction_id": "int_01JKXYZ...",
  "response": {
    "selected_indices": [0, 2],
    "selected_options": []
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `workflow` | object | Yes | Same workflow JSON as start request |
| `virtual_db` | string | Yes | Base64-encoded gzip of virtual database JSON from start response |
| `target_step_id` | string | Yes | Same step ID as start request |
| `target_module_name` | string | Yes | Same module name as start request |
| `interaction_id` | string | Yes | Interaction ID from start response |
| `response` | object | Yes | `InteractionResponseData` with user's response |

**Response:**
```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "completed",
  "message": "Virtual module executed successfully",
  "result": {
    "module_outputs": {
      "selected_indices": [0, 2],
      "selected_data": [
        {"id": 1, "label": "Option A"},
        {"id": 3, "label": "Option C"}
      ],
      "retry_requested": false,
      "jump_back_requested": false
    },
    "virtual_db": {...}
  }
}
```

### Error Response Format

Both endpoints return errors in the same format:

```json
{
  "workflow_run_id": "virtual_01JKXYZ...",
  "status": "error",
  "error": "Module 'select_options' not found in step 'step_1'",
  "result": {
    "error_type": "module_not_found",
    "details": {
      "step_id": "step_1",
      "module_name": "select_options",
      "available_modules": ["input_form", "generate_content"]
    },
    "virtual_db": {...}
  }
}
```

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Client (Editor App)                        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
        ┌───────────────────────┴───────────────────────┐
        │                                               │
        ▼                                               ▼
┌───────────────────────┐                 ┌───────────────────────────┐
│ POST /virtual/start   │                 │ POST /virtual/respond     │
├───────────────────────┤                 ├───────────────────────────┤
│ workflow              │                 │ workflow                  │
│ virtual_db (optional) │                 │ virtual_db (required)     │
│ target_step_id        │                 │ target_step_id            │
│ target_module_name    │                 │ target_module_name        │
│                       │                 │ interaction_id            │
│                       │                 │ response                  │
└───────────┬───────────┘                 └─────────────┬─────────────┘
            │                                           │
            ▼                                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        Virtual Execution Layer                       │
├─────────────────────────────────────────────────────────────────────┤
│  1. Create VirtualDatabase (mongomock)                               │
│  2. Import virtual_db state (if provided)                            │
│  3. Ensure virtual user exists                                       │
│  4. Resolve module inputs via Jinja2                                 │
│  5. Execute module (same code path as real workflow)                 │
│  6. Store events in virtual DB                                       │
│  7. Export virtual_db state                                          │
│  8. Return WorkflowResponse                                          │
└─────────────────────────────────────────────────────────────────────┘
            │                                           │
            ▼                                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           Response                                   │
├─────────────────────────────────────────────────────────────────────┤
│  WorkflowResponse (identical to real workflow)                       │
│  + result.virtual_db: { collections as JSON }                        │
└─────────────────────────────────────────────────────────────────────┘
```

## Virtual Database Serialization

The virtual database state is transferred as a gzip-compressed, base64-encoded
string to minimize bandwidth:

```
Client                              Server
   │                                   │
   │  Request (virtual_db: null)       │
   ├──────────────────────────────────>│
   │                                   │  Create mongomock DB
   │                                   │  Execute module
   │                                   │  Export to JSON
   │                                   │  gzip compress
   │                                   │  base64 encode
   │  Response (virtual_db: "H4sI...") │
   │<──────────────────────────────────┤
   │                                   │
   │  Request (virtual_db: "H4sI...")  │
   ├──────────────────────────────────>│
   │                                   │  base64 decode
   │                                   │  gzip decompress
   │                                   │  Parse JSON
   │                                   │  Import to mongomock
   │                                   │  Execute module
   │                                   │  ...
```

**Format:**
- JSON → gzip → base64 string
- Typical compression ratio: 5-10x for JSON data
- Client treats it as opaque string (no need to parse)

## Implementation

### VirtualDatabase Class

```python
# backend/db/virtual.py

"""
Virtual Database using mongomock for stateless workflow execution.

Provides the same interface as Database but uses an in-memory mongomock
instance. State can be exported to a compressed string and imported back,
allowing the client to maintain state between requests.
"""

import gzip
import base64
import json
import mongomock
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime, timezone

from bson import ObjectId

from .repos import (
    UserRepository,
    EventRepository,
    WorkflowRepository,
    BranchRepository,
    FileRepository,
    StateRepository,
    TokenRepository,
    VersionRepository,
    ContentRepository,
)

logger = logging.getLogger(__name__)

VIRTUAL_USER_ID = "virtual_user_001"


class VirtualDatabase:
    """
    In-memory database using mongomock for virtual workflow execution.
    
    Provides the same interface as Database but uses mongomock instead
    of real MongoDB. State can be exported to JSON and imported back.
    """
    
    def __init__(self, compressed_state: Optional[str] = None):
        """
        Initialize virtual database.
        
        Args:
            compressed_state: Optional base64-encoded gzip of JSON state.
                             If provided, decompresses and imports.
        """
        self.client = mongomock.MongoClient()
        self.db = self.client["virtual_db"]
        
        # Import initial state if provided
        if compressed_state:
            state = self._decompress_state(compressed_state)
            self._import_state(state)
        
        # Ensure virtual user exists
        self._ensure_virtual_user()
        
        # Initialize repositories (same as real Database)
        self.user_repo = UserRepository(self.db)
        self.event_repo = EventRepository(self.db)
        self.workflow_repo = WorkflowRepository(self.db)
        self.branch_repo = BranchRepository(self.db)
        self.file_repo = FileRepository(self.db)
        self.state_repo = StateRepository(self.db)
        self.token_repo = TokenRepository(self.db)
        self.version_repo = VersionRepository(self.db)
        self.content_repo = ContentRepository(self.db)
        
        # Direct collection access (for compatibility with Database interface)
        self.users = self.db.users
        self.access_keys = self.db.access_keys
        self.refresh_tokens = self.db.refresh_tokens
        self.invitation_codes = self.db.invitation_codes
        self.workflow_runs = self.db.workflow_runs
        self.branches = self.db.branches
        self.events = self.db.events
        self.tokens = self.db.tokens
        self.workflow_templates = self.db.workflow_templates
        self.workflow_versions = self.db.workflow_versions
        self.workflow_files = self.db.workflow_files
        self.workflow_run_version_history = self.db.workflow_run_version_history
        self.option_usage = self.db.option_usage
        self.weighted_keywords = self.db.weighted_keywords
        self.config = self.db.config
        self.content_generation_metadata = self.db.content_generation_metadata
        self.generated_content = self.db.generated_content
    
    def _ensure_virtual_user(self):
        """Ensure the virtual user exists in the database."""
        if not self.db.users.find_one({"_id": VIRTUAL_USER_ID}):
            self.db.users.insert_one({
                "_id": VIRTUAL_USER_ID,
                "user_id": VIRTUAL_USER_ID,
                "username": "virtual_user",
                "email": "virtual@example.com",
                "created_at": datetime.now(timezone.utc),
                "is_virtual": True
            })
    
    def _import_state(self, state: Dict[str, Any]):
        """Import state from JSON dict into mongomock."""
        for collection_name, documents in state.items():
            if documents:
                # Deep copy to avoid modifying original
                docs_copy = []
                for doc in documents:
                    docs_copy.append(self._deserialize_doc(doc))
                self.db[collection_name].insert_many(docs_copy)
    
    def _deserialize_doc(self, doc: Dict) -> Dict:
        """Convert JSON document back to MongoDB format."""
        result = {}
        for key, value in doc.items():
            if isinstance(value, dict):
                result[key] = self._deserialize_doc(value)
            elif isinstance(value, list):
                result[key] = [
                    self._deserialize_doc(v) if isinstance(v, dict) else v
                    for v in value
                ]
            else:
                result[key] = value
        return result
    
    def _decompress_state(self, compressed: str) -> Dict[str, Any]:
        """Decompress base64-encoded gzip JSON state."""
        gzip_bytes = base64.b64decode(compressed)
        json_bytes = gzip.decompress(gzip_bytes)
        return json.loads(json_bytes.decode('utf-8'))
    
    def _compress_state(self, state: Dict[str, Any]) -> str:
        """Compress state to base64-encoded gzip JSON."""
        json_bytes = json.dumps(state).encode('utf-8')
        gzip_bytes = gzip.compress(json_bytes)
        return base64.b64encode(gzip_bytes).decode('ascii')
    
    def export_state(self) -> str:
        """Export all collections to compressed string."""
        result = {}
        for collection_name in self.db.list_collection_names():
            docs = list(self.db[collection_name].find())
            serialized_docs = []
            for doc in docs:
                serialized_docs.append(self._serialize_doc(doc))
            result[collection_name] = serialized_docs
        return self._compress_state(result)
    
    def _serialize_doc(self, doc: Dict) -> Dict:
        """Convert document to JSON-serializable format."""
        result = {}
        for key, value in doc.items():
            if isinstance(value, ObjectId):
                result[key] = str(value)
            elif isinstance(value, datetime):
                result[key] = value.isoformat()
            elif isinstance(value, dict):
                result[key] = self._serialize_doc(value)
            elif isinstance(value, list):
                result[key] = [
                    self._serialize_doc(v) if isinstance(v, dict) else
                    str(v) if isinstance(v, ObjectId) else
                    v.isoformat() if isinstance(v, datetime) else v
                    for v in value
                ]
            else:
                result[key] = value
        return result
    
    def close(self):
        """Close the mongomock client (no-op but maintains interface)."""
        pass
```

### API Routes

```python
# backend/server/api/routes/virtual.py

"""
Virtual Workflow Execution API routes.

Provides endpoints for running modules in virtual context using mongomock.
These endpoints mirror the real workflow endpoints for exact parity:

    Real                        Virtual
    POST /workflow/start    →   POST /workflow/virtual/start
    POST /workflow/respond  →   POST /workflow/virtual/respond
"""

import logging
import uuid6
from fastapi import APIRouter, Depends
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional

from ..dependencies import get_current_user_id
from models import (
    WorkflowResponse,
    WorkflowStatus,
    WorkflowProgress,
    InteractionResponseData,
)
from backend.db.virtual import VirtualDatabase, VIRTUAL_USER_ID
from engine.module_registry import ModuleRegistry
from engine.jinja2_resolver import Jinja2Resolver as ParameterResolver
from engine.module_interface import (
    InteractiveModule,
    ExecutableModule,
    InteractionResponse as EngineInteractionResponse,
)
from workflow.workflow_context import WorkflowExecutionContext, StateProxy
from workflow.workflow_utils import convert_interaction_request

logger = logging.getLogger('workflow.virtual')

router = APIRouter(prefix="/workflow/virtual", tags=["virtual"])

# Shared module registry
_registry: Optional[ModuleRegistry] = None


def get_registry() -> ModuleRegistry:
    """Get or create the module registry."""
    global _registry
    if _registry is None:
        _registry = ModuleRegistry()
        _registry.discover_modules()
    return _registry


class VirtualStartRequest(BaseModel):
    """Request to start virtual module execution."""
    workflow: Dict[str, Any] = Field(
        ...,
        description="Full resolved workflow JSON"
    )
    virtual_db: Optional[str] = Field(
        default=None,
        description="Base64-encoded gzip of virtual database JSON. "
                    "If null, creates fresh state."
    )
    target_step_id: str = Field(
        ...,
        description="Step ID containing target module"
    )
    target_module_name: str = Field(
        ...,
        description="Module name to execute"
    )


class VirtualRespondRequest(BaseModel):
    """Request to respond to virtual interaction."""
    workflow: Dict[str, Any] = Field(
        ...,
        description="Full resolved workflow JSON"
    )
    virtual_db: str = Field(
        ...,
        description="Base64-encoded gzip of virtual database JSON from start response"
    )
    target_step_id: str = Field(
        ...,
        description="Step ID containing target module"
    )
    target_module_name: str = Field(
        ...,
        description="Module name"
    )
    interaction_id: str = Field(
        ...,
        description="Interaction ID from start response"
    )
    response: InteractionResponseData = Field(
        ...,
        description="User's response to the interaction"
    )


class VirtualExecutionError(Exception):
    """Error during virtual module execution."""
    
    def __init__(
        self,
        error_type: str,
        message: str,
        details: Optional[Dict[str, Any]] = None
    ):
        self.error_type = error_type
        self.message = message
        self.details = details or {}
        super().__init__(message)


def find_step_and_module(
    workflow: Dict[str, Any],
    step_id: str,
    module_name: str
) -> tuple:
    """
    Find step and module in workflow definition.
    
    Returns:
        (step, step_index, module_config, module_index)
    
    Raises:
        VirtualExecutionError if step or module not found
    """
    steps = workflow.get("steps", [])
    
    # Find step
    step = None
    step_index = 0
    for i, s in enumerate(steps):
        if s.get("step_id") == step_id:
            step = s
            step_index = i
            break
    
    if not step:
        available_steps = [s.get("step_id") for s in steps]
        raise VirtualExecutionError(
            "step_not_found",
            f"Step '{step_id}' not found in workflow",
            {"step_id": step_id, "available_steps": available_steps}
        )
    
    # Find module
    modules = step.get("modules", [])
    module_config = None
    module_index = 0
    for i, m in enumerate(modules):
        if m.get("name", m.get("module_id")) == module_name:
            module_config = m
            module_index = i
            break
    
    if not module_config:
        available_modules = [
            m.get("name", m.get("module_id")) for m in modules
        ]
        raise VirtualExecutionError(
            "module_not_found",
            f"Module '{module_name}' not found in step '{step_id}'",
            {
                "step_id": step_id,
                "module_name": module_name,
                "available_modules": available_modules
            }
        )
    
    return step, step_index, module_config, module_index


def create_virtual_context(
    vdb: VirtualDatabase,
    workflow: Dict[str, Any],
    virtual_run_id: str,
    step: Dict[str, Any],
    module_config: Dict[str, Any],
    module_index: int,
    target_step_id: str,
    target_module_name: str,
) -> tuple[WorkflowExecutionContext, Dict[str, Any]]:
    """
    Create execution context for virtual module execution.
    
    Returns:
        (context, resolved_inputs)
    """
    config = workflow.get("config", {})
    workflow_id = workflow.get("workflow_id", "virtual")
    
    # Get current state from virtual DB
    module_outputs = vdb.state_repo.get_module_outputs(virtual_run_id)
    
    # Create state proxy and resolver
    state_proxy = StateProxy(module_outputs, virtual_run_id, "")
    state_proxy.set_step_config(step)
    resolver = ParameterResolver(state_proxy, config=config)
    
    # Resolve module inputs
    raw_inputs = module_config.get("inputs", {}).copy()
    resolved_inputs = resolver.resolve_with_schema(raw_inputs, module_outputs)
    
    # Create execution context
    context = WorkflowExecutionContext(
        workflow_run_id=virtual_run_id,
        db=vdb,
        module_outputs=module_outputs,
        services={
            "workflow_template_name": workflow_id,
            "user_id": VIRTUAL_USER_ID,
        },
        config=config,
        workflow_dir="",
        workflow_path="",
        workflow_template_name=workflow_id,
        workflow_template_id=None,
        user_id=VIRTUAL_USER_ID,
        branch_id=None,
        logger=logger
    )
    context.step_id = target_step_id
    context.current_module_name = target_module_name
    context.current_module_index = module_index
    context.retryable = module_config.get("retryable")
    context.sub_actions = module_config.get("sub_actions")
    
    return context, resolved_inputs


def build_error_response(
    virtual_run_id: str,
    error: VirtualExecutionError,
    vdb: Optional[VirtualDatabase] = None
) -> WorkflowResponse:
    """Build error response with details."""
    return WorkflowResponse(
        workflow_run_id=virtual_run_id,
        status=WorkflowStatus.ERROR,
        error=error.message,
        result={
            "error_type": error.error_type,
            "details": error.details,
            "virtual_db": vdb.export_state() if vdb else None
        }
    )


@router.post("/start", response_model=WorkflowResponse)
async def start_virtual_module(
    request: VirtualStartRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Start virtual execution of a module.
    
    Mirrors POST /workflow/start for real workflows.
    
    If module is interactive, returns interaction_request.
    If module is non-interactive, executes and returns outputs.
    
    The virtual_db in the response contains the database state
    that must be sent back in the respond request.
    """
    virtual_run_id = f"virtual_{uuid6.uuid7().hex[:16]}"
    vdb = None
    
    try:
        # Create virtual database
        vdb = VirtualDatabase(request.virtual_db)
        
        # Find step and module
        step, step_index, module_config, module_index = find_step_and_module(
            request.workflow,
            request.target_step_id,
            request.target_module_name
        )
        
        # Get module from registry
        registry = get_registry()
        module_id = module_config.get("module_id")
        module = registry.get_module(module_id)
        
        if not module:
            raise VirtualExecutionError(
                "module_not_registered",
                f"Module '{module_id}' not found in registry",
                {"module_id": module_id}
            )
        
        # Create context
        context, resolved_inputs = create_virtual_context(
            vdb=vdb,
            workflow=request.workflow,
            virtual_run_id=virtual_run_id,
            step=step,
            module_config=module_config,
            module_index=module_index,
            target_step_id=request.target_step_id,
            target_module_name=request.target_module_name,
        )
        
        # Handle interactive modules
        if isinstance(module, InteractiveModule):
            interaction_req = module.get_interaction_request(
                resolved_inputs, context
            )
            
            if interaction_req:
                # Convert to API format
                api_request = convert_interaction_request(interaction_req)
                
                # Build progress
                progress = WorkflowProgress(
                    current_step=request.target_step_id,
                    current_module=request.target_module_name,
                    completed_steps=[],
                    total_steps=len(request.workflow.get("steps", [])),
                    step_index=step_index
                )
                
                return WorkflowResponse(
                    workflow_run_id=virtual_run_id,
                    status=WorkflowStatus.AWAITING_INPUT,
                    message="Virtual module awaiting input",
                    progress=progress,
                    interaction_request=api_request,
                    result={"virtual_db": vdb.export_state()}
                )
        
        # Handle non-interactive modules (ExecutableModule)
        if isinstance(module, ExecutableModule):
            outputs = module.execute(resolved_inputs, context)
            
            return WorkflowResponse(
                workflow_run_id=virtual_run_id,
                status=WorkflowStatus.COMPLETED,
                message="Virtual module executed successfully",
                result={
                    "module_outputs": outputs,
                    "virtual_db": vdb.export_state()
                }
            )
        
        raise VirtualExecutionError(
            "unsupported_module_type",
            f"Module type not supported: {type(module).__name__}",
            {"module_id": module_id}
        )
    
    except VirtualExecutionError as e:
        return build_error_response(virtual_run_id, e, vdb)
    
    except Exception as e:
        logger.exception(f"Virtual start failed: {e}")
        return WorkflowResponse(
            workflow_run_id=virtual_run_id,
            status=WorkflowStatus.ERROR,
            error=str(e),
            result={
                "error_type": "execution_failed",
                "details": {"exception": str(e)},
                "virtual_db": vdb.export_state() if vdb else None
            }
        )


@router.post("/respond", response_model=WorkflowResponse)
async def respond_virtual_module(
    request: VirtualRespondRequest,
    user_id: str = Depends(get_current_user_id)
):
    """
    Process response to a virtual interaction.
    
    Mirrors POST /workflow/respond for real workflows.
    
    Requires virtual_db from the start response to reconstruct state.
    Returns module outputs and updated virtual_db.
    """
    virtual_run_id = f"virtual_{uuid6.uuid7().hex[:16]}"
    vdb = None
    
    try:
        # Create virtual database from provided state
        vdb = VirtualDatabase(request.virtual_db)
        
        # Find step and module
        step, step_index, module_config, module_index = find_step_and_module(
            request.workflow,
            request.target_step_id,
            request.target_module_name
        )
        
        # Get module from registry
        registry = get_registry()
        module_id = module_config.get("module_id")
        module = registry.get_module(module_id)
        
        if not module:
            raise VirtualExecutionError(
                "module_not_registered",
                f"Module '{module_id}' not found in registry",
                {"module_id": module_id}
            )
        
        if not isinstance(module, InteractiveModule):
            raise VirtualExecutionError(
                "module_not_interactive",
                f"Module '{module_id}' is not interactive",
                {"module_id": module_id}
            )
        
        # Create context
        context, resolved_inputs = create_virtual_context(
            vdb=vdb,
            workflow=request.workflow,
            virtual_run_id=virtual_run_id,
            step=step,
            module_config=module_config,
            module_index=module_index,
            target_step_id=request.target_step_id,
            target_module_name=request.target_module_name,
        )
        
        # Convert response to engine format
        engine_response = EngineInteractionResponse(
            interaction_id=request.interaction_id,
            value=request.response.value,
            selected_indices=request.response.selected_indices,
            selected_options=request.response.selected_options,
            cancelled=request.response.cancelled,
            retry_requested=request.response.retry_requested,
            retry_groups=request.response.retry_groups,
            retry_feedback=request.response.retry_feedback,
            jump_back_requested=request.response.jump_back_requested,
            jump_back_target=request.response.jump_back_target,
            form_data=request.response.form_data,
        )
        
        # Execute module with response
        outputs = module.execute_with_response(
            resolved_inputs, context, engine_response
        )
        
        return WorkflowResponse(
            workflow_run_id=virtual_run_id,
            status=WorkflowStatus.COMPLETED,
            message="Virtual module executed successfully",
            result={
                "module_outputs": outputs,
                "virtual_db": vdb.export_state()
            }
        )
    
    except VirtualExecutionError as e:
        return build_error_response(virtual_run_id, e, vdb)
    
    except Exception as e:
        logger.exception(f"Virtual respond failed: {e}")
        return WorkflowResponse(
            workflow_run_id=virtual_run_id,
            status=WorkflowStatus.ERROR,
            error=str(e),
            result={
                "error_type": "execution_failed",
                "details": {"exception": str(e)},
                "virtual_db": vdb.export_state() if vdb else None
            }
        )
```

### Register Routes

```python
# In backend/server/api/app.py

from .routes import virtual

# Add to router includes
app.include_router(virtual.router)
```

### Export VirtualDatabase

```python
# In backend/db/__init__.py

from .virtual import VirtualDatabase, VIRTUAL_USER_ID

__all__ = [
    # ... existing exports ...
    "VirtualDatabase",
    "VIRTUAL_USER_ID",
]
```

## Endpoint Comparison

| Aspect | Real Workflow | Virtual Workflow |
|--------|---------------|------------------|
| Start endpoint | `POST /workflow/start` | `POST /workflow/virtual/start` |
| Respond endpoint | `POST /workflow/respond` | `POST /workflow/virtual/respond` |
| Database | Real MongoDB | mongomock |
| State persistence | Server-side (events) | Client-side (compressed virtual_db) |
| State format | N/A | Base64-encoded gzip JSON |
| workflow_run_id | UUID | `virtual_{uuid}` |
| User | Authenticated user | Fixed virtual user |
| Response format | `WorkflowResponse` | `WorkflowResponse` + `virtual_db` |

## Error Types

| Error Type | Description |
|------------|-------------|
| `step_not_found` | Target step not in workflow |
| `module_not_found` | Target module not in step |
| `module_not_registered` | Module ID not in registry |
| `module_not_interactive` | Respond called for non-interactive module |
| `unsupported_module_type` | Module is neither Interactive nor Executable |
| `execution_failed` | Module execution raised exception |

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `backend/db/virtual.py` | Create | VirtualDatabase class |
| `backend/server/api/routes/virtual.py` | Create | Virtual endpoints |
| `backend/server/api/app.py` | Modify | Register virtual router |
| `backend/db/__init__.py` | Modify | Export VirtualDatabase |

## Future: Mock Data Generation

Separate endpoint (to be implemented later):

```
POST /workflow/virtual/mock-data
```

Uses gpt-4o-mini/nano to generate mock data for a given JSON schema.
Independent from virtual execution endpoints.
