# Tabs Container Architecture - Revision 2

## Summary

See r1.md Summary section (unchanged).

## Current Container Architecture

See r1.md Current Container Architecture section (unchanged).

## Initial Proposal (Rejected)

See r1.md Initial Proposal section (unchanged).

## Revised Design

See r1.md Revised Design section (unchanged) for:
- New Types (tabs, tab)
- New UxConfig Fields (tab_label, tab_label_field)
- Tab Label Resolution

---

## Proposed Solution: Context-Based Registration

Use React Context for tab registration. TabsLayout provides context, TabLayout registers with it.

### Key Components

| Component | Purpose |
|-----------|---------|
| **TabsContext** | Provides registration functions and active tab state |
| **TabsLayout** | Container that provides context, re-renders children with passthrough behavior, collects registered tabs, renders tab header bar |
| **TabLayout** | Tab wrapper that registers with TabsContext, only renders content when active |
| **SchemaRenderer** | Handles compound `*.*` parsing |

### Compound Parsing in SchemaRenderer

SchemaRenderer detects `outer.inner` pattern (e.g., `tab.media`):

```tsx
// SchemaRenderer sees render_as="tab.media"
// Splits into outer="tab", inner="media"
// Returns:
<TabLayout {...allParams}>
  <SchemaRenderer schema={{...currentSchema, render_as: "media"}} data={data} />
</TabLayout>
```

This is generic - `*.*` works for any combination. For now, assume only 2 levels.

### TabsLayout Behavior

When TabsLayout renders:
1. Provides TabsContext to descendants
2. Calls SchemaRenderer with modified schema: `display=passthrough`, `render_as=undefined`
3. Normal rendering continues - Array/ObjectSchemaRenderer handle children
4. TabLayout children register themselves with context
5. TabsLayout renders tab header bar from registered tabs
6. Only active tab's content is visible

---

## Test Cases

### Case 1: Pure Array

```json
{
  "chapters": {
    "type": "array",
    "_ux.render_as": "tabs",
    "items": {
      "type": "object",
      "_ux": { "render_as": "tab", "tab_label_field": "title" },
      "properties": {
        "title": { "type": "string" },
        "content": { "type": "string" }
      }
    }
  }
}
```

**Flow:**
```
SchemaRenderer (chapters, render_as="tabs")
  └── TabsLayout [provides TabsContext]
        └── SchemaRenderer (chapters, display=passthrough, render_as=undefined)
              └── ArraySchemaRenderer
                    └── for each item:
                          SchemaRenderer (item, render_as="tab")
                            └── TabLayout [registers with TabsContext]
                                  └── SchemaRenderer (item, render_as=undefined)
                                        └── ObjectSchemaRenderer → renders title, content
```

### Case 2: Passthrough Array

```json
{
  "chapters": {
    "type": "array",
    "_ux.render_as": "tabs",
    "items": {
      "type": "object",
      "_ux.display": "passthrough",
      "properties": {
        "content": {
          "type": "object",
          "_ux": { "render_as": "tab", "tab_label_field": "title" },
          "properties": { "data": { "type": "string" } }
        }
      }
    }
  }
}
```

**Flow:**
```
SchemaRenderer (chapters, render_as="tabs")
  └── TabsLayout [provides TabsContext]
        └── SchemaRenderer (chapters, display=passthrough, render_as=undefined)
              └── ArraySchemaRenderer
                    └── for each item:
                          SchemaRenderer (item, display=passthrough)
                            └── ObjectSchemaRenderer (passthrough) → <>{children}</>
                                  └── SchemaRenderer (content, render_as="tab")
                                        └── TabLayout [registers]
                                              └── ObjectSchemaRenderer → renders data
```

### Case 3: Pure Object (Target Use Case)

```json
{
  "type": "object",
  "_ux.display": "passthrough",
  "properties": {
    "scene_title": { "_ux.display": false },
    "prompts": {
      "type": "object",
      "_ux.render_as": "tabs",
      "properties": {
        "midjourney": {
          "_ux": { "render_as": "tab.media", "tab_label": "Midjourney", "provider": "midjourney" }
        },
        "leonardo": {
          "_ux": { "render_as": "tab", "tab_label": "Leonardo" },
          "properties": { "phoenix_1_0": { "_ux.render_as": "media" } }
        },
        "sora": { "_ux": { "render_as": "tab.media", "tab_label": "Sora" } },
        "stable_diffusion": { "_ux": { "render_as": "tab.media", "tab_label": "Stable Diffusion" } }
      }
    }
  }
}
```

**Flow:**
```
SchemaRenderer (root, display=passthrough)
  └── ObjectSchemaRenderer (passthrough) → <>{children}</>
        └── SchemaRenderer (prompts, render_as="tabs")
              └── TabsLayout [provides TabsContext]
                    └── SchemaRenderer (prompts, display=passthrough, render_as=undefined)
                          └── ObjectSchemaRenderer
                                ├── SchemaRenderer (midjourney, render_as="tab.media")
                                │     └── TabLayout [registers] ← compound parsed
                                │           └── SchemaRenderer (render_as="media")
                                │                 └── MediaPanel
                                ├── SchemaRenderer (leonardo, render_as="tab")
                                │     └── TabLayout [registers]
                                │           └── ObjectSchemaRenderer
                                │                 └── MediaPanel (phoenix_1_0)
                                ├── SchemaRenderer (sora, render_as="tab.media")
                                │     └── TabLayout → MediaPanel
                                └── SchemaRenderer (stable_diffusion, render_as="tab.media")
                                      └── TabLayout → MediaPanel
```

### Case 4: Passthrough Object

```json
{
  "type": "object",
  "_ux.render_as": "tabs",
  "properties": {
    "scene_title": { "_ux.display": false },
    "prompts": {
      "type": "object",
      "_ux.display": "passthrough",
      "properties": {
        "midjourney": { "_ux": { "render_as": "tab.media", "tab_label": "Midjourney" } },
        "leonardo": { "_ux": { "render_as": "tab", "tab_label": "Leonardo" } },
        "sora": { "_ux": { "render_as": "tab.media", "tab_label": "Sora" } },
        "stable_diffusion": { "_ux": { "render_as": "tab.media", "tab_label": "Stable Diffusion" } }
      }
    }
  }
}
```

**Flow:**
```
SchemaRenderer (root, render_as="tabs")
  └── TabsLayout [provides TabsContext]
        └── SchemaRenderer (root, display=passthrough, render_as=undefined)
              └── ObjectSchemaRenderer
                    └── SchemaRenderer (prompts, display=passthrough)
                          └── ObjectSchemaRenderer (passthrough) → <>{children}</>
                                ├── TabLayout (midjourney) → MediaPanel
                                ├── TabLayout (leonardo) → ObjectSchemaRenderer
                                ├── TabLayout (sora) → MediaPanel
                                └── TabLayout (stable_diffusion) → MediaPanel
```

---

## Implementation Plan

### Files to Create

| File | Purpose |
|------|---------|
| `TabsContext.tsx` | React context for tab registration |
| `TabsLayout.tsx` | Container that provides context, renders tab bar |
| `TabLayout.tsx` | Tab wrapper that registers with context |

### Files to Modify

| File | Change |
|------|--------|
| `types.ts` | Add `tabs` to ContainerType, `tab` to RoleType, add `tab_label`/`tab_label_field` to UxConfig |
| `SchemaRenderer.tsx` | Add compound `*.*` parsing before type routing |
| `layouts/index.ts` | Import TabsLayout to register |
| `cc_image_prompts_display_schema.json` | Update prompts to use tabs |

---

## Questions for Review

1. Is the context-based registration approach correct?
<!-- yes, i think other components have similar functionality -->
2. Should compound parsing (`*.*`) be in SchemaRenderer or elsewhere?
<!-- It should be in SchemaRenderer, in my mind, how it could be is,
const SchemaRendrer = (schema, data, children <-- this is new, we need to support this in all components) => {
    if (schema.render_as like ".*) {
        firstRenderAs = x
        secondRenderAs = y

        return 
        <SchemaRenderer schema={...schema, render_as=firstRenderAs} ...>
            <SchemaRenderer schema={...schema, render_as=secondRenderAs} />
        </SchemaRenderer>
    }

    if (schema.rander_as == "tab") {
        return <TabLayout>{{children}}</TabLayout>
    }
    if (schema.render_as == "media") {
        return <MediaThingie>{{children}}</MediaThingie>
    }
}

const TabLayout = (... children <-- need to add this for all container types (for now) ) => {
    // context stuff
    if (chilren) return children; <-- need this for all children
    
    return <SchemaRenderer schema={...schema, render_as=undefined} ... />
}

for now, lets say that components can ignore chidren if needed, good example is
media component
-->
3. How does TabLayout determine visibility - via context state or CSS?
<!-- context -->
4. Any concerns with this approach?
<!-- no as long as you understood what need to be done, i dont want to find half 
way through implementation that something doesnt work. -->
