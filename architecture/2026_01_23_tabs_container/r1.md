# Tabs Container Architecture

## Summary

Add a tabs container to the webui schema-interaction system. Tabs are used when multiple cards/panels take significant space in the view and make navigation difficult. The target use case is workflow/cc step 3 (image prompts) where provider panels (Midjourney, Leonardo, Sora, Stable Diffusion) are currently stacked vertically.

## Current Container Architecture

### Three-Layer Hierarchy

```
Array (ContainerType: card-stack)
  └── Item (LayoutType: card)
        ├── Property (RoleType: card-title)    → slot in card header
        ├── Property (RoleType: card-subtitle) → slot below title
        └── Property (no role)                 → slot in card body
```

- **ContainerType** (`card-stack`, `section-list`) - arranges fully-rendered items
- **LayoutType** (`card`, `section`) - wraps an item with slots for its properties
- **RoleType** (`card-title`, `section-summary`) - marks properties for slot placement

### Rendering Flow

1. **ObjectSchemaRenderer** wraps each property in a div with `data-*` attributes
2. **Passthrough**: When `display: "passthrough"`, returns `<>{children}</>` - children bubble up
3. **Layouts** receive pre-rendered children and query via `data-*` attributes

### Key Files

- `types.ts` - Type definitions (ContainerType, RoleType, LayoutType)
- `layouts/registry.tsx` - Layout registration system
- `layouts/utils.ts` - Child filtering utilities (`filterByAttr`, etc.)
- `ArraySchemaRenderer.tsx` - Routes arrays to container layouts
- `ObjectSchemaRenderer.tsx` - Routes objects to layout types, wraps children with data-*

---

## Initial Proposal (Rejected)

### Approach
Add `tabs` as ContainerType with parent declaring `render_as: "tabs"` and assuming all children are tabs.

### Schema Example
```json
{
  "prompts": {
    "type": "object",
    "_ux.render_as": "tabs",
    "properties": {
      "midjourney": { "_ux.display_label": "Midjourney", ... },
      "leonardo": { "_ux.display_label": "Leonardo", ... }
    }
  }
}
```

### Problems Identified
1. **Assumes all children are tabs** - What if only some children are tabs?
2. **No explicit tab declaration** - Children don't declare themselves as tabs
3. **Array support unclear** - For arrays, all items share same schema, so `display_label` would be identical

---

## Revised Design (Operator Feedback)

### Key Insight: Children Declare Themselves as Tabs

Instead of parent assuming all children are tabs, each child explicitly declares `render_as: "tab"` or `render_as: "tab.*"` (compound).

### New Types

| Type | Category | Purpose |
|------|----------|---------|
| `tabs` | ContainerType | Container that arranges tab children |
| `tab` | RoleType | Marker declaring "I am a tab" |

### New UxConfig Fields

| Field | Type | Purpose |
|-------|------|---------|
| `tab_label` | string | Static tab label from schema |
| `tab_label_field` | string | Field name to read label from data |

### Tab Label Resolution
1. `tab_label` (static from schema)
2. `tab_label_field` (read from item data)
3. Error if neither

### Compound render_as (`tab.media`)

New functionality: compound render_as with dot notation.

- `tab.media` means "this is a tab, render content as media"
- TabsContainer extracts tab metadata, strips `tab.` prefix, re-renders with inner render_as
- Example: `<SchemaRenderer {...props} render_as="media" />`

### Array Schema Example

```json
{
  "chapters": {
    "type": "array",
    "_ux": {
      "render_as": "tabs"
    },
    "items": {
      "type": "object",
      "_ux": {
        "render_as": "tab",
        "tab_label_field": "title"
      },
      "properties": {
        "title": { "type": "string" },
        "content": { "type": "string" }
      }
    }
  }
}
```

### Object Schema Example (Target: Step 3)

```json
{
  "type": "object",
  "_ux.display": "passthrough",
  "properties": {
    "scene_title": { "_ux.display": false },
    "prompts": {
      "type": "object",
      "_ux.render_as": "tabs",
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Midjourney",
            "provider": "midjourney"
          }
        },
        "leonardo": {
          "type": "object",
          "_ux": {
            "render_as": "tab",
            "tab_label": "Leonardo"
          },
          "properties": {
            "phoenix_1_0": {
              "_ux.render_as": "media",
              ...
            }
          }
        },
        "sora": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Sora"
          }
        },
        "stable_diffusion": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Stable Diffusion"
          }
        }
      }
    }
  }
}
```

---

## Implementation Attempts

### Attempt 1: TabsLayout Iterates Schema Properties

**Approach**: TabsLayout receives `schema`, `data`, `path` via LayoutProps. Manually iterate `schema.properties` or `data` array to find tabs.

**Code Concept**:
```tsx
const TabsLayout: React.FC<LayoutProps> = ({ schema, data, path }) => {
  const tabs = [];

  if (Array.isArray(data)) {
    // Array: iterate items
    data.forEach((item, index) => {
      const itemUx = getUx(schema.items);
      if (isTabRenderAs(itemUx.render_as)) {
        tabs.push({ key: index, label: resolveLabel(itemUx, item), ... });
      }
    });
  } else {
    // Object: iterate properties
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      const propUx = getUx(propSchema);
      if (isTabRenderAs(propUx.render_as)) {
        tabs.push({ key, label: resolveLabel(propUx, data[key]), ... });
      }
    }
  }

  // Render active tab with stripped render_as
  return <SchemaRenderer {...} render_as={innerRenderAs} />;
};
```

**Problem**: Does not handle passthrough fields.

**Example Hierarchy**:
```
tabs (container)
  └── passthrough
        └── passthrough
              └── tab.media (child)
```

TabsLayout only looks at direct `schema.properties`, missing children nested under passthroughs.

### Attempt 2: Query Pre-rendered Children

**Approach**: Like CardStackLayout, receive pre-rendered children and query `data-*` attributes.

**Problem**:
- For compound `tab.media`, content is already rendered with full `render_as: "tab.media"`
- Need to re-render with stripped `render_as: "media"`
- Can't re-render pre-rendered ReactElements

### Attempt 3: Make Tabs a Special Renderer (Like Table)

**Approach**: Handle `render_as: "tabs"` in SchemaRenderer BEFORE type routing, like `table`.

**TableSchemaRenderer Pattern**:
- Receives full data and schema
- `discoverColumns()` recursively scans properties for `render_as: "column"`
- Recursion handles passthrough (nested properties)
- When rendering, strips `render_as: "column"`

**Rejected**: Table is special because its layout is fundamentally different (rows/columns grid). Tabs is a pure container like `section-list` and should work within existing container infrastructure.

---

## Current Issue

**Problem**: How to handle passthrough fields in a pure container layout?

**Constraint**: Tabs should be a ContainerType (like `card-stack`), not a special renderer (like `table`).

**Challenge**:
1. Container layouts receive pre-rendered children via `children` prop
2. Passthrough children bubble their children up, so TabsLayout receives them
3. But children have `data-render-as="tab.media"` - content already rendered with compound render_as
4. TabsLayout needs to:
   - Extract tab metadata from children (works via `data-tab-label`)
   - Re-render content with stripped `tab.` prefix (doesn't work - can't re-render ReactElements)

**Key Question**: How can a container layout re-render children with modified render_as, while staying within the existing container infrastructure?

---

## Options to Explore

### Option A: Handle Compound in SchemaRenderer

SchemaRenderer detects `tab.*` compound render_as:
- Strips `tab.` prefix
- Routes to inner render_as (e.g., `media`)
- Wraps result with tab metadata in `data-*` attributes

TabsLayout then receives children with correct inner content already rendered.

**Issue**: Who sets `data-tab-label`? SchemaRenderer doesn't wrap children.

### Option B: Handle Compound in ObjectSchemaRenderer

ObjectSchemaRenderer detects `tab.*` when wrapping children:
- Sets `data-render-as="tab.media"` and `data-tab-label="..."`
- Calls SchemaRenderer with stripped `render_as: "media"`

TabsLayout receives children with:
- `data-render-as="tab.media"` (for tab detection)
- `data-tab-label="..."` (for tab label)
- Inner content rendered as `media`

**Issue**: ArraySchemaRenderer doesn't wrap children in divs currently.

### Option C: Modify ArraySchemaRenderer

Add child wrapping to ArraySchemaRenderer (like ObjectSchemaRenderer):
- Wrap each item in div with `data-*` attributes
- Allows consistent tab metadata for array items

Combined with Option B, this could provide full support.

### Option D: Something Else?

<!--
lets walk through this with some example, i will create 4 types of examples,

#1 Pure array
{
  "chapters": {
    "type": "array",
    "_ux": {
      "render_as": "tabs"
    },
    "items": {
      "type": "object",
      "_ux": {
        "render_as": "tab",
        "tab_label_field": "title"
      },
      "properties": {
        "title": {
          "type": "string"
        },
        "content": {
          "type": "string"
        }
      }
    }
  }
}


#2 Passthrough array
{
  "chapters": {
    "type": "array",
    "_ux": {
      "render_as": "tabs"
    },
    "items": {
      "type": "object",
      "_ux.display": "passthrough",
      "properties": {
        "content": {
          "type": "string",
          "_ux": {
            "render_as": "tab",
            "tab_label_field": "title"
          },
          "properties": {
            "data": "datum"
          }
        }
      }
    }
  }
}


#3 Pure object
{
  "type": "object",
  "_ux.display": "passthrough",
  "properties": {
    "scene_title": { "_ux.display": false },
    "prompts": {
      "type": "object",
      "_ux.render_as": "tabs",
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Midjourney",
            "provider": "midjourney"
          }
        },
        "leonardo": {
          "type": "object",
          "_ux": {
            "render_as": "tab",
            "tab_label": "Leonardo"
          },
          "properties": {
            "phoenix_1_0": {
              "_ux.render_as": "media",
              ...
            }
          }
        },
        "sora": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Sora"
          }
        },
        "stable_diffusion": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Stable Diffusion"
          }
        }
      }
    }
  }
}

#4 Passthrough object
{
  "type": "object",
  "_ux.render_as": "tabs",
  "properties": {
    "scene_title": { "_ux.display": false },
    "prompts": {
      "type": "object",
       "_ux.display": "passthrough",
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Midjourney",
            "provider": "midjourney"
          }
        },
        "leonardo": {
          "type": "object",
          "_ux": {
            "render_as": "tab",
            "tab_label": "Leonardo"
          },
          "properties": {
            "phoenix_1_0": {
              "_ux.render_as": "media",
              ...
            }
          }
        },
        "sora": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Sora"
          }
        },
        "stable_diffusion": {
          "_ux": {
            "render_as": "tab.media",
            "tab_label": "Stable Diffusion"
          }
        }
      }
    }
  }
}

Current solution: SchemaRenderer -> sees render_as="tabs" -> TabsLayout ->
iterate through items in array -> extract tab data -> render first item in
array

Proposal 1: SchemaRenderer -> sees render_as=tabs -> TabsLayout ->
SchemaRenderer with its setting itself's schema.display=passthrough,
schema.render_as=undefined -> 
Array use case: 
SchemaRenderer sees array ->
    ArraySchemaRenderer -> sees the array -> loop through array -> use
    SchemaRenderer -> if passthrough, render children inside <></>, if not wrap
    children layout and return generation -> SchemaRenderer interate through
    nodes until it sees render_as=tab -> TabLayout -> register itself with 
    TabsLayout -> TabsLayout create tab header and keep track of childs  
SchemaRenderer sees object ->
    ObjectSchemaRenderer -> do schema stuff on object/fields -> wrap fields 
    around SchemaRenderer -> if passthrough, render children inside <></>, 
    if not wrap children layout and return generation -> SchemaRenderer 
    interate through nodes until it sees render_as=tab -> TabLayout -> 
    register itself with TabsLayout -> TabsLayout create tab header and 
    keep track of childs 

in this way, we are utilizing all tools available for us, and still make it 
work for current needs.
--> 

---

## Questions for Review

1. Is Option B (handle compound in ObjectSchemaRenderer) the right approach?
2. Should ArraySchemaRenderer be modified to wrap children like ObjectSchemaRenderer?
3. Are there other patterns in the codebase that solve similar problems?
4. Is there a simpler approach we're missing?
