# Tabs Container Architecture - Revision 3

## Summary

See r1.md Summary section (unchanged).

## Current Container Architecture

See r1.md Current Container Architecture section (unchanged).

## Revised Design

See r1.md Revised Design section (unchanged) for types and UxConfig fields.

---

## Proposed Solution: Context-Based Registration with Compound Parsing

### Overview

1. **SchemaRenderer** handles compound `*.*` parsing by recursive wrapping
2. **All layouts/containers** accept optional `children` prop - if passed, render children; if not, render via SchemaRenderer
3. **TabsContext** provides registration and active tab state
4. **TabLayout** registers with context, controls visibility via context state

### SchemaRenderer Changes

Add `children` prop support and compound parsing:

```tsx
const SchemaRenderer = ({ schema, data, path, ux, children }) => {
  // Compound parsing: "tab.media" → outer="tab", inner="media"
  if (ux.render_as?.includes(".")) {
    const [firstRenderAs, secondRenderAs] = ux.render_as.split(".");

    return (
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={{ ...ux, render_as: firstRenderAs }}
      >
        <SchemaRenderer
          schema={schema}
          data={data}
          path={path}
          ux={{ ...ux, render_as: secondRenderAs }}
        />
      </SchemaRenderer>
    );
  }

  // Route to specific renderers
  if (ux.render_as === "tab") {
    return <TabLayout schema={schema} data={data} path={path} ux={ux}>{children}</TabLayout>;
  }

  if (ux.render_as === "media") {
    return <MediaPanel schema={schema} data={data} path={path} ux={ux}>{children}</MediaPanel>;
  }

  // ... existing routing
};
```

### TabLayout Component

```tsx
const TabLayout = ({ schema, data, path, ux, children }) => {
  const tabsContext = useTabsContext();

  // Register this tab with parent TabsLayout
  useEffect(() => {
    const label = ux.tab_label || resolveTabLabelField(ux.tab_label_field, data);
    tabsContext.register({ id: path.join("."), label });
    return () => tabsContext.unregister(path.join("."));
  }, []);

  // Only render if this is the active tab
  if (!tabsContext.isActive(path.join("."))) {
    return null;
  }

  // If children passed (from compound), render them
  if (children) {
    return <>{children}</>;
  }

  // Otherwise, render content via SchemaRenderer
  return (
    <SchemaRenderer
      schema={schema}
      data={data}
      path={path}
      ux={{ ...ux, render_as: undefined }}
    />
  );
};
```

### TabsLayout Component

```tsx
const TabsLayout = ({ schema, data, path, ux, children }) => {
  const [activeTabId, setActiveTabId] = useState<string | null>(null);
  const [tabs, setTabs] = useState<Array<{ id: string; label: string }>>([]);

  const contextValue = {
    register: (tab) => setTabs(prev => [...prev, tab]),
    unregister: (id) => setTabs(prev => prev.filter(t => t.id !== id)),
    isActive: (id) => id === activeTabId || (activeTabId === null && tabs[0]?.id === id),
    setActive: setActiveTabId,
  };

  // If children passed, render them (shouldn't happen for tabs container)
  if (children) {
    return <TabsContext.Provider value={contextValue}>{children}</TabsContext.Provider>;
  }

  return (
    <TabsContext.Provider value={contextValue}>
      {/* Tab Headers */}
      <div className="tab-headers">
        {tabs.map(tab => (
          <button
            key={tab.id}
            onClick={() => setActiveTabId(tab.id)}
            className={tab.id === activeTabId ? "active" : ""}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content - render with passthrough behavior */}
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={{ ...ux, display: "passthrough", render_as: undefined }}
      />
    </TabsContext.Provider>
  );
};
```

### MediaPanel (and other components)

Components can ignore `children` if not needed:

```tsx
const MediaPanel = ({ schema, data, path, ux, children }) => {
  // MediaPanel ignores children - it has its own rendering logic
  return (
    <div className="media-panel">
      {/* ... existing MediaPanel implementation */}
    </div>
  );
};
```

---

## Flow Example: Case 3 (Pure Object)

Schema:
```json
{
  "prompts": {
    "_ux.render_as": "tabs",
    "properties": {
      "midjourney": { "_ux": { "render_as": "tab.media", "tab_label": "Midjourney" } }
    }
  }
}
```

Flow:
```
1. SchemaRenderer(prompts, render_as="tabs")
   └── TabsLayout [provides TabsContext, renders tab headers]
         └── SchemaRenderer(prompts, display=passthrough, render_as=undefined)
               └── ObjectSchemaRenderer
                     └── SchemaRenderer(midjourney, render_as="tab.media")
                           │
                           │  Compound parsing: split into "tab" + "media"
                           │
                           └── SchemaRenderer(midjourney, render_as="tab")
                                 │   children = SchemaRenderer(midjourney, render_as="media")
                                 │
                                 └── TabLayout [registers with context]
                                       │   children = MediaPanel
                                       │   isActive? → render children
                                       │
                                       └── MediaPanel (renders midjourney data)
```

---

## Implementation Plan

### Files to Create

| File | Purpose |
|------|---------|
| `TabsContext.tsx` | React context for tab registration |
| `TabsLayout.tsx` | Container that provides context, renders tab bar |
| `TabLayout.tsx` | Tab wrapper that registers with context |

### Files to Modify

| File | Change |
|------|--------|
| `types.ts` | Add `tabs` to ContainerType, `tab` to RoleType, add `tab_label`/`tab_label_field` to UxConfig |
| `SchemaRenderer.tsx` | Add `children` prop, add compound `*.*` parsing, add routing for `tab` |
| `layouts/index.ts` | Import TabsLayout to register |
| `cc_image_prompts_display_schema.json` | Update prompts to use tabs |

### Components Needing `children` Prop

For now, add `children` prop to layouts/containers that may be used in compound:
- TabLayout (new)
- TabsLayout (new)
- MediaPanel (can ignore children)

Other components can be updated as needed.

---

## Decisions Made

1. **Context-based registration** - Confirmed
2. **Compound parsing in SchemaRenderer** - Confirmed, with recursive wrapping
3. **Visibility via context state** - Confirmed (not CSS)
4. **Children prop pattern** - All layouts/containers accept children; if passed, render them; if not, render via SchemaRenderer
5. **Components can ignore children** - e.g., MediaPanel has its own rendering logic

---

## Detailed Plan of Action

### Phase 1: Type Definitions

**File: `types.ts`**

1. Add `"tabs"` to `ContainerType`
2. Add `"tab"` to `RoleType`
3. Add `"tabs"` to `CONTAINER_TYPES` array
4. Add `"tab"` to `ROLE_TYPES` array
5. Add `tab_label?: string` to `UxConfig`
6. Add `tab_label_field?: string` to `UxConfig`

### Phase 2: TabsContext

**File: `TabsContext.tsx` (new)**

1. Create `TabInfo` interface: `{ id: string; label: string; order: number }`
2. Create `TabsContextValue` interface:
   - `register(tab: TabInfo): void`
   - `unregister(id: string): void`
   - `isActive(id: string): boolean`
   - `setActive(id: string): void`
   - `tabs: TabInfo[]`
   - `activeTabId: string | null`
3. Create `TabsContext` with `createContext`
4. Create `useTabsContext()` hook
5. Create `useTabsContextOptional()` hook (returns null if no context)

### Phase 3: TabLayout Component

**File: `TabLayout.tsx` (new)**

1. Props: `schema`, `data`, `path`, `ux`, `children`
2. Get context via `useTabsContext()`
3. On mount: register with context using `tab_label` or `tab_label_field`
4. On unmount: unregister
5. If not active tab: return `null`
6. If `children` passed: return `<>{children}</>`
7. Else: return `<SchemaRenderer {...} render_as={undefined} />`

### Phase 4: TabsLayout Component

**File: `TabsLayout.tsx` (new)**

1. Props: `schema`, `data`, `path`, `ux`, `children`
2. State: `activeTabId`, managed via context
3. Provide `TabsContext.Provider`
4. Render tab header bar from registered tabs
5. Render content via `<SchemaRenderer {...} display="passthrough" render_as={undefined} />`
6. Register with layout registry: `registerLayout("tabs", TabsLayout)`

### Phase 5: SchemaRenderer Changes

**File: `SchemaRenderer.tsx`**

1. Add `children?: ReactNode` to props interface
2. Add compound `*.*` parsing BEFORE existing routing:
   ```tsx
   if (ux.render_as?.includes(".")) {
     const [outer, inner] = ux.render_as.split(".", 2);
     return (
       <SchemaRenderer {...} render_as={outer}>
         <SchemaRenderer {...} render_as={inner} />
       </SchemaRenderer>
     );
   }
   ```
3. Add routing for `render_as === "tab"`:
   ```tsx
   if (ux.render_as === "tab") {
     return <TabLayout {...}>{children}</TabLayout>;
   }
   ```
4. Update `render_as === "tabs"` routing to use TabsLayout

### Phase 6: Layout Registration

**File: `layouts/index.ts`**

1. Import `TabsLayout` to trigger registration

### Phase 7: Schema Update

**File: `cc_image_prompts_display_schema.json`**

1. Change `prompts._ux.display` from `"passthrough"` to `"visible"`
2. Add `prompts._ux.render_as: "tabs"`
3. Change `midjourney._ux.render_as` from `"media"` to `"tab.media"`
4. Add `midjourney._ux.tab_label: "Midjourney"`
5. Change `leonardo._ux.render_as` from `"card"` to `"tab"`
6. Add `leonardo._ux.tab_label: "Leonardo"`
7. Change `sora._ux.render_as` from `"media"` to `"tab.media"`
8. Add `sora._ux.tab_label: "Sora"`
9. Change `stable_diffusion._ux.render_as` from `"media"` to `"tab.media"`
10. Add `stable_diffusion._ux.tab_label: "Stable Diffusion"`

### Phase 8: Testing

1. Test pure object case (step 3 prompts)
2. Verify tab switching works
3. Verify MediaPanel renders correctly in each tab
4. Verify Leonardo (non-compound `tab`) renders its nested content

---

## Implementation Order

1. Phase 1: Type definitions (foundation)
2. Phase 2: TabsContext (needed by TabLayout and TabsLayout)
3. Phase 3: TabLayout (depends on context)
4. Phase 4: TabsLayout (depends on context)
5. Phase 5: SchemaRenderer changes (depends on TabLayout, TabsLayout)
6. Phase 6: Layout registration
7. Phase 7: Schema update
8. Phase 8: Testing
