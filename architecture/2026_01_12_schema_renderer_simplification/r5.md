# SchemaRenderer Simplification Architecture - Revision 5

## Summary

This revision incorporates operator feedback on R4:

1. **Remove card-content special handling** - Defer to later, no special case in ObjectSchemaRenderer
2. **Pass all meta fields as data attributes** - No derived slots, layouts query raw attributes
3. **Layouts decide placement** - Each layout interprets attributes as it sees fit

---

## Changes from R4

### Removed: getSlotFromRole

R4 had a function mapping roles to slots:
```tsx
// R4 - REMOVED
function getSlotFromRole(renderAs: string | undefined, highlight?: boolean): string {
  if (highlight === true) return "highlight";
  switch (renderAs) {
    case "card-title": return "title";
    // ...
  }
}
```

**Problem**: Hardcoded mapping. Adding new roles requires core changes.

### New: Pass All Meta Fields as Attributes

Instead of deriving a slot, pass ALL rendering-related schema fields as `data-*` attributes:

```tsx
// R5 - NEW
<div
  data-render-as={itemSchema.render_as}
  data-highlight={itemSchema.highlight}
  data-highlight-color={itemSchema.highlight_color}
  data-display-label={itemSchema.display_label}
  data-description={itemSchema.description}
  data-display-order={itemSchema.display_order}
  data-selectable={itemSchema.selectable}
>
  <SchemaRenderer ... />
</div>
```

### Layouts Query and Place

Each layout decides what attributes mean to it:

```tsx
function CardLayout({ children }: LayoutProps) {
  // Layout decides how to interpret attributes
  const titles = filterByAttr(children, "data-render-as", "card-title");
  const subtitles = filterByAttr(children, "data-render-as", "card-subtitle");
  const highlighted = filterByAttr(children, "data-highlight", "true");
  const body = filterExcluding(children, ["card-title", "card-subtitle"]);

  // ...render slots
}
```

---

## Core Principles (Updated)

### 1. Schemas Are Explicit
*(Unchanged from R4)*

### 2. Layouts Are Data-Agnostic
*(Unchanged from R4)*

### 3. Display Is Explicit
*(Unchanged from R4)*

### 4. Containers Own Selection
*(Unchanged from R4)*

### 5. Slots Are Plural
*(Unchanged from R4)*

### 6. Meta Fields Flow Through (NEW)

All rendering-related schema fields are passed as data attributes. Layouts interpret them as needed.

| Schema Field | Data Attribute | Purpose |
|--------------|----------------|---------|
| `render_as` | `data-render-as` | Role/layout type |
| `highlight` | `data-highlight` | Highlight flag |
| `highlight_color` | `data-highlight-color` | Custom highlight color |
| `display_label` | `data-display-label` | Field label |
| `description` | `data-description` | Field description |
| `display_order` | `data-display-order` | Sort order |
| `selectable` | `data-selectable` | Selection enabled |

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SchemaRenderer (Pure Router)                         │
│                                                                              │
│  1. Check null/undefined → return null                                       │
│  2. Route by schema.type → Array/Object/Terminal                             │
│                                                                              │
│  ~20 lines                                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              ▼                       ▼                       ▼
┌─────────────────────────┐ ┌─────────────────────────┐ ┌─────────────────────┐
│  ArraySchemaRenderer    │ │  ObjectSchemaRenderer   │ │   TerminalRenderer  │
│                         │ │                         │ │                     │
│  - Check display mode   │ │  - Check display mode   │ │  - Check display    │
│  - Get layout           │ │  - Get layout           │ │  - Render primitive │
│  - Iterate items        │ │  - Iterate properties   │ │  - Handle templates │
│  - Call SchemaRenderer  │ │  - Wrap with data-*     │ │                     │
│    for each item        │ │  - Handle computed      │ │                     │
│                         │ │  - Handle additional    │ │                     │
│  ~60 lines              │ │  ~100 lines             │ │  ~60 lines          │
└─────────────────────────┘ └─────────────────────────┘ └─────────────────────┘
              │                       │
              └───────────┬───────────┘
                          ▼
              ┌─────────────────────────┐
              │   getLayout(render_as)  │
              │   Registration-based    │
              └─────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Layouts                                         │
│                                                                              │
│  - Receive children with data-* attributes                                  │
│  - Query children by any attribute (filterByAttr)                           │
│  - Decide placement based on layout's interpretation                        │
│  - Handle selection internally (useSelectable)                               │
│  - Wrap EACH child individually                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Component Specifications

### SchemaRenderer

```tsx
/**
 * SchemaRenderer - Pure type-based router.
 * Routes to ArraySchemaRenderer, ObjectSchemaRenderer, or TerminalRenderer.
 */
function SchemaRenderer({ data, schema, path = [] }: SchemaRendererProps) {
  // 1. Null/undefined
  if (data == null) {
    return null;
  }

  // 2. Route by type
  if (schema.type === "array") {
    return <ArraySchemaRenderer data={data} schema={schema} path={path} />;
  }

  if (schema.type === "object") {
    return <ObjectSchemaRenderer data={data} schema={schema} path={path} />;
  }

  // 3. Primitive
  return <TerminalRenderer data={data} schema={schema} path={path} />;
}
```

---

### ArraySchemaRenderer

```tsx
/**
 * ArraySchemaRenderer - Handles arrays.
 *
 * - Checks display mode
 * - Gets layout from render_as (registration-based)
 * - Iterates items, calls SchemaRenderer for each
 * - Layout handles selection internally
 */
function ArraySchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: skip entirely
  if (displayMode === "hidden") {
    return null;
  }

  // Validate
  if (!Array.isArray(data)) {
    return <ErrorRenderer message="Expected array" path={path} />;
  }

  const itemsSchema = schema.items ?? { type: "object", display: "visible" };

  // Render children
  const children = data.map((item, index) => (
    <SchemaRenderer
      key={index}
      data={item}
      schema={itemsSchema}
      path={[...path, String(index)]}
    />
  ));

  // Passthrough: children without layout wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  const Layout = getLayout(schema.render_as);
  return (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );
}
```

---

### ObjectSchemaRenderer

```tsx
/**
 * ObjectSchemaRenderer - Handles objects.
 *
 * - Checks display mode
 * - Gets layout from render_as (registration-based)
 * - Iterates properties (including additionalProperties and computed)
 * - Wraps each child with data-* attributes for ALL meta fields
 * - Layout queries attributes and decides placement
 */
function ObjectSchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: skip entirely
  if (displayMode === "hidden") {
    return null;
  }

  // Validate
  if (typeof data !== "object" || data === null) {
    return <ErrorRenderer message="Expected object" path={path} />;
  }

  const dataObj = data as Record<string, unknown>;
  const properties = schema.properties ?? {};
  const additionalProps = schema.additionalProperties;
  const computed = schema.computed ?? {};

  // Collect renderable items
  const items: RenderableItem[] = [];

  // 1. Regular properties
  for (const [key, propSchema] of Object.entries(properties)) {
    const propDisplay = propSchema.display ?? "hidden";
    if (propDisplay !== "hidden" && key in dataObj) {
      items.push({
        key,
        value: dataObj[key],
        schema: propSchema,
      });
    }
  }

  // 2. Additional properties (dynamic keys)
  if (additionalProps && typeof additionalProps === "object") {
    for (const key of Object.keys(dataObj)) {
      if (!(key in properties)) {
        const addSchema = additionalProps as SchemaProperty;
        const addDisplay = addSchema.display ?? "hidden";
        if (addDisplay !== "hidden") {
          items.push({
            key,
            value: dataObj[key],
            schema: addSchema,
          });
        }
      }
    }
  }

  // 3. Computed fields (virtual)
  for (const [key, compSchema] of Object.entries(computed)) {
    const compDisplay = compSchema.display ?? "hidden";
    if (compDisplay !== "hidden" && compSchema.display_format) {
      items.push({
        key,
        value: dataObj,  // Whole object for template
        schema: compSchema,
      });
    }
  }

  // Sort by display_order
  items.sort((a, b) => (a.schema.display_order ?? 999) - (b.schema.display_order ?? 999));

  // Render children with ALL meta fields as data-* attributes
  const children = items.map(({ key, value, schema: itemSchema }) => {
    const childPath = [...path, key];

    return (
      <div
        key={key}
        data-render-as={itemSchema.render_as}
        data-highlight={itemSchema.highlight ? "true" : undefined}
        data-highlight-color={itemSchema.highlight_color}
        data-display-label={itemSchema.display_label}
        data-description={itemSchema.description}
        data-display-order={itemSchema.display_order}
        data-selectable={itemSchema.selectable ? "true" : undefined}
      >
        <SchemaRenderer
          data={value}
          schema={itemSchema}
          path={childPath}
        />
      </div>
    );
  });

  // Passthrough: children without layout wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  const Layout = getLayout(schema.render_as);
  return (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );
}
```

**Key change**: No `getSlotFromRole`. All meta fields passed as-is.

---

### TerminalRenderer

*(Unchanged from R4)*

```tsx
function TerminalRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  // Handle display_format template
  if (schema.display_format) {
    const formatted = renderTemplate(schema.display_format, data);
    return <TextRenderer value={formatted} label={schema.display_label} />;
  }

  // Route by render_as
  switch (schema.render_as) {
    case "color":
      return <ColorRenderer value={data} label={schema.display_label} />;
    case "url":
      return <UrlRenderer value={data} label={schema.display_label} />;
    case "datetime":
      return <DateTimeRenderer value={data} label={schema.display_label} />;
    case "number":
      return <NumberRenderer value={data} label={schema.display_label} />;
    case "image":
      return <ImageRenderer value={data} label={schema.display_label} />;
    default:
      return <TextRenderer value={String(data)} label={schema.display_label} />;
  }
}
```

---

## Layout Specifications

### Layout Utilities

```tsx
/**
 * Filter children by a data-* attribute value.
 */
function filterByAttr(
  children: ReactNode,
  attr: string,
  value: string
): ReactElement[] {
  const result: ReactElement[] = [];

  React.Children.forEach(children, (child) => {
    if (React.isValidElement(child)) {
      const attrValue = (child.props as Record<string, unknown>)[attr];
      if (attrValue === value) {
        result.push(child);
      }
    }
  });

  return result;
}

/**
 * Filter children by a data-* attribute existing (truthy).
 */
function filterByAttrExists(
  children: ReactNode,
  attr: string
): ReactElement[] {
  const result: ReactElement[] = [];

  React.Children.forEach(children, (child) => {
    if (React.isValidElement(child)) {
      const attrValue = (child.props as Record<string, unknown>)[attr];
      if (attrValue) {
        result.push(child);
      }
    }
  });

  return result;
}

/**
 * Filter children excluding specific render_as values.
 */
function filterExcludingRenderAs(
  children: ReactNode,
  excludeValues: string[]
): ReactElement[] {
  const result: ReactElement[] = [];

  React.Children.forEach(children, (child) => {
    if (React.isValidElement(child)) {
      const renderAs = (child.props as Record<string, unknown>)["data-render-as"];
      if (!excludeValues.includes(renderAs as string)) {
        result.push(child);
      }
    }
  });

  return result;
}

/**
 * Get all children as array.
 */
function childrenToArray(children: ReactNode): ReactElement[] {
  const result: ReactElement[] = [];
  React.Children.forEach(children, (child) => {
    if (React.isValidElement(child)) {
      result.push(child);
    }
  });
  return result;
}
```

### Layout Interface

```tsx
interface LayoutProps {
  schema: SchemaProperty;
  path: string[];
  data: unknown;
  children: ReactNode;
}

// All layouts receive same props
// Layouts query children by data-* attributes
// Layouts handle selection via useSelectable internally
// Layouts wrap EACH child individually
```

---

### CardLayout

```tsx
registerLayout("card", CardLayout);

function CardLayout({ schema, path, data, children }: LayoutProps) {
  const selectable = useSelectable(path, data, schema);
  const index = getIndexFromPath(path);

  // Query children by attributes
  const titles = filterByAttr(children, "data-render-as", "card-title");
  const subtitles = filterByAttr(children, "data-render-as", "card-subtitle");
  const highlighted = filterByAttrExists(children, "data-highlight");
  const body = filterExcludingRenderAs(children, ["card-title", "card-subtitle"]);

  // Remove highlighted from body to avoid duplication
  const bodyWithoutHighlight = body.filter(
    child => !(child.props as Record<string, unknown>)["data-highlight"]
  );

  return (
    <div
      className={cn(
        "relative rounded-lg border-2 bg-card/80",
        selectable?.selected ? "border-primary bg-primary/5" : "border-border",
        selectable && "cursor-pointer"
      )}
      onClick={selectable?.handleClick}
    >
      <div className="p-5">
        {/* Index badge */}
        {index !== undefined && (
          <div className="absolute -left-3 -top-3 w-7 h-7 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-bold">
            {index + 1}
          </div>
        )}

        {/* Selection indicator */}
        {selectable?.selected && (
          <div className="absolute top-2 right-2">
            <Check className="h-5 w-5 text-primary" />
          </div>
        )}

        {/* Titles - wrap EACH */}
        {titles.map((child, i) => (
          <div key={i} className="text-base font-semibold">{child}</div>
        ))}

        {/* Subtitles - wrap EACH */}
        {subtitles.map((child, i) => (
          <div key={i} className="mt-1 text-sm text-muted-foreground">{child}</div>
        ))}

        {/* Highlighted - wrap EACH with highlight styling */}
        {highlighted.map((child, i) => {
          const color = (child.props as Record<string, unknown>)["data-highlight-color"] as string;
          return (
            <span
              key={i}
              className="inline-block mt-2 mr-2 px-2 py-0.5 rounded-md text-sm font-medium"
              style={color ? { backgroundColor: `${color}20`, color } : undefined}
            >
              {child}
            </span>
          );
        })}

        {/* Body - wrap EACH */}
        {bodyWithoutHighlight.length > 0 && (
          <div className="border-t border-border mt-4 pt-4 space-y-3">
            {bodyWithoutHighlight.map((child, i) => (
              <div key={i}>{child}</div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

**Key changes**:
- Uses `filterByAttr` to query by `data-render-as`
- Uses `filterByAttrExists` to find highlighted children
- Can read `data-highlight-color` for custom styling
- No hardcoded slot mapping

---

### CardStackLayout

*(Unchanged from R4)*

```tsx
registerLayout("card-stack", CardStackLayout);

function CardStackLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No items</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

---

### SectionLayout

```tsx
registerLayout("section", SectionLayout);

function SectionLayout({ schema, path, data, children }: LayoutProps) {
  const [expanded, setExpanded] = useState(false);

  // Query children by attributes
  const titles = filterByAttr(children, "data-render-as", "section-title");
  const summaries = filterByAttr(children, "data-render-as", "section-summary");
  const badges = filterByAttr(children, "data-render-as", "section-badge");
  const highlighted = filterByAttrExists(children, "data-highlight");
  const body = filterExcludingRenderAs(children, [
    "section-title", "section-summary", "section-badge"
  ]);

  const bodyWithoutHighlight = body.filter(
    child => !(child.props as Record<string, unknown>)["data-highlight"]
  );

  return (
    <div className="border-2 border-border rounded-lg border-l-4 border-l-primary/40">
      {/* Header - clickable */}
      <button
        type="button"
        onClick={() => setExpanded(!expanded)}
        className="w-full flex items-start gap-3 p-4 text-left hover:bg-muted/30"
      >
        <ChevronRight className={cn("h-5 w-5 transition-transform", expanded && "rotate-90")} />

        <div className="flex-1">
          {/* Title row - wrap EACH inline */}
          <div className="flex items-center gap-2 flex-wrap">
            {titles.map((child, i) => (
              <span key={i} className="font-semibold">{child}</span>
            ))}
            {badges.map((child, i) => (
              <span key={i} className="text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary">
                {child}
              </span>
            ))}
          </div>

          {/* Summaries - wrap EACH */}
          {summaries.map((child, i) => (
            <div key={i} className="mt-1 text-sm text-muted-foreground">{child}</div>
          ))}

          {/* Highlighted - wrap EACH */}
          {highlighted.map((child, i) => {
            const color = (child.props as Record<string, unknown>)["data-highlight-color"] as string;
            return (
              <span
                key={i}
                className="inline-block mt-2 mr-2 px-2 py-0.5 rounded-md text-sm font-medium"
                style={color ? { backgroundColor: `${color}20`, color } : undefined}
              >
                {child}
              </span>
            );
          })}
        </div>
      </button>

      {/* Body - expandable */}
      {expanded && bodyWithoutHighlight.length > 0 && (
        <div className="px-4 pb-4 border-t border-border pt-4 space-y-4">
          {bodyWithoutHighlight.map((child, i) => (
            <div key={i}>{child}</div>
          ))}
        </div>
      )}
    </div>
  );
}
```

---

### SectionListLayout

*(Unchanged from R4)*

```tsx
registerLayout("section-list", SectionListLayout);

function SectionListLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No sections</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

---

### DefaultLayout

*(Unchanged from R4)*

```tsx
registerLayout("default", DefaultLayout);

function DefaultLayout({ children }: LayoutProps) {
  return <div className="space-y-2">{children}</div>;
}
```

---

## render_as Classification (Updated)

### Container Layouts

Applied via `getLayout()`:

| Value | Component | Description |
|-------|-----------|-------------|
| `card-stack` | CardStackLayout | Vertical stack with gap |
| `section-list` | SectionListLayout | Vertical list with gap |
| `card` | CardLayout | Bordered card, queries roles |
| `section` | SectionLayout | Collapsible, queries roles |
| (default) | DefaultLayout | Simple container |

### Role Types (Queried by Layouts)

Layouts query `data-render-as` to find children:

| Value | Queried By | Placement |
|-------|------------|-----------|
| `card-title` | CardLayout | Title area |
| `card-subtitle` | CardLayout | Subtitle area |
| `section-title` | SectionLayout | Header title |
| `section-summary` | SectionLayout | Header summary |
| `section-badge` | SectionLayout | Inline badge |

**Key difference from R4**: No central mapping. Each layout defines what roles it understands.

### Terminal Types

Handled by TerminalRenderer (unchanged):

| Value | Renderer |
|-------|----------|
| `text` | TextRenderer |
| `color` | ColorRenderer |
| `url` | UrlRenderer |
| `datetime` | DateTimeRenderer |
| `number` | NumberRenderer |
| `image` | ImageRenderer |

### Meta Fields as Attributes

| Schema Field | Attribute | Use Case |
|--------------|-----------|----------|
| `render_as` | `data-render-as` | Layout queries for placement |
| `highlight` | `data-highlight` | Find highlighted children |
| `highlight_color` | `data-highlight-color` | Custom highlight styling |
| `display_label` | `data-display-label` | Show field labels |
| `description` | `data-description` | Tooltips, help text |
| `selectable` | `data-selectable` | Selection behavior |

---

## Benefits of This Approach

### 1. No Central Mapping

R4:
```tsx
// Central function everyone depends on
function getSlotFromRole(renderAs) { ... }
```

R5:
```tsx
// Each layout queries what it needs
const titles = filterByAttr(children, "data-render-as", "card-title");
```

### 2. New Roles = Layout Changes Only

Adding a new role like `card-action`:
- R4: Update `getSlotFromRole`, update CardLayout
- R5: Update CardLayout only

### 3. Layouts Can Use Any Attribute

```tsx
// Future: layout reads description for tooltips
const items = childrenToArray(children);
items.forEach(child => {
  const desc = child.props["data-description"];
  // Use for tooltip
});
```

### 4. Custom Styling via Attributes

```tsx
// highlight_color passed through, layout applies it
const color = child.props["data-highlight-color"];
style={{ color, backgroundColor: `${color}20` }}
```

### 5. card-content Solved Naturally

If we need card-content later, a layout can query for it:
```tsx
const cardContents = filterByAttr(children, "data-render-as", "card-content");
// Wrap each in card-style container
```

No special handling in ObjectSchemaRenderer needed.

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx              # Pure router (~20 lines)
├── ArraySchemaRenderer.tsx         # Array handler (~60 lines)
├── ObjectSchemaRenderer.tsx        # Object handler (~100 lines)
├── TerminalRenderer.tsx            # Primitive handler (~60 lines)
├── useSelectable.ts                # Selection hook (existing)
├── layouts/
│   ├── index.ts                    # Registry + getLayout + registerLayout
│   ├── types.ts                    # LayoutProps
│   ├── utils.ts                    # filterByAttr, filterByAttrExists, etc.
│   ├── CardLayout.tsx              # ~90 lines
│   ├── CardStackLayout.tsx         # ~15 lines
│   ├── SectionLayout.tsx           # ~100 lines
│   ├── SectionListLayout.tsx       # ~15 lines
│   └── DefaultLayout.tsx           # ~10 lines
├── terminals/
│   ├── TextRenderer.tsx
│   ├── ColorRenderer.tsx
│   └── ... (existing)
└── types.ts                        # SchemaProperty, DisplayMode
```

---

## Line Count Estimate

| Component | Lines |
|-----------|-------|
| SchemaRenderer.tsx | ~20 |
| ArraySchemaRenderer.tsx | ~60 |
| ObjectSchemaRenderer.tsx | ~100 |
| TerminalRenderer.tsx | ~60 |
| layouts/index.ts | ~20 |
| layouts/types.ts | ~15 |
| layouts/utils.ts | ~50 |
| layouts/CardLayout.tsx | ~90 |
| layouts/CardStackLayout.tsx | ~15 |
| layouts/SectionLayout.tsx | ~100 |
| layouts/SectionListLayout.tsx | ~15 |
| layouts/DefaultLayout.tsx | ~10 |
| **Total** | **~555** |

Similar to R4 (~550 lines), cleaner architecture.

---

## Schema Migration Required

*(Unchanged from R4)*

### Arrays Needing Item `render_as` (6 changes)

| Workflow | File | Change |
|----------|------|--------|
| OMS | aesthetic_display_schema.json | Add `items.render_as: "section"` |
| OMS | paragraph_display_schema.json | Add nested `items.render_as: "card"` |
| CC | cc_text_overlays_display_schema.json | Add `items.render_as: "section"` |
| CC | cc_music_options_display_schema.json | Add `items.render_as: "section"` |
| CC | cc_image_prompts_display_schema.json | Refactor (section-list on object) |
| CC | cc_video_prompts_display_schema.json | Refactor (section-list on object) |

### Objects Needing `display: "passthrough"` (9 changes)

| Workflow | File | Path |
|----------|------|------|
| OMS | leonardo_display_schema.json | `properties.prompts` |
| OMS | midjourney_display_schema.json | `properties.prompts` |
| OMS | sora_display_schema.json | `properties.prompts` |
| OMS | stable_diffusion_display_schema.json | `properties.prompts` |
| OMS | midjourney_animate_display_schema.json | `properties.prompts` |
| OMS | motion_2_0_display_schema.json | `properties.prompts` |
| OMS | color_display_schema.json | `properties.themes.items` |
| CC | cc_image_prompts_display_schema.json | `properties.prompts` |
| CC | cc_video_prompts_display_schema.json | `properties.prompts` |

---

## Plan of Action (POA)

### Phase 1: Foundation - Types and Utilities

**Goal**: Create the foundation without breaking existing code.

#### 1.1 Update Types
- [ ] `types.ts` - Add `DisplayMode` type: `"visible" | "hidden" | "passthrough"`
- [ ] `types.ts` - Update `SchemaProperty` interface to use `display?: DisplayMode | boolean` (backwards compat)

#### 1.2 Create Layout Infrastructure
- [ ] Create `layouts/` folder
- [ ] `layouts/types.ts` - Define `LayoutProps` interface
- [ ] `layouts/utils.ts` - Create filter utilities:
  - `filterByAttr(children, attr, value)`
  - `filterByAttrExists(children, attr)`
  - `filterExcludingRenderAs(children, excludeValues)`
  - `childrenToArray(children)`
- [ ] `layouts/index.ts` - Create registry:
  - `layoutRegistry: Record<string, React.FC<LayoutProps>>`
  - `registerLayout(key, component)`
  - `getLayout(renderAs)`

#### 1.3 Create Layout Components
- [ ] `layouts/DefaultLayout.tsx` (~10 lines)
- [ ] `layouts/CardStackLayout.tsx` (~15 lines)
- [ ] `layouts/SectionListLayout.tsx` (~15 lines)
- [ ] `layouts/CardLayout.tsx` (~90 lines) - with `filterByAttr` queries
- [ ] `layouts/SectionLayout.tsx` (~100 lines) - with `filterByAttr` queries

**Checkpoint**: Layouts compile, registry works, no runtime usage yet.

---

### Phase 2: Core Renderers

**Goal**: Create new renderer components alongside existing ones.

#### 2.1 Create ArraySchemaRenderer
- [ ] `ArraySchemaRenderer.tsx` (~60 lines)
  - Check display mode (handle both boolean and string for backwards compat)
  - Get layout via `getLayout(schema.render_as)`
  - Iterate items, call SchemaRenderer for each
  - Passthrough mode returns fragment
  - Visible mode wraps in Layout

#### 2.2 Create ObjectSchemaRenderer
- [ ] `ObjectSchemaRenderer.tsx` (~100 lines)
  - Check display mode
  - Collect renderable items from:
    - `properties` (check each property's display)
    - `additionalProperties` (dynamic keys)
    - `computed` (virtual fields with display_format)
  - Sort by `display_order`
  - Wrap each child with data-* attributes:
    - `data-render-as`
    - `data-highlight`
    - `data-highlight-color`
    - `data-display-label`
    - `data-description`
    - `data-display-order`
    - `data-selectable`
  - Passthrough mode returns fragment
  - Visible mode wraps in Layout

#### 2.3 Update TerminalRenderer
- [ ] `TerminalRenderer.tsx` - Update to check display mode (string or boolean)

#### 2.4 Create New SchemaRenderer
- [ ] `SchemaRenderer.new.tsx` (~20 lines) - Pure router version
  - Route by `schema.type` to Array/Object/Terminal
  - No display logic, no strictMode, no innerData extraction

**Checkpoint**: New renderers compile, not wired up yet.

---

### Phase 3: Integration

**Goal**: Wire up new renderers, verify with existing schemas.

#### 3.1 Switch SchemaRenderer
- [ ] Rename `SchemaRenderer.tsx` → `SchemaRenderer.old.tsx`
- [ ] Rename `SchemaRenderer.new.tsx` → `SchemaRenderer.tsx`
- [ ] Update `index.ts` exports

#### 3.2 Test with Existing Schemas (display: true/false)
- [ ] Test OMS step 1 (user_input) - simple cards
- [ ] Test OMS step 2 (prompt_generation) - sections with nested content
- [ ] Verify backwards compatibility with `display: true` treated as `"visible"`

**Checkpoint**: Basic rendering works with existing schemas.

---

### Phase 4: Schema Migration

**Goal**: Update schemas to use new display values and explicit render_as on items.

#### 4.1 OMS Workflow Schemas

**Arrays needing item render_as:**
- [ ] `aesthetic_display_schema.json` - Add `items.render_as: "section"`
- [ ] `paragraph_display_schema.json` - Add nested `items.render_as: "card"`

**Objects needing display: "passthrough":**
- [ ] `leonardo_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `midjourney_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `sora_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `stable_diffusion_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `midjourney_animate_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `motion_2_0_display_schema.json` - `properties.prompts.display: "passthrough"`
- [ ] `color_display_schema.json` - `properties.themes.items.display: "passthrough"`

#### 4.2 CC Workflow Schemas

**Arrays needing item render_as:**
- [ ] `cc_text_overlays_display_schema.json` - Add `items.render_as: "section"`
- [ ] `cc_music_options_display_schema.json` - Add `items.render_as: "section"`

**Schemas needing refactor (section-list on object):**
- [ ] `cc_image_prompts_display_schema.json` - Refactor structure
- [ ] `cc_video_prompts_display_schema.json` - Refactor structure

**Objects needing display: "passthrough":**
- [ ] `cc_image_prompts_display_schema.json` - After refactor
- [ ] `cc_video_prompts_display_schema.json` - After refactor

**Checkpoint**: All schemas use new display values, all rendering works.

---

### Phase 5: TUI Adapter

**Goal**: Make TUI work with new display values.

#### 5.1 Create Display Adapter
- [ ] `tui/src/display_adapter.py` (or similar)
  - Function to normalize display values:
    - `"visible"` → `True`
    - `"passthrough"` → traverse children without wrapper (new logic)
    - `"hidden"` → `False`
    - `True` → `True` (backwards compat)
    - `False` → `False` (backwards compat)

#### 5.2 Update TUI Rendering
- [ ] Integrate adapter into TUI schema traversal
- [ ] Test all OMS steps in TUI
- [ ] Test all CC steps in TUI

**Checkpoint**: TUI renders correctly with new schemas.

---

### Phase 6: Cleanup

**Goal**: Remove old code, finalize architecture.

#### 6.1 Remove Old Files
- [ ] Delete `SchemaRenderer.old.tsx`
- [ ] Delete `helpers/extractInnerData.ts` (logic now in ObjectSchemaRenderer)
- [ ] Delete `helpers/getRenderer.ts` (replaced by layout registry)
- [ ] Delete `renderers/layouts/DefaultArrayRenderer.tsx` (replaced)
- [ ] Delete `renderers/layouts/DefaultObjectRenderer.tsx` (replaced)
- [ ] Update `helpers/index.ts` exports

#### 6.2 Remove Old Patterns
- [ ] Remove `isWrapper` from renderer-types.ts
- [ ] Remove `strictMode` from all code
- [ ] Remove `Field` from Renderer interface
- [ ] Remove `SelectableWrapper.tsx` if no longer used externally
- [ ] Remove `SelectableItem.tsx` if no longer used

#### 6.3 Update Exports
- [ ] `index.ts` - Clean up exports
- [ ] `renderers/index.ts` - Clean up exports
- [ ] `renderers/layouts/index.ts` - Remove, use new `layouts/index.ts`

**Checkpoint**: No dead code, clean architecture.

---

### Phase 7: Verification

**Goal**: Full testing of all workflows.

#### 7.1 OMS Workflow Testing
- [ ] Step 1: user_input - card selection
- [ ] Step 2: prompt_generation - sections with card-stacks
- [ ] Step 4: video_prompt_generation - motion anchors
- [ ] Step 5: text_overlays - paragraphs with cards
- [ ] Step 6: titles_descriptions - titles/descriptions
- [ ] Step 7: text_colors - color themes
- [ ] Step 8: music_generation - music options

#### 7.2 CC Workflow Testing
- [ ] Step 1: user_input - pet type, aesthetic, duration
- [ ] Step 2: scene_generation - scenes
- [ ] Step 3: image_prompts - image prompts
- [ ] Step 4: video_prompts - video prompts
- [ ] Step 5: text_overlays - text overlays
- [ ] Step 6: titles_social - titles, descriptions
- [ ] Step 7: music - music options

#### 7.3 Feature Testing
- [ ] Selection in CardLayout
- [ ] Selection in SectionLayout (if applicable)
- [ ] Nested containers (section containing card-stack)
- [ ] Highlight flag with custom colors
- [ ] Computed fields
- [ ] additionalProperties
- [ ] Passthrough mode

**Checkpoint**: All workflows render correctly in WebUI and TUI.

---

## File Changes Summary

### New Files (12)
```
layouts/
├── index.ts
├── types.ts
├── utils.ts
├── CardLayout.tsx
├── CardStackLayout.tsx
├── SectionLayout.tsx
├── SectionListLayout.tsx
└── DefaultLayout.tsx

ArraySchemaRenderer.tsx
ObjectSchemaRenderer.tsx
```

### Modified Files (5)
```
types.ts                    # Add DisplayMode
TerminalRenderer.tsx        # Check display mode
SchemaRenderer.tsx          # Rewrite as pure router
index.ts                    # Update exports
renderers/renderer-types.ts # Remove isWrapper, Field
```

### Deleted Files (6)
```
helpers/extractInnerData.ts
helpers/getRenderer.ts
renderers/layouts/DefaultArrayRenderer.tsx
renderers/layouts/DefaultObjectRenderer.tsx
SelectableWrapper.tsx       # If unused
SelectableItem.tsx          # If unused
```

### Schema Files Modified (17)
```
OMS (11):
- aesthetic_display_schema.json
- paragraph_display_schema.json
- leonardo_display_schema.json
- midjourney_display_schema.json
- sora_display_schema.json
- stable_diffusion_display_schema.json
- midjourney_animate_display_schema.json
- motion_2_0_display_schema.json
- color_display_schema.json

CC (6):
- cc_text_overlays_display_schema.json
- cc_music_options_display_schema.json
- cc_image_prompts_display_schema.json
- cc_video_prompts_display_schema.json
```

---

## Risk Mitigation

### Backwards Compatibility
- Keep `display: true/false` working during transition
- Type union: `display?: DisplayMode | boolean`
- Normalize in renderers: `const isVisible = display === true || display === "visible"`

### Rollback Plan
- Keep `SchemaRenderer.old.tsx` until Phase 7 complete
- Can revert by renaming files back

### Incremental Verification
- Each phase has a checkpoint
- Test after each phase before proceeding
- Don't proceed to cleanup until all tests pass

---

## Summary of Changes from R4

| Aspect | R4 | R5 |
|--------|----|----|
| card-content | Special case in ObjectSchemaRenderer | Removed, defer to later |
| Role → Slot mapping | `getSlotFromRole()` function | Removed, layouts query attributes |
| Child wrapping | `data-slot` attribute | ALL meta fields as `data-*` |
| Layout queries | `groupBySlot()` | `filterByAttr()`, `filterByAttrExists()` |
| Adding new roles | Update central mapping + layout | Update layout only |
| Custom styling | Not supported | `data-highlight-color` etc. |
| Implementation plan | High-level phases | Detailed POA with checkpoints |

---

## Appendix: Estimated Effort

| Phase | Tasks | Complexity |
|-------|-------|------------|
| Phase 1: Foundation | 12 | Low |
| Phase 2: Core Renderers | 5 | Medium |
| Phase 3: Integration | 4 | Low |
| Phase 4: Schema Migration | 17 | Low (repetitive) |
| Phase 5: TUI Adapter | 3 | Medium |
| Phase 6: Cleanup | 9 | Low |
| Phase 7: Verification | 19 | Low (testing) |
| **Total** | **69** | - |
