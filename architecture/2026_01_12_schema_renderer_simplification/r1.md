# SchemaRenderer Simplification Architecture

## Summary

SchemaRenderer has drifted from its R4 vision of being a "simple schema-based router". This document proposes simplification through:
1. Explicit `display` property with three values: `visible`, `hidden`, `passthrough`
2. Elimination of implicit traversal modes (strictMode)
3. Removal of wrapper hacks (isWrapper) in favor of clean architectural patterns
4. Guarantee that `display: visible` nodes are ALWAYS rendered

---

## Current Problems

### Problem 1: Implicit Two-Mode Traversal (strictMode)

SchemaRenderer has a hidden state machine:
- **Non-strict mode**: Traverse without requiring `display: true`, looking for displayable descendants
- **Strict mode**: After first `display: true`, ALL children must have `display: true`

```tsx
// Current: Complex implicit mode switching
if (strictMode && schema.display !== true) {
  return null;  // DROPPED!
}

// extractInnerData.ts - 60+ lines of hasDisplayableDescendant logic
function hasDisplayableDescendant(schema: SchemaProperty): boolean {
  if (schema.display === true) return true;
  // ... recursive checks for properties, items, computed, additionalProperties
}
```

**Problems:**
- Implicit behavior - schema author doesn't know why something renders or doesn't
- Complex recursive checks that slow down rendering
- Nodes can be silently dropped

### Problem 2: Implicit Pass-Through Guessing

```tsx
// Current: Lines 330-346 - guessing when to pass through
const isArrayItem = index !== undefined;
if (!isArrayItem && schema.display !== true && !hasExplicitRenderer(schema) && innerData.length > 0) {
  return (
    <>
      {innerData.map((item) => (
        <SchemaRenderer ... />
      ))}
    </>
  );
}
```

**Problems:**
- "Guessing game" - multiple conditions to infer intent
- Different behavior for array items vs object properties
- Schema author has no explicit control

### Problem 3: isWrapper Hack

```tsx
// Current: renderer-types.ts
interface Renderer {
  isWrapper?: boolean;  // Hack for SectionRenderer to wrap card-stack
}

// SchemaRenderer.tsx - Lines 299-307
if (rendererProp?.isWrapper && hasExplicitRenderer(schema) && schemaRenderer) {
  const syntheticInnerData = [{ key: "_content", value: data, schema: {...}, strictMode: true }];
  return renderWithSlots(rendererProp, schema, data, syntheticInnerData, path, index);
}
```

**Problems:**
- Solves only ONE use case (section wrapping card-stack)
- Creates synthetic data items (`_content`)
- Doesn't generalize to future components

### Problem 4: Nodes Being Dropped

Current logic can drop nodes silently:
- In strictMode, missing `display: true` → dropped
- Role types not consumed by slots → warned but may render incorrectly
- Complex conditional chains mean some paths return null

---

## Proposed Solution: Explicit Display Property

### New Display Values

```typescript
type DisplayMode = "visible" | "hidden" | "passthrough";

interface SchemaProperty {
  display?: DisplayMode;  // Default: "hidden"
  // ... other properties
}
```

| Value | Meaning |
|-------|---------|
| `visible` | Render this node. MUST appear in output. |
| `hidden` | Do not render this node or traverse into it. (Default) |
| `passthrough` | Do not render this node, but traverse into children. |

### Behavior Guarantees

1. **`display: visible`** - Node MUST be rendered, regardless of container or parent context
2. **`display: hidden`** - Node is completely invisible, no traversal
3. **`display: passthrough`** - Node is structurally invisible, but children are processed

### Migration from Current Schema

| Current | New |
|---------|-----|
| `display: true` | `display: "visible"` |
| `display: false` | `display: "hidden"` |
| (missing) + has displayable descendants | `display: "passthrough"` |
| (missing) + no displayable descendants | `display: "hidden"` |

---

## Simplified SchemaRenderer

### New Architecture

```tsx
function SchemaRenderer({ data, schema, path, renderer, index }: Props) {
  // 1. Handle null data
  if (data == null) return null;

  // 2. Handle display mode
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  // 3. Passthrough: render children directly, no wrapper
  if (displayMode === "passthrough") {
    const innerData = extractInnerData(data, schema);
    return (
      <>
        {innerData.map((item) => (
          <SchemaRenderer
            key={item.key}
            data={item.value}
            schema={item.schema}
            path={[...path, String(item.key)]}
            index={typeof item.key === "number" ? item.key : undefined}
            renderer={renderer}  // Pass renderer to children
          />
        ))}
      </>
    );
  }

  // 4. Visible: render with appropriate renderer
  const effectiveRenderer = getEffectiveRenderer(schema, renderer);
  const innerData = extractInnerData(data, schema);

  if (effectiveRenderer) {
    return renderWithSlots(effectiveRenderer, schema, data, innerData, path, index);
  }

  // 5. Terminal: no inner data or no renderer
  return <TerminalRenderer value={data} schema={schema} path={path} />;
}
```

### Key Simplifications

| Current | Simplified |
|---------|------------|
| `hasDisplayableDescendant()` recursive check | REMOVED - explicit `passthrough` |
| `strictMode` parameter threading | REMOVED - no mode switching |
| `isWrapper` hack | REMOVED - see container pattern below |
| Multiple conditional branches | 3 clear paths: hidden → null, passthrough → children, visible → render |

---

## Container Pattern (Replacing isWrapper)

### The Problem isWrapper Solved

Section containing card-stack:
```json
{
  "render_as": "section-list",
  "items": {
    "properties": {
      "title": { "render_as": "section-title", "display": "visible" },
      "ideas": {
        "render_as": "card-stack",
        "display": "visible",
        "items": { ... }
      }
    }
  }
}
```

Section needs to:
1. Render its slots (title, summary)
2. Let card-stack render itself (not treat it as a body slot)

### Clean Solution: Containers Respect Child Renderers

Instead of `isWrapper`, make this the standard behavior:

**Rule**: When a slot contains a child with `render_as` (container), that child renders itself.

```tsx
// In renderWithSlots
function renderWithSlots(renderer, schema, data, innerData, path, index) {
  return (
    <renderer.Render schema={schema} path={path} data={data} index={index}>
      {slotConfigs?.map((slotConfig) => {
        const filtered = innerData.filter((d) => slotConfig.match(d.schema));

        return (
          <slotConfig.Slot key={slotConfig.name}>
            {filtered.map((item) => (
              <SchemaRenderer
                key={item.key}
                data={item.value}
                schema={item.schema}  // If schema has render_as, it gets its own renderer
                path={[...path, String(item.key)]}
                // NO renderer prop passed - child determines its own renderer
              />
            ))}
          </slotConfig.Slot>
        );
      })}
    </renderer.Render>
  );
}
```

The key insight: **Don't pass `renderer` to children inside slots**. Each child determines its own renderer based on its schema.

This means:
- If child has `render_as: "card-stack"`, it uses CardStackRenderer
- If child has no `render_as`, it uses the slot's styling
- No special `isWrapper` flag needed

---

## Simplified extractInnerData

```tsx
function extractInnerData(data: unknown, schema: SchemaProperty): InnerDataItem[] {
  // Arrays: each item
  if (schema.type === "array" && Array.isArray(data)) {
    const itemsSchema = schema.items || { type: "object" };
    return data.map((item, idx) => ({
      key: idx,
      value: item,
      schema: itemsSchema,
    }));
  }

  // Objects: each property with display !== "hidden"
  if (schema.type === "object" && typeof data === "object" && data !== null) {
    const dataObj = data as Record<string, unknown>;
    const properties = schema.properties || {};

    const items: InnerDataItem[] = [];

    for (const [key, propSchema] of Object.entries(properties)) {
      const displayMode = propSchema.display ?? "hidden";
      if (displayMode !== "hidden" && key in dataObj) {
        items.push({
          key,
          value: dataObj[key],
          schema: propSchema,
        });
      }
    }

    // Sort by display_order
    items.sort((a, b) => (a.schema.display_order ?? 999) - (b.schema.display_order ?? 999));

    return items;
  }

  return [];
}
```

**Removed:**
- `strictMode` parameter
- `hasDisplayableDescendant` checks
- computed fields handling (can be separate if needed)
- additionalProperties handling (can be separate if needed)

---

## Role Types Clarification

Role types (`card-title`, `section-title`, etc.) are NOT display modes. They are:
- Hints for slot matching
- Styling instructions

A node can have BOTH:
```json
{
  "title": {
    "render_as": "card-title",  // Role: goes in title slot
    "display": "visible"        // Display: must render
  }
}
```

**Rule**: Role types affect WHERE something renders (which slot), not WHETHER it renders.

If `display: "visible"` and no slot consumes it, it STILL renders (in fallback slot or directly).

---

## Migration Impact

### Schema Changes Required

None on server/TUI side for MVP. WebUI can interpret:
- `display: true` → `"visible"`
- `display: false` → `"hidden"`
- `display: undefined` → `"hidden"` (breaking change from current implicit traversal)

For full feature, schemas need explicit `display: "passthrough"` on structural nodes.

### WebUI Code Changes

| File | Change |
|------|--------|
| `SchemaRenderer.tsx` | Rewrite to simplified version (~100 lines vs ~400) |
| `extractInnerData.ts` | Remove strictMode, hasDisplayableDescendant (~50 lines vs ~180) |
| `renderer-types.ts` | Remove `isWrapper` from Renderer interface |
| `types.ts` | Update DisplayMode type |
| Layout renderers | No changes needed |

---

## Questions for Review

1. **Default display value**: I proposed `hidden` as default. This is a BREAKING CHANGE from current behavior where missing display traverses if descendants have display. Is this acceptable, or should we default to `passthrough` for backwards compatibility?
<!--no we update all schemas to handle new display values, and we can add adapter to tui to make it work. -->

2. **Computed fields**: Currently handled in extractInnerData. Should they:
   - (A) Stay in extractInnerData with their own display check
   - (B) Move to a separate concern
   - (C) Be handled by a specific renderer
<!--extractInnerData is not an rederer right? if it can become renderer, how so? actually, one idea i want to entertain (just entertain, not want to do so), lets make ArrayRenderer and ObjectRenderer two render their respective of values, if there's display_as value for either of those, those 2 will put baseline for what to do, and do rendering, actually, this is another huge mess we have right now, we messed up big time with having extraction logic in SchemaRenderer, may be ObjectRenderer and ArrayRenderer can see data and do the extraction. how can that help for this?-->

3. **additionalProperties**: Same question - keep in extractInnerData or handle separately?
<!--I'm not sure what you mean here, additionalProperties should be treated as any json schema things, its just we need to read it differently than other schema, but in the same time, they have similar rules. this begs the question actually, are we reading addtionalProperties and use them accodingly?-->

4. **Array items display**: Should array items inherit display from parent array, or must each item schema have explicit display?
   ```json
   {
     "type": "array",
     "display": "visible",
     "items": {
       // Does this need display: "visible" too?
     }
   }
   <!--yes, array's display=visible says, this array is visible, items field lets say abc has display=visible, means its rendered, xyz has display=hidden, means that field is hidden.-->
   ```

5. **Role type fallback**: If a `card-title` node isn't in a card context, should it:
   - (A) Warn and render as plain text (current)
   - (B) Silently render as plain text
   - (C) Error
   <!--Good question, it should render with warning, so, that feild will be rendered by terminals, as how termals render data, if possible we can show warning below. one option i want entertain for a different time is, add debug mode for webui where show all these things inline, when debug is off, we just render it, no warn, thats for later, may be add issue for it, with simple info-->

---

## Appendix: Before/After Comparison

### Before (Current ~400 lines)
```tsx
function SchemaRenderer({ data, schema, path, className, strictMode, index, renderer }) {
  const { state: workflowState } = useWorkflowStateContext();
  const templateState = (workflowState.state_mapped || {}) as Record<string, unknown>;
  const isRoot = path.length === 0;

  if (data == null) return null;

  if (isRoot && !hasDisplayableDescendant(schema)) {
    return <div>No displayable content</div>;
  }

  if (schema.selectable === true && hasNestedSelectable(schema.items || schema)) {
    return <ErrorRenderer ... />;
  }

  if (schema.display_format && !schema.render_as) {
    const formatted = renderTemplate(schema.display_format, data, templateState);
    return <TerminalRenderer ... />;
  }

  if (isRoleType(schema.render_as)) {
    console.warn(`Role type "${schema.render_as}" found outside container context`);
  }

  const schemaRenderer = getRenderer(schema);
  const innerData = extractInnerData(data, schema, strictMode);

  if (rendererProp?.isWrapper && hasExplicitRenderer(schema) && schemaRenderer) {
    const syntheticInnerData = [{ key: "_content", ... }];
    return renderWithSlots(rendererProp, schema, data, syntheticInnerData, path, index);
  }

  const renderer = hasExplicitRenderer(schema) ? schemaRenderer : rendererProp ?? schemaRenderer;

  const isArrayItem = index !== undefined;
  if (!isArrayItem && schema.display !== true && !hasExplicitRenderer(schema) && innerData.length > 0) {
    return <>{innerData.map(...}</>
  }

  if (renderer) {
    return renderWithSlots(renderer, schema, data, innerData, path, index);
  }

  if (innerData.length > 0) {
    return <>{innerData.map(...}</>
  }

  if (strictMode && schema.display !== true) {
    return null;
  }

  return <TerminalRenderer ... />;
}
```

### After (Proposed ~100 lines)
```tsx
function SchemaRenderer({ data, schema, path, index, renderer }: Props) {
  // 1. Null data
  if (data == null) return null;

  // 2. Display mode
  const displayMode = schema.display ?? "hidden";
  if (displayMode === "hidden") return null;

  // 3. Passthrough
  if (displayMode === "passthrough") {
    const innerData = extractInnerData(data, schema);
    return (
      <>
        {innerData.map((item) => (
          <SchemaRenderer
            key={item.key}
            data={item.value}
            schema={item.schema}
            path={[...path, String(item.key)]}
            index={typeof item.key === "number" ? item.key : undefined}
            renderer={renderer}
          />
        ))}
      </>
    );
  }

  // 4. Visible - get renderer
  const effectiveRenderer = getEffectiveRenderer(schema, renderer);
  const innerData = extractInnerData(data, schema);

  // 5. Render with slots or terminal
  if (effectiveRenderer && innerData.length > 0) {
    return renderWithSlots(effectiveRenderer, schema, data, innerData, path, index);
  }

  return <TerminalRenderer value={data} schema={schema} path={path} />;
}
```

---

## Next Steps

1. Operator review and feedback on this proposal
2. Decide on open questions (defaults, computed fields, etc.)
3. Create implementation plan if approved
