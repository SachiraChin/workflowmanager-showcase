# SchemaRenderer Simplification Architecture - Revision 3

## Summary

This revision addresses feedback on R2:
1. **Unified layout selection** - Layouts are data-type agnostic; both Array and Object can use any layout
2. **additionalProperties** - Handled by ObjectSchemaRenderer
3. **Computed fields** - Handled by ObjectSchemaRenderer
4. **Selection** - Any node with `selectable: true` gets wrapped; containers can customize
5. **Highlight** - Cross-cutting concern for multiple layouts, not just CardLayout

---

## Key Insight: Layouts Are Data-Type Agnostic

### The Misconception

R2 proposed separate layout lookups:
- `getArrayLayout()` → card-stack, section-list
- `getObjectLayout()` → card, section

This implies layouts are tied to data types. **Wrong.**

### The Truth

Layouts are pure visual containers. They receive children and render them. They don't care if children came from array items or object properties.

**Valid Examples:**

```json
// Array with card-stack (common)
{
  "type": "array",
  "render_as": "card-stack",
  "items": { "render_as": "card" }
}

// Object with card-stack (also valid)
{
  "type": "object",
  "render_as": "card-stack",
  "properties": {
    "midjourney": { "render_as": "card", "display": "visible" },
    "leonardo": { "render_as": "card", "display": "visible" }
  }
}

// Array with section-list (common)
{
  "type": "array",
  "render_as": "section-list",
  "items": { "render_as": "section" }
}

// Object with section-list (also valid)
{
  "type": "object",
  "render_as": "section-list",
  "properties": {
    "basics": { "render_as": "section", "display": "visible" },
    "advanced": { "render_as": "section", "display": "visible" }
  }
}
```

### What's Actually Different

| Aspect | ArraySchemaRenderer | ObjectSchemaRenderer |
|--------|--------------------|--------------------|
| Iteration | `data[0], data[1], ...` | `data.prop_a, data.prop_b, ...` |
| Schema per child | Same (`items` schema) | Different (per property) |
| Slot assignment | None (all items same type) | Yes (based on `render_as` role) |
| Display per child | Inherits from array  | Each property has own `display` |

**Layouts don't care about any of this.** They just receive children.
<!--"Display per child" for array is wrong above. When array node itself has display=visible, it says that that array as whole is visible, and its chilren must be rendered. array itself can have render_as which can be a container which children are included. When array item's field has display=visible, means that field in the object is visible, so and so forth. I think important question to think here is how Field option work and how thats going to apply here. we probably need to dig deep into it and add details in the doc. -->
---

## Unified Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SchemaRenderer (Pure Router)                         │
│  - Checks null/undefined                                                     │
│  - Routes by schema.type                                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              ▼                       ▼                       ▼
┌─────────────────────┐   ┌─────────────────────┐   ┌─────────────────────┐
│ ArraySchemaRenderer │   │ObjectSchemaRenderer │   │  TerminalRenderer   │
│                     │   │                     │   │                     │
│ - Iterates items    │   │ - Iterates props    │   │ - Renders primitive │
│ - Same schema each  │   │ - Different schemas │   │                     │
│ - No slot assign    │   │ - Adds data-slot    │   │                     │
│ - Picks layout      │   │ - Picks layout      │   │                     │
│   (ANY layout)      │   │   (ANY layout)      │   │                     │
└─────────────────────┘   └─────────────────────┘   └─────────────────────┘
              │                       │
              └───────────┬───────────┘
                          ▼
              ┌─────────────────────────┐
              │  getLayout(render_as)   │
              │  (Unified - same for    │
              │   both array & object)  │
              └─────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Layouts (Pure Visual)                                 │
│                                                                              │
│  - Receive children (ReactNode)                                              │
│  - Group by data-slot if present                                             │
│  - If no slots, render in order                                              │
│  - NO data access, NO schema access                                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Unified Layout Selection

```tsx
<!--we probably have registration based logic for these-->
/**
 * Get layout component for ANY render_as value.
 * Used by both ArraySchemaRenderer and ObjectSchemaRenderer.
 */
function getLayout(renderAs: string | undefined): React.FC<LayoutProps> {
  switch (renderAs) {
    // List containers (spacing between children)
    case "card-stack":
      return CardStackLayout;
    case "section-list":
      return SectionListLayout;

    // Item containers (slots, styling)
    case "card":
      return CardLayout;
    case "section":
      return SectionLayout;

    // Default
    default:
      return DefaultLayout;
  }
}
```

---

## Updated ArraySchemaRenderer

```tsx
function ArraySchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  if (!Array.isArray(data)) {
    return <ErrorRenderer message="Expected array" path={path} />;
  }

  const itemsSchema = schema.items ?? { type: "object" };

  // Render children
  const children = data.map((item, index) => (
    <SchemaRenderer
      key={index}
      data={item}
      schema={itemsSchema}
      path={[...path, String(index)]}
    />
  ));

  // Passthrough: children without wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  const Layout = getLayout(schema.render_as);  // <-- Unified!
  const content = (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );

  // Selection wrapper if selectable
  <!--probably keep an eye of below, as each container can define its own selectable behavior. check containers, how they work just in case.-->
  if (schema.selectable) {
    return (
      <SelectableWrapper schema={schema} path={path} data={data}>
        {content}
      </SelectableWrapper>
    );
  }

  return content;
}
```

---

## Updated ObjectSchemaRenderer

```tsx
function ObjectSchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  if (typeof data !== "object" || data === null) {
    return <ErrorRenderer message="Expected object" path={path} />;
  }

  const dataObj = data as Record<string, unknown>;
  const properties = schema.properties ?? {};
  const additionalProps = schema.additionalProperties;
  const computed = schema.computed ?? {};

  // Collect renderable items
  const items: Array<{ key: string; value: unknown; schema: SchemaProperty; slot: string }> = [];

  // 1. Regular properties
  for (const [key, propSchema] of Object.entries(properties)) {
    const propDisplay = propSchema.display ?? "hidden";
    if (propDisplay !== "hidden" && key in dataObj) {
      items.push({
        key,
        value: dataObj[key],
        schema: propSchema,
        slot: getSlotFromRole(propSchema.render_as),
      });
    }
  }

  // 2. Additional properties (dynamic keys not in schema.properties)
  if (additionalProps && typeof additionalProps === "object") {
    for (const key of Object.keys(dataObj)) {
      if (!(key in properties)) {
        const addSchema = additionalProps as SchemaProperty;
        const addDisplay = addSchema.display ?? "hidden";
        if (addDisplay !== "hidden") {
          items.push({
            key,
            value: dataObj[key],
            schema: addSchema,
            slot: getSlotFromRole(addSchema.render_as),
          });
        }
      }
    }
  }

  // 3. Computed fields (virtual fields derived from data)
  for (const [key, computedSchema] of Object.entries(computed)) {
    const compDisplay = computedSchema.display ?? "hidden";
    if (compDisplay !== "hidden" && computedSchema.display_format) {
      items.push({
        key,
        value: dataObj,  // Computed fields receive whole object for template
        schema: computedSchema,
        slot: getSlotFromRole(computedSchema.render_as),
      });
    }
  }

  // Sort by display_order
  items.sort((a, b) => (a.schema.display_order ?? 999) - (b.schema.display_order ?? 999));

  // Render children with data-slot wrappers
  const children = items.map(({ key, value, schema: itemSchema, slot }) => (
    <div key={key} data-slot={slot}>
      <SchemaRenderer
        data={value}
        schema={itemSchema}
        path={[...path, key]}
      />
    </div>
  ));

  // Passthrough: children without wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  const Layout = getLayout(schema.render_as);  // <-- Unified!
  const content = (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );

  // Selection wrapper if selectable
  if (schema.selectable) {
    return (
      <SelectableWrapper schema={schema} path={path} data={data}>
        {content}
      </SelectableWrapper>
    );
  }

  return content;
}

<!--we probably have registration based logic for these-->
/**
 * Map render_as role type to slot name.
 */
function getSlotFromRole(renderAs: string | undefined): string {
  switch (renderAs) {
    case "card-title":
    case "section-title":
      return "title";
    case "card-subtitle":
    case "section-summary":
      return "subtitle";
    case "section-badge":
      return "badge";
    case "highlight":
      return "highlight";
    default:
      return "body";
  }
}
```

---

## Selection Handling

### Rule

Any node with `selectable: true` must be wrapped for selection. There are two approaches:

1. **Default wrapping**: Use `SelectableWrapper` component
2. **Container-specific**: Layout handles selection internally

### Implementation

```tsx
// In ArraySchemaRenderer and ObjectSchemaRenderer:
if (schema.selectable) {
  return (
    <SelectableWrapper schema={schema} path={path} data={data}>
      {content}
    </SelectableWrapper>
  );
}
```

### Layout-Specific Selection

Some layouts (like CardLayout) may want to integrate selection UI directly (checkbox in corner, border color, etc.). In this case:

```tsx
// CardLayout can use useSelectable internally
function CardLayout({ schema, path, data, children }: LayoutProps) {
  const selectable = useSelectable(path, data, schema);

  return (
    <div
      className={cn("card", selectable?.selected && "selected")}
      onClick={selectable?.handleClick}
    >
      {/* Selection indicator */}
      {selectable && <SelectionIndicator selected={selectable.selected} />}
      {children}
    </div>
  );
}
```

**Question**: Should selection always be handled by `SelectableWrapper`, or can layouts opt-in to handle it themselves?

**Proposal**: Layouts receive a `selectable` prop. If they handle it, they set `handlesSelection: true` in their config. Otherwise, Array/ObjectSchemaRenderer wraps with SelectableWrapper.

---

## Highlight Handling

Highlight is a cross-cutting slot that applies to multiple layouts.

### Slot Assignment

<!--I dont think current implementation of slots are correct. how I thought was, when there're slots, we simply give container all chilren which has that slot condition, and container meant to container supposed to wrap EACH children by the ux for each slot type. For example, there's no slot.title, its always slot.titles, we cant stop user from having 2 title fields, 5 summary fields. we have no control over it, so we always assume its 1+ and wrap each child for each slot type with respective wrapper. what i understood from current logic is that container wrap all children with one wrapper.-->

```tsx
function getSlotFromRole(renderAs: string | undefined): string {
  // ...
  case "highlight":
    return "highlight";
  // ...
}
```

Or via `highlight: true` on schema:

```tsx
// In ObjectSchemaRenderer, when collecting items:
const slot = propSchema.highlight === true
  ? "highlight"
  : getSlotFromRole(propSchema.render_as);
```

### Layout Support

Layouts that support highlight slot:

```tsx
// CardLayout
function CardLayout({ children }: LayoutProps) {
  const slots = groupBySlot(children);

  return (
    <div className="card">
      {slots.title && <div className="title">{slots.title}</div>}
      {slots.subtitle && <div className="subtitle">{slots.subtitle}</div>}
      {slots.highlight && (
        <div className="highlight-container">
          {slots.highlight.map((child, i) => (
            <span key={i} className="highlight-badge">{child}</span>
          ))}
        </div>
      )}
      {slots.body && <div className="body">{slots.body}</div>}
    </div>
  );
}

// SectionLayout - same pattern
function SectionLayout({ children }: LayoutProps) {
  const slots = groupBySlot(children);

  return (
    <div className="section">
      <div className="header">
        {slots.title}
        {slots.badge}
        {slots.highlight && (
          <div className="highlight-container">{slots.highlight}</div>
        )}
      </div>
      {slots.subtitle}
      {slots.body}
    </div>
  );
}
```

---

## Complete render_as Classification

### Container Types (Layout Selection)

| Value | Layout | Description |
|-------|--------|-------------|
| `card-stack` | CardStackLayout | Vertical stack with gap |
| `section-list` | SectionListLayout | Vertical list with gap |
| `card` | CardLayout | Bordered card with slots |
| `section` | SectionLayout | Collapsible section with slots |
| (none) | DefaultLayout | Simple container |

**Any data type (array or object) can use any layout.**

### Role Types (Slot Assignment)

| Value | Slot | Description |
|-------|------|-------------|
| `card-title` | title | Primary heading |
| `section-title` | title | Primary heading |
| `card-subtitle` | subtitle | Secondary text |
| `section-summary` | subtitle | Secondary text |
| `section-badge` | badge | Inline badge |
| (none) | body | Default content |

<!--
you missed card-content above, and that one was a mess to handle. you probably new section just to handle that.
problem with that one was that, its classified as a role, but behaves like container. the idea of the card-content 
was that its single field value, rendered as a card, how it randers is that, its simple card layout,field's 
display_label as header, and fields value as body of card. due to this behavior, it went up and down so many times
and each fix we added to make that work, it broke others. whole reason we have wrappers and so much of logic is
due to this component.
-->

### Special Flags

| Flag | Effect |
|------|--------|
| `highlight: true` | Assigns to "highlight" slot |
| `selectable: true` | Enables selection wrapping |

---

## Data Flow Example: Object with card-stack

### Schema

```json
{
  "type": "object",
  "render_as": "card-stack",
  "display": "visible",
  "properties": {
    "midjourney": {
      "type": "object",
      "render_as": "card",
      "display": "visible",
      "selectable": true,
      "properties": {
        "prompt": { "type": "string", "render_as": "card-title", "display": "visible" },
        "params": { "type": "string", "display": "visible", "display_label": "Parameters" }
      }
    },
    "leonardo": {
      "type": "object",
      "render_as": "card",
      "display": "visible",
      "selectable": true,
      "properties": {
        "prompt": { "type": "string", "render_as": "card-title", "display": "visible" },
        "style": { "type": "string", "display": "visible", "display_label": "Style" }
      }
    }
  }
}
```

### Render Flow

```
SchemaRenderer(type: "object")
  └─► ObjectSchemaRenderer
        ├─ display="visible" ✓
        ├─ render_as="card-stack" → CardStackLayout
        │
        ├─ midjourney: data-slot="body"
        │    └─► SchemaRenderer(type: "object")
        │          └─► ObjectSchemaRenderer
        │                ├─ render_as="card" → CardLayout
        │                ├─ selectable=true → wrapped
        │                └─ properties...
        │
        └─ leonardo: data-slot="body"
             └─► SchemaRenderer(type: "object")
                   └─► ObjectSchemaRenderer
                         └─ ... same pattern
```

### Output

```
CardStackLayout
  └─ [data-slot="body"]
       └─ SelectableWrapper
            └─ CardLayout (midjourney)
                 ├─ [title] prompt value
                 └─ [body] Parameters: params value
  └─ [data-slot="body"]
       └─ SelectableWrapper
            └─ CardLayout (leonardo)
                 ├─ [title] prompt value
                 └─ [body] Style: style value
```

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx              # Pure router (~20 lines)
├── ArraySchemaRenderer.tsx         # Array handler (~60 lines)
├── ObjectSchemaRenderer.tsx        # Object handler (~120 lines)
├── TerminalRenderer.tsx            # Primitive handler (~60 lines)
├── SelectableWrapper.tsx           # Selection UI wrapper
├── useSelectable.ts                # Selection hook
├── layouts/
│   ├── index.ts                    # Layout registry + getLayout()
│   ├── types.ts                    # LayoutProps, groupBySlot
│   ├── CardLayout.tsx              # Card with slots (~60 lines)
│   ├── CardStackLayout.tsx         # Card stack (~15 lines)
│   ├── SectionLayout.tsx           # Section with slots (~70 lines)
│   ├── SectionListLayout.tsx       # Section list (~15 lines)
│   └── DefaultLayout.tsx           # Fallback (~15 lines)
├── terminals/
│   └── ... (existing)
└── types.ts                        # SchemaProperty, DisplayMode
```

---

## Questions for Review

1. **Layout-specific selection**: Should layouts be able to handle selection themselves (like CardLayout with checkbox), or always use SelectableWrapper?
<!--yeah, container must handle selectable, simply because they may have UX for selectable. but if they dont want to handle it, 
they can use SeletableWrapper internally. but thats decision made by container, not the parent renderer.-->

2. **Slot for highlight**: Use `render_as: "highlight"` or `highlight: true` flag? Or both as aliases?
<!--we cant do that isnt it? there can be node "render_as": "card-title" and highlight=true, hightight in a way, enhacement on
existing rendering mechanism, not a state itself.-->

3. **Default layout for array vs object**: Should DefaultLayout behave differently for arrays (gap) vs objects (no gap)?
<!--there should be any diffrence on that, the boundaries are provided by containers, layouts, and we are not going
enforce anything outside of that.-->

---

## Changes from R2

| Aspect | R2 | R3 |
|--------|----|----|
| Layout lookup | Separate `getArrayLayout` / `getObjectLayout` | Unified `getLayout` |
| additionalProperties | Asked if needed | Included in ObjectSchemaRenderer |
| Computed fields | Asked if needed | Included in ObjectSchemaRenderer |
| Selection | Mentioned | Explicit wrapping pattern with layout opt-out |
| Highlight | Asked if keep | Cross-cutting slot for multiple layouts |
