# SchemaRenderer Simplification Architecture - Revision 2

## Summary

This revision refines the architecture based on operator feedback. The core insight: **extraction logic belongs in Array/ObjectSchemaRenderer, not SchemaRenderer**. SchemaRenderer becomes a pure type-based router. Layouts become pure visual wrappers that group children by `data-slot` attributes.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SchemaRenderer (Pure Router)                         │
│  - Checks null/undefined                                                     │
│  - Routes by schema.type to appropriate renderer                             │
│  - ~30 lines                                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              ▼                       ▼                       ▼
┌─────────────────────┐   ┌─────────────────────┐   ┌─────────────────────┐
│ ArraySchemaRenderer │   │ObjectSchemaRenderer │   │  TerminalRenderer   │
│                     │   │                     │   │                     │
│ - Data-aware        │   │ - Data-aware        │   │ - Data-aware        │
│ - Picks layout from │   │ - Picks layout from │   │ - Renders primitive │
│   render_as         │   │   render_as         │   │ - Handles nudges    │
│ - Iterates items    │   │ - Iterates props    │   │ - Selection support │
│ - Calls Schema-     │   │ - Adds data-slot    │   │                     │
│   Renderer per item │   │ - Calls Schema-     │   │                     │
│                     │   │   Renderer per prop │   │                     │
└─────────────────────┘   └─────────────────────┘   └─────────────────────┘
              │                       │
              ▼                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Layouts (Pure Visual)                                 │
│                                                                              │
│  CardStackLayout, SectionListLayout, CardLayout, SectionLayout, etc.        │
│                                                                              │
│  - Receive children (ReactNode) with data-slot attributes                   │
│  - Group children by data-slot                                              │
│  - Render visual structure                                                  │
│  - NO data access, NO schema access                                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Display Property

### Values

```typescript
type DisplayMode = "visible" | "hidden" | "passthrough";
```

| Value | Meaning |
|-------|---------|
| `visible` | Render this node. MUST appear in output. |
| `hidden` | Do not render this node. Do not traverse. (Default) |
| `passthrough` | Do not render wrapper, but render children. |

### Rules

1. `display: "visible"` → Node MUST be rendered, regardless of context
2. `display: "hidden"` → Node is invisible, no traversal (default)
3. `display: "passthrough"` → Node wrapper is invisible, children are processed
4. Array items inherit traversal from parent array's display, but each property inside item has its own display

---

## Component Specifications

### SchemaRenderer (Pure Router)

```tsx
/**
 * SchemaRenderer - Pure type-based router.
 *
 * Routes to:
 * - ArraySchemaRenderer for type: "array"
 * - ObjectSchemaRenderer for type: "object"
 * - TerminalRenderer for primitives
 */
function SchemaRenderer({ data, schema, path = [] }: SchemaRendererProps) {
  // 1. Null/undefined check
  if (data == null) {
    return null;
  }

  // 2. Route by type
  if (schema.type === "array") {
    return <ArraySchemaRenderer data={data} schema={schema} path={path} />;
  }

  if (schema.type === "object") {
    return <ObjectSchemaRenderer data={data} schema={schema} path={path} />;
  }

  // 3. Primitive - terminal render
  return <TerminalRenderer data={data} schema={schema} path={path} />;
}
```

**Lines: ~20**

---

### ArraySchemaRenderer


```tsx
/**
 * ArraySchemaRenderer - Renders arrays with appropriate layout.
 *
 * Responsibilities:
 * - Check display mode
 * - Pick layout based on render_as
 * - Iterate items, call SchemaRenderer for each
 * - Wrap in layout
 */
function ArraySchemaRenderer({ data, schema, path }: ArraySchemaRendererProps) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: don't render
  if (displayMode === "hidden") {
    return null;
  }

  // Validate data is array
  if (!Array.isArray(data)) {
    return <ErrorRenderer message="Expected array" path={path} />;
  }

  // Get items schema
  const itemsSchema = schema.items ?? { type: "object" };

  // Render children
  const children = data.map((item, index) => (
    <SchemaRenderer
      key={index}
      data={item}
      schema={itemsSchema}
      path={[...path, String(index)]}
    />
  ));

  // Passthrough: render children without wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  const Layout = getArrayLayout(schema.render_as);
  return (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );
}

<!--Following (getArrayLayout method) has wrong assumptions, any container can
render either arrays or objects, may be its something we have to figure out as 
well as it constantly  came up layouts cannot render both, and i understand the 
logic why. please explain it to me in simple terms.-->
/**
 * Get layout component for array render_as value.
 */
function getArrayLayout(renderAs: string | undefined): React.FC<LayoutProps> {
  switch (renderAs) {
    case "card-stack":
      return CardStackLayout;
    case "section-list":
      return SectionListLayout;
    default:
      return DefaultArrayLayout;
  }
}
```

**Lines: ~50**

---

### ObjectSchemaRenderer

```tsx
/**
 * ObjectSchemaRenderer - Renders objects with appropriate layout.
 *
 * Responsibilities:
 * - Check display mode
 * - Pick layout based on render_as
 * - Iterate properties, add data-slot wrapper, call SchemaRenderer
 * - Handle selection (if schema.selectable)
 * - Wrap in layout
 */
function ObjectSchemaRenderer({ data, schema, path }: ObjectSchemaRendererProps) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: don't render
  if (displayMode === "hidden") {
    return null;
  }

  // Validate data is object
  if (typeof data !== "object" || data === null) {
    return <ErrorRenderer message="Expected object" path={path} />;
  }

  const dataObj = data as Record<string, unknown>;
  const properties = schema.properties ?? {};

  // Collect renderable properties
  const renderableProps = Object.entries(properties)
    .filter(([key, propSchema]) => {
      const propDisplay = propSchema.display ?? "hidden";
      return propDisplay !== "hidden" && key in dataObj;
    })
    .sort((a, b) => {
      const orderA = a[1].display_order ?? 999;
      const orderB = b[1].display_order ?? 999;
      return orderA - orderB;
    });

  // Render children with data-slot wrappers
  const children = renderableProps.map(([key, propSchema]) => {
    const slot = getSlotFromRenderAs(propSchema.render_as);
    const childPath = [...path, key];

    return (
      <div key={key} data-slot={slot}>
        <SchemaRenderer
          data={dataObj[key]}
          schema={propSchema}
          path={childPath}
        />
      </div>
    );
  });

  // Passthrough: render children without wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout (with selection if applicable)
  const Layout = getObjectLayout(schema.render_as);
  const content = (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );

  // Selection wrapper if selectable
  if (schema.selectable) {
    return (
      <SelectableWrapper schema={schema} path={path} data={data}>
        {content}
      </SelectableWrapper>
    );
  }

  return content;
}

<!--read comment on ArraySchemaRenderer-->
/**
 * Get layout component for object render_as value.
 */
function getObjectLayout(renderAs: string | undefined): React.FC<LayoutProps> {
  switch (renderAs) {
    case "card":
      return CardLayout;
    case "section":
      return SectionLayout;
    default:
      return DefaultObjectLayout;
  }
}

/**
 * Map render_as role to slot name.
 * Role types are render_as values that indicate slot placement.
 */
function getSlotFromRenderAs(renderAs: string | undefined): string {
  switch (renderAs) {
    // Card slots
    case "card-title":
      return "title";
    case "card-subtitle":
      return "subtitle";
    // Section slots
    case "section-title":
      return "title";
    case "section-badge":
      return "badge";
    case "section-summary":
      return "summary";
    // No role = body/content slot
    default:
      return "body";
  }
}
```

**Lines: ~100**

---

### Layout Components (Pure Visual)

Layouts receive children with `data-slot` attributes and group them visually.

```tsx
/**
 * Layout props - same for all layouts.
 */
interface LayoutProps {
  schema: SchemaProperty;
  path: string[];
  data: unknown;
  children: ReactNode;
}

/**
 * Group children by their data-slot attribute.
 */
function groupBySlot(children: ReactNode): Record<string, ReactNode[]> {
  const groups: Record<string, ReactNode[]> = {};

  React.Children.forEach(children, (child) => {
    if (!React.isValidElement(child)) return;

    const slot = (child.props as { "data-slot"?: string })["data-slot"] ?? "body";
    if (!groups[slot]) {
      groups[slot] = [];
    }
    groups[slot].push(child);
  });

  return groups;
}
```

#### CardLayout

```tsx
/**
 * CardLayout - Visual card structure.
 *
 * Slots:
 * - title: Header title
 * - subtitle: Below title
 * - highlight: Prominent fields (future)
 * - body: Main content (default)
 */
function CardLayout({ schema, path, data, children }: LayoutProps) {
  const slots = groupBySlot(children);
  const selectable = useSelectable(path, data, schema);

  // Index from path (last segment if numeric)
  const lastSegment = path[path.length - 1];
  const index = /^\d+$/.test(lastSegment) ? parseInt(lastSegment, 10) : undefined;

  return (
    <div
      className={cn(
        "relative rounded-lg border-2 bg-card/80",
        selectable?.selected && "border-primary bg-primary/5",
        !selectable?.selected && "border-border"
      )}
      onClick={selectable?.handleClick}
    >
      <div className="p-5">
        {/* Index badge */}
        {index !== undefined && (
          <div className="absolute -left-3 -top-3 w-7 h-7 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-bold">
            {index + 1}
          </div>
        )}

        {/* Selection indicator */}
        {selectable?.selected && (
          <div className="absolute top-2 right-2">
            <Check className="h-5 w-5 text-primary" />
          </div>
        )}

        {/* Title */}
        {slots.title && (
          <div className="text-base font-semibold">{slots.title}</div>
        )}

        {/* Subtitle */}
        {slots.subtitle && (
          <div className="mt-1 text-sm text-muted-foreground">{slots.subtitle}</div>
        )}

        {/* Body */}
        {slots.body && (
          <div className="border-t border-border mt-4 pt-4 space-y-3">
            {slots.body}
          </div>
        )}
      </div>
    </div>
  );
}
```

#### CardStackLayout

```tsx
/**
 * CardStackLayout - Vertical stack of cards.
 * Just adds spacing between children.
 */
function CardStackLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No items</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

#### SectionLayout

```tsx
/**
 * SectionLayout - Collapsible section.
 *
 * Slots:
 * - title: Section header
 * - badge: Badge next to title
 * - summary: Below title row
 * - body: Expandable content (default)
 */
function SectionLayout({ schema, children }: LayoutProps) {
  const [expanded, setExpanded] = useState(false);
  const slots = groupBySlot(children);

  return (
    <div className="border-2 border-border rounded-lg border-l-4 border-l-primary/40">
      {/* Header - clickable */}
      <button
        type="button"
        onClick={() => setExpanded(!expanded)}
        className="w-full flex items-start gap-3 p-4 text-left hover:bg-muted/30"
      >
        <ChevronRight className={cn("h-5 w-5 transition-transform", expanded && "rotate-90")} />

        <div className="flex-1">
          {/* Title row */}
          <div className="flex items-center gap-2">
            {slots.title && <span className="font-semibold">{slots.title}</span>}
            {slots.badge && (
              <span className="text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary">
                {slots.badge}
              </span>
            )}
          </div>

          {/* Summary */}
          {slots.summary && (
            <div className="mt-1 text-sm text-muted-foreground">{slots.summary}</div>
          )}
        </div>
      </button>

      {/* Body - expandable */}
      {expanded && slots.body && (
        <div className="px-4 pb-4 border-t border-border pt-4">
          {slots.body}
        </div>
      )}
    </div>
  );
}
```

#### SectionListLayout

```tsx
/**
 * SectionListLayout - Vertical list of sections.
 */
function SectionListLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No sections</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

---

## render_as Classification

`render_as` values fall into two categories:

### Container Types (for Arrays)

Used by ArraySchemaRenderer to pick layout:

| Value | Layout | Description |
|-------|--------|-------------|
| `card-stack` | CardStackLayout | Vertical stack with card styling per item |
| `section-list` | SectionListLayout | Vertical list of collapsible sections |
| (default) | DefaultArrayLayout | Simple vertical list |

### Container Types (for Objects)

Used by ObjectSchemaRenderer to pick layout:

| Value | Layout | Description |
|-------|--------|-------------|
| `card` | CardLayout | Card with slots (title, subtitle, body) |
| `section` | SectionLayout | Collapsible section with slots |
| (default) | DefaultObjectLayout | Simple vertical stack of fields |

### Role Types (Slot Hints)

Used by ObjectSchemaRenderer to set `data-slot`:

| Value | Slot | Used In |
|-------|------|---------|
| `card-title` | title | CardLayout |
| `card-subtitle` | subtitle | CardLayout |
| `section-title` | title | SectionLayout |
| `section-badge` | badge | SectionLayout |
| `section-summary` | summary | SectionLayout |
| (default) | body | All layouts |

---

## Terminal Rendering

### TerminalRenderer

Handles primitive values and applies render_as styling.

```tsx
/**
 * TerminalRenderer - Renders primitive values.
 *
 * render_as values for terminals:
 * - text (default)
 * - color
 * - url
 * - datetime
 * - number
 * - image
 */
function TerminalRenderer({ data, schema, path }: TerminalRendererProps) {
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  // Handle display_format template
  if (schema.display_format) {
    const formatted = renderTemplate(schema.display_format, data);
    return <TextRenderer value={formatted} label={schema.display_label} />;
  }

  // Route by render_as
  switch (schema.render_as) {
    case "color":
      return <ColorRenderer value={data} label={schema.display_label} />;
    case "url":
      return <UrlRenderer value={data} label={schema.display_label} />;
    case "datetime":
      return <DateTimeRenderer value={data} label={schema.display_label} />;
    case "number":
      return <NumberRenderer value={data} label={schema.display_label} />;
    case "image":
      return <ImageRenderer value={data} label={schema.display_label} />;
    default:
      return <TextRenderer value={String(data)} label={schema.display_label} />;
  }
}
```

---

## Data Flow Example

### Schema

```json
{
  "type": "array",
  "render_as": "card-stack",
  "display": "visible",
  "items": {
    "type": "object",
    "render_as": "card",
    "display": "visible",
    "selectable": true,
    "properties": {
      "name": {
        "type": "string",
        "render_as": "card-title",
        "display": "visible"
      },
      "description": {
        "type": "string",
        "render_as": "card-subtitle",
        "display": "visible"
      },
      "details": {
        "type": "string",
        "display": "visible",
        "display_label": "Details"
      }
    }
  }
}
```

### Data

```json
[
  { "name": "Item 1", "description": "First item", "details": "Some details" },
  { "name": "Item 2", "description": "Second item", "details": "More details" }
]
```

### Render Flow

```
SchemaRenderer(data=[...], schema={type:"array"})
  │
  └─► ArraySchemaRenderer
        │
        ├─ display="visible" ✓
        ├─ render_as="card-stack" → CardStackLayout
        │
        └─ For each item:
             │
             └─► SchemaRenderer(data={name,desc,details}, schema={type:"object"})
                   │
                   └─► ObjectSchemaRenderer
                         │
                         ├─ display="visible" ✓
                         ├─ render_as="card" → CardLayout
                         ├─ selectable=true → wrap in SelectableWrapper
                         │
                         └─ For each property:
                              │
                              ├─ name: data-slot="title"
                              │    └─► SchemaRenderer → TerminalRenderer → "Item 1"
                              │
                              ├─ description: data-slot="subtitle"
                              │    └─► SchemaRenderer → TerminalRenderer → "First item"
                              │
                              └─ details: data-slot="body"
                                   └─► SchemaRenderer → TerminalRenderer → "Some details"
```

### Rendered Output

```
CardStackLayout
  └─ CardLayout (selectable, index=0)
       ├─ [title slot] "Item 1"
       ├─ [subtitle slot] "First item"
       └─ [body slot] "Details: Some details"
  └─ CardLayout (selectable, index=1)
       ├─ [title slot] "Item 2"
       ├─ [subtitle slot] "Second item"
       └─ [body slot] "Details: More details"
```

---

## Nested Containers Example

Section containing card-stack (the case that required `isWrapper` hack):

### Schema

```json
{
  "type": "array",
  "render_as": "section-list",
  "display": "visible",
  "items": {
    "type": "object",
    "render_as": "section",
    "display": "visible",
    "properties": {
      "title": {
        "type": "string",
        "render_as": "section-title",
        "display": "visible"
      },
      "ideas": {
        "type": "array",
        "render_as": "card-stack",
        "display": "visible",
        "items": { ... }
      }
    }
  }
}
```

### Render Flow

```
ArraySchemaRenderer (section-list)
  │
  └─ For each section:
       │
       └─► ObjectSchemaRenderer (section)
             │
             ├─ title: data-slot="title"
             │    └─► TerminalRenderer
             │
             └─ ideas: data-slot="body"
                  │
                  └─► ArraySchemaRenderer (card-stack) ← NESTED CONTAINER
                        │
                        └─ CardStackLayout
                             └─ CardLayout per item
```

**Key insight**: The `ideas` property has `render_as: "card-stack"`, so when ObjectSchemaRenderer calls SchemaRenderer for it, SchemaRenderer routes to ArraySchemaRenderer, which picks CardStackLayout.

No `isWrapper` hack needed. The nested container renders itself naturally.

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx              # Pure router (~20 lines)
├── ArraySchemaRenderer.tsx         # Array handler (~50 lines)
├── ObjectSchemaRenderer.tsx        # Object handler (~100 lines)
├── TerminalRenderer.tsx            # Primitive handler (~60 lines)
├── SelectableWrapper.tsx           # Selection UI wrapper
├── useSelectable.ts                # Selection hook
├── layouts/
│   ├── index.ts                    # Layout exports
│   ├── types.ts                    # LayoutProps interface
│   ├── groupBySlot.ts              # Slot grouping utility
│   ├── CardLayout.tsx              # Card visual (~60 lines)
│   ├── CardStackLayout.tsx         # Card stack (~15 lines)
│   ├── SectionLayout.tsx           # Section visual (~70 lines)
│   ├── SectionListLayout.tsx       # Section list (~15 lines)
│   ├── DefaultArrayLayout.tsx      # Default array (~15 lines)
│   └── DefaultObjectLayout.tsx     # Default object (~20 lines)
├── terminals/
│   ├── TextRenderer.tsx
│   ├── ColorRenderer.tsx
│   ├── UrlRenderer.tsx
│   └── ... (existing)
└── helpers/
    └── renderTemplate.ts           # Template string rendering
```

---

## Line Count Comparison

| Component | Current | Proposed |
|-----------|---------|----------|
| SchemaRenderer.tsx | ~400 | ~20 |
| extractInnerData.ts | ~180 | REMOVED |
| renderer-types.ts | ~140 | ~30 (LayoutProps only) |
| getRenderer.ts | ~80 | REMOVED (inline in Array/Object) |
| ArraySchemaRenderer.tsx | NEW | ~50 |
| ObjectSchemaRenderer.tsx | NEW | ~100 |
| CardStackRenderer.tsx | ~42 | REMOVED (→ CardStackLayout ~15) |
| CardRenderer.tsx | ~184 | REMOVED (→ CardLayout ~60) |
| SectionListRenderer.tsx | ~42 | REMOVED (→ SectionListLayout ~15) |
| SectionRenderer.tsx | ~168 | REMOVED (→ SectionLayout ~70) |
| **Total affected** | **~1236** | **~360** |

**Reduction: ~70%**

---

## Migration Plan

### Phase 1: Create New Structure

1. Create `ArraySchemaRenderer.tsx`
2. Create `ObjectSchemaRenderer.tsx`
3. Create `layouts/` folder with all layouts
4. Create `layouts/groupBySlot.ts` utility

### Phase 2: Simplify SchemaRenderer

1. Remove all logic except type routing
2. Remove strictMode
3. Remove renderer prop
4. Route to Array/Object/Terminal

### Phase 3: Update Display Values

1. Add TypeScript type for DisplayMode
2. Update schema interpretation (`true` → `"visible"`, etc.)
3. Test with existing schemas

### Phase 4: Remove Old Code

1. Delete `extractInnerData.ts`
2. Delete `getRenderer.ts`
3. Delete old renderer files
4. Delete `renderer-types.ts` (keep LayoutProps in layouts/types.ts)

### Phase 5: Test All Workflows

1. Test OMS step 1 (card-stack selections)
2. Test nested containers (section-list with card-stack)
3. Test selection behavior
4. Test passthrough display mode

---

## Questions for Review

1. **additionalProperties handling**: Should ObjectSchemaRenderer handle `additionalProperties` for dynamic keys, or is that a separate concern?
<!--ObjectSchemaRenderer should handle it, i wonder why you asked me this question-->

2. **Computed fields**: Should ObjectSchemaRenderer handle `computed` fields, or remove that feature?
<!--computed fields must be handled, and i dont see any other place than ObjectSchemaRenderer to handle them-->

3. **Selection on arrays**: Currently selection is on items. Should ArraySchemaRenderer ever have selection on the array itself?
<!--Currently (at least for my knowlege) if given node has selectable=true, we wrap it with default wrapper, for containers, it can wrap its own way. but it must be handle one way or another.-->

4. **Highlight slot**: Current CardRenderer has a highlight slot. Should we keep it, or simplify to just title/subtitle/body?
<!--highlight should be handled in both section-list and card-stack. not sure it delegated to Card to handle it though-->

---

## Issue to Create

**Debug Mode for WebUI**

When debug mode is enabled:
- Show role type warnings inline (e.g., "card-title used outside card context")
- Show display mode indicators
- Show slot assignments visually

When debug mode is disabled:
- Render normally, no warnings in UI
- Warnings only in console (if at all)

This is a future enhancement, not part of this refactor.
