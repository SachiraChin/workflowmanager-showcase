# SchemaRenderer Simplification Architecture - Revision 4

## Summary

This revision finalizes the architecture based on operator feedback:

1. **No Field pattern** - Schemas must explicitly specify `render_as` on items
2. **Unified layout registry** - Registration-based lookup for all layouts
3. **Explicit display modes** - `visible`, `hidden`, `passthrough`
4. **Container-owned selection** - Containers handle their own selection UI
5. **Plural slots** - Each child wrapped individually, not grouped
6. **card-content as wrapper layout** - Special handling for single-value cards
7. **highlight as flag** - Not a render_as value, can combine with roles

---

## Core Principles

### 1. Schemas Are Explicit

No implicit defaults. If you want items rendered as cards, say so:

```json
{
  "type": "array",
  "render_as": "card-stack",
  "display": "visible",
  "items": {
    "type": "object",
    "render_as": "card",      // REQUIRED - no Field fallback
    "display": "visible",
    "properties": { ... }
  }
}
```

**Why:** Eliminates the confusing Field pattern where parent controls child rendering implicitly.

### 2. Layouts Are Data-Agnostic

Any layout can render any data type. `getLayout()` is unified:

```tsx
// Registration-based lookup
const layoutRegistry: Record<string, React.FC<LayoutProps>> = {};

function registerLayout(key: string, component: React.FC<LayoutProps>) {
  layoutRegistry[key] = component;
}

function getLayout(renderAs: string | undefined): React.FC<LayoutProps> {
  return layoutRegistry[renderAs ?? "default"] ?? DefaultLayout;
}
```

### 3. Display Is Explicit

```typescript
type DisplayMode = "visible" | "hidden" | "passthrough";
```

| Value | Meaning | Default |
|-------|---------|---------|
| `visible` | Render this node | - |
| `hidden` | Skip this node entirely | YES (default) |
| `passthrough` | Don't render self, but render children | - |

### 4. Containers Own Selection

Containers handle selection internally. No external `SelectableWrapper` imposed by parent.

```tsx
function CardLayout({ schema, path, data, children }: LayoutProps) {
  // Container decides if/how to handle selection
  const selectable = useSelectable(path, data, schema);

  return (
    <div
      className={cn("card", selectable?.selected && "selected")}
      onClick={selectable?.handleClick}
    >
      {selectable && <SelectionIndicator {...selectable} />}
      {children}
    </div>
  );
}
```

### 5. Slots Are Plural

Containers wrap EACH child in a slot individually:

```tsx
// CORRECT - each child wrapped
{slots.title?.map((child, i) => (
  <div key={i} className="title-item">{child}</div>
))}

// WRONG - all children in one wrapper
{slots.title && <div className="title-slot">{slots.title}</div>}
```

**Why:** Schema author might have 2 title fields, 5 summary fields. We can't prevent that, so we handle it.

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SchemaRenderer (Pure Router)                         │
│                                                                              │
│  1. Check null/undefined → return null                                       │
│  2. Route by schema.type → Array/Object/Terminal                             │
│                                                                              │
│  ~20 lines                                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              ▼                       ▼                       ▼
┌─────────────────────────┐ ┌─────────────────────────┐ ┌─────────────────────┐
│  ArraySchemaRenderer    │ │  ObjectSchemaRenderer   │ │   TerminalRenderer  │
│                         │ │                         │ │                     │
│  - Check display mode   │ │  - Check display mode   │ │  - Check display    │
│  - Get layout           │ │  - Get layout           │ │  - Render primitive │
│  - Iterate items        │ │  - Iterate properties   │ │  - Handle nudges    │
│  - Call SchemaRenderer  │ │  - Add data-slot        │ │                     │
│    for each item        │ │  - Handle computed      │ │                     │
│                         │ │  - Handle additional    │ │                     │
│  ~60 lines              │ │  ~120 lines             │ │  ~60 lines          │
└─────────────────────────┘ └─────────────────────────┘ └─────────────────────┘
              │                       │
              └───────────┬───────────┘
                          ▼
              ┌─────────────────────────┐
              │   getLayout(render_as)  │
              │   Registration-based    │
              └─────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Layouts                                         │
│                                                                              │
│  - Receive children (ReactNode) with data-slot attributes                   │
│  - Group by data-slot, wrap EACH child individually                         │
│  - Handle selection internally (useSelectable)                               │
│  - NO parent-imposed wrapping                                                │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Component Specifications

### SchemaRenderer

```tsx
/**
 * SchemaRenderer - Pure type-based router.
 * Routes to ArraySchemaRenderer, ObjectSchemaRenderer, or TerminalRenderer.
 */
function SchemaRenderer({ data, schema, path = [] }: SchemaRendererProps) {
  // 1. Null/undefined
  if (data == null) {
    return null;
  }

  // 2. Route by type
  if (schema.type === "array") {
    return <ArraySchemaRenderer data={data} schema={schema} path={path} />;
  }

  if (schema.type === "object") {
    return <ObjectSchemaRenderer data={data} schema={schema} path={path} />;
  }

  // 3. Primitive
  return <TerminalRenderer data={data} schema={schema} path={path} />;
}
```

---

### ArraySchemaRenderer

```tsx
/**
 * ArraySchemaRenderer - Handles arrays.
 *
 * - Checks display mode
 * - Gets layout from render_as (registration-based)
 * - Iterates items, calls SchemaRenderer for each
 * - Layout handles selection internally
 */
function ArraySchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: skip entirely
  if (displayMode === "hidden") {
    return null;
  }

  // Validate
  if (!Array.isArray(data)) {
    return <ErrorRenderer message="Expected array" path={path} />;
  }

  const itemsSchema = schema.items ?? { type: "object", display: "visible" };

  // Render children
  const children = data.map((item, index) => (
    <SchemaRenderer
      key={index}
      data={item}
      schema={itemsSchema}
      path={[...path, String(index)]}
    />
  ));

  // Passthrough: children without layout wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  // Layout handles selection internally via useSelectable
  const Layout = getLayout(schema.render_as);
  return (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );
}
```

---

### ObjectSchemaRenderer

```tsx
/**
 * ObjectSchemaRenderer - Handles objects.
 *
 * - Checks display mode
 * - Gets layout from render_as (registration-based)
 * - Iterates properties (including additionalProperties and computed)
 * - Adds data-slot to each child based on role
 * - Handles card-content specially (wrapper layout)
 * - Layout handles selection internally
 */
function ObjectSchemaRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  // Hidden: skip entirely
  if (displayMode === "hidden") {
    return null;
  }

  // Validate
  if (typeof data !== "object" || data === null) {
    return <ErrorRenderer message="Expected object" path={path} />;
  }

  const dataObj = data as Record<string, unknown>;
  const properties = schema.properties ?? {};
  const additionalProps = schema.additionalProperties;
  const computed = schema.computed ?? {};

  // Collect renderable items
  const items: RenderableItem[] = [];

  // 1. Regular properties
  for (const [key, propSchema] of Object.entries(properties)) {
    const propDisplay = propSchema.display ?? "hidden";
    if (propDisplay !== "hidden" && key in dataObj) {
      items.push({
        key,
        value: dataObj[key],
        schema: propSchema,
      });
    }
  }

  // 2. Additional properties (dynamic keys)
  if (additionalProps && typeof additionalProps === "object") {
    for (const key of Object.keys(dataObj)) {
      if (!(key in properties)) {
        const addSchema = additionalProps as SchemaProperty;
        const addDisplay = addSchema.display ?? "hidden";
        if (addDisplay !== "hidden") {
          items.push({
            key,
            value: dataObj[key],
            schema: addSchema,
          });
        }
      }
    }
  }

  // 3. Computed fields (virtual)
  for (const [key, compSchema] of Object.entries(computed)) {
    const compDisplay = compSchema.display ?? "hidden";
    if (compDisplay !== "hidden" && compSchema.display_format) {
      items.push({
        key,
        value: dataObj,  // Whole object for template
        schema: compSchema,
      });
    }
  }

  // Sort by display_order
  items.sort((a, b) => (a.schema.display_order ?? 999) - (b.schema.display_order ?? 999));

  // Render children with data-slot wrappers
  const children = items.map(({ key, value, schema: itemSchema }) => {
    const childPath = [...path, key];

    <!--remove this, we will come to this later, no speical handling for now.-->
    // Special case: card-content is a wrapper layout
    if (itemSchema.render_as === "card-content") {
      return (
        <CardContentLayout key={key} schema={itemSchema}>
          <SchemaRenderer
            data={value}
            schema={{ ...itemSchema, render_as: undefined }}
            path={childPath}
          />
        </CardContentLayout>
      );
    }

    // Normal case: add data-slot wrapper
    const slot = getSlotFromRole(itemSchema.render_as, itemSchema.highlight);
    return (
      <div key={key} data-slot={slot}>
        <SchemaRenderer
          data={value}
          schema={itemSchema}
          path={childPath}
        />
      </div>
    );
  });

  // Passthrough: children without layout wrapper
  if (displayMode === "passthrough") {
    return <>{children}</>;
  }

  // Visible: wrap in layout
  // Layout handles selection internally via useSelectable
  const Layout = getLayout(schema.render_as);
  return (
    <Layout schema={schema} path={path} data={data}>
      {children}
    </Layout>
  );
}

/**
 * Map role type and highlight flag to slot name.
 */
function getSlotFromRole(renderAs: string | undefined, highlight?: boolean): string {
  <!--isnt this overriding role? i thought we were going to handle these separately. actually, 
  now looking at your use of attribute, rather than filter and fill, we should just include
  all meta fields in schema to div wraping children node, and parent can query and place them.
  this analyzing and placing them feels like asking for mess when new roles are being added.
  is it possible to add meta fields as is with same key or it has to be prefixed by data-?
  when i said meta fields, i what i meant was all fields we use to render, like render_as, 
  highlight, highlight_color, display_label, description, etc, all and any rendering related meta field.

  i feel like this could solve card-content issue as well.
  -->
  // Highlight flag takes precedence (can combine with role)
  if (highlight === true) {
    return "highlight";
  }

  switch (renderAs) {
    case "card-title":
    case "section-title":
      return "title";
    case "card-subtitle":
    case "section-summary":
      return "subtitle";
    case "section-badge":
      return "badge";
    default:
      return "body";
  }
}
```

---

### TerminalRenderer

```tsx
/**
 * TerminalRenderer - Handles primitives.
 *
 * - Checks display mode
 * - Handles display_format templates
 * - Routes to specific renderers (text, color, url, etc.)
 */
function TerminalRenderer({ data, schema, path }: Props) {
  const displayMode = schema.display ?? "hidden";

  if (displayMode === "hidden") {
    return null;
  }

  // Handle display_format template
  if (schema.display_format) {
    const formatted = renderTemplate(schema.display_format, data);
    return <TextRenderer value={formatted} label={schema.display_label} />;
  }

  // Route by render_as
  switch (schema.render_as) {
    case "color":
      return <ColorRenderer value={data} label={schema.display_label} />;
    case "url":
      return <UrlRenderer value={data} label={schema.display_label} />;
    case "datetime":
      return <DateTimeRenderer value={data} label={schema.display_label} />;
    case "number":
      return <NumberRenderer value={data} label={schema.display_label} />;
    case "image":
      return <ImageRenderer value={data} label={schema.display_label} />;
    default:
      return <TextRenderer value={String(data)} label={schema.display_label} />;
  }
}
```

---

## Layout Specifications

### Layout Interface

```tsx
interface LayoutProps {
  schema: SchemaProperty;
  path: string[];
  data: unknown;
  children: ReactNode;
}

// All layouts receive same props
// Layouts handle selection via useSelectable internally
// Layouts group children by data-slot and wrap EACH child
```

### Slot Grouping Utility

```tsx
/**
 * Group children by data-slot attribute.
 * Returns arrays (plural) for each slot.
 */
function groupBySlot(children: ReactNode): Record<string, ReactNode[]> {
  const groups: Record<string, ReactNode[]> = {};

  React.Children.forEach(children, (child) => {
    if (!React.isValidElement(child)) return;

    const slot = (child.props as { "data-slot"?: string })["data-slot"] ?? "body";
    if (!groups[slot]) {
      groups[slot] = [];
    }
    groups[slot].push(child);
  });

  return groups;
}
```

### CardLayout

```tsx
registerLayout("card", CardLayout);

function CardLayout({ schema, path, data, children }: LayoutProps) {
  const slots = groupBySlot(children);
  const selectable = useSelectable(path, data, schema);

  // Index from path (for numbered cards in array)
  const index = getIndexFromPath(path);

  return (
    <div
      className={cn(
        "relative rounded-lg border-2 bg-card/80",
        selectable?.selected ? "border-primary bg-primary/5" : "border-border",
        selectable && "cursor-pointer"
      )}
      onClick={selectable?.handleClick}
    >
      <div className="p-5">
        {/* Index badge */}
        {index !== undefined && (
          <div className="absolute -left-3 -top-3 w-7 h-7 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-bold">
            {index + 1}
          </div>
        )}

        {/* Selection indicator */}
        {selectable?.selected && (
          <div className="absolute top-2 right-2">
            <Check className="h-5 w-5 text-primary" />
          </div>
        )}

        {/* Title slot - wrap EACH child */}
        {slots.title?.map((child, i) => (
          <div key={i} className="text-base font-semibold">{child}</div>
        ))}

        {/* Subtitle slot - wrap EACH child */}
        {slots.subtitle?.map((child, i) => (
          <div key={i} className="mt-1 text-sm text-muted-foreground">{child}</div>
        ))}

        {/* Highlight slot - wrap EACH child */}
        {slots.highlight?.map((child, i) => (
          <span key={i} className="inline-block mt-2 mr-2 px-2 py-0.5 rounded-md bg-teal-600/10 text-teal-600 text-sm font-medium">
            {child}
          </span>
        ))}

        {/* Body slot - wrap EACH child */}
        {slots.body && slots.body.length > 0 && (
          <div className="border-t border-border mt-4 pt-4 space-y-3">
            {slots.body.map((child, i) => (
              <div key={i}>{child}</div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

### CardStackLayout

```tsx
registerLayout("card-stack", CardStackLayout);

function CardStackLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No items</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

### SectionLayout

```tsx
registerLayout("section", SectionLayout);

function SectionLayout({ schema, path, data, children }: LayoutProps) {
  const [expanded, setExpanded] = useState(false);
  const slots = groupBySlot(children);

  return (
    <div className="border-2 border-border rounded-lg border-l-4 border-l-primary/40">
      {/* Header - clickable */}
      <button
        type="button"
        onClick={() => setExpanded(!expanded)}
        className="w-full flex items-start gap-3 p-4 text-left hover:bg-muted/30"
      >
        <ChevronRight className={cn("h-5 w-5 transition-transform", expanded && "rotate-90")} />

        <div className="flex-1">
          {/* Title row - wrap EACH child inline */}
          <div className="flex items-center gap-2 flex-wrap">
            {slots.title?.map((child, i) => (
              <span key={i} className="font-semibold">{child}</span>
            ))}
            {slots.badge?.map((child, i) => (
              <span key={i} className="text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary">
                {child}
              </span>
            ))}
          </div>

          {/* Subtitle - wrap EACH child */}
          {slots.subtitle?.map((child, i) => (
            <div key={i} className="mt-1 text-sm text-muted-foreground">{child}</div>
          ))}

          {/* Highlight - wrap EACH child */}
          {slots.highlight?.map((child, i) => (
            <span key={i} className="inline-block mt-2 mr-2 px-2 py-0.5 rounded-md bg-amber-600/10 text-amber-600 text-sm font-medium">
              {child}
            </span>
          ))}
        </div>
      </button>

      {/* Body - expandable */}
      {expanded && slots.body && slots.body.length > 0 && (
        <div className="px-4 pb-4 border-t border-border pt-4 space-y-4">
          {slots.body.map((child, i) => (
            <div key={i}>{child}</div>
          ))}
        </div>
      )}
    </div>
  );
}
```

### SectionListLayout

```tsx
registerLayout("section-list", SectionListLayout);

function SectionListLayout({ children }: LayoutProps) {
  const hasChildren = React.Children.count(children) > 0;

  if (!hasChildren) {
    return <div className="text-center text-muted-foreground py-4">No sections</div>;
  }

  return <div className="flex flex-col gap-3">{children}</div>;
}
```

### CardContentLayout

```tsx
/**
 * CardContentLayout - Wrapper for single values rendered as cards.
 *
 * Takes a primitive value and renders it as a card with:
 * - display_label as header
 * - value as body
 */
registerLayout("card-content", CardContentLayout);

function CardContentLayout({ schema, children }: { schema: SchemaProperty; children: ReactNode }) {
  return (
    <div className="rounded-lg border-2 border-border bg-card/80">
      <div className="p-4">
        {schema.display_label && (
          <div className="text-sm font-semibold text-muted-foreground mb-2">
            {schema.display_label}
          </div>
        )}
        <div>{children}</div>
      </div>
    </div>
  );
}
```

### DefaultLayout

```tsx
registerLayout("default", DefaultLayout);

function DefaultLayout({ children }: LayoutProps) {
  return <div className="space-y-2">{children}</div>;
}
```

---

## render_as Classification

### Container Layouts

Applied via `getLayout()` - any type can use any layout:

| Value | Component | Description |
|-------|-----------|-------------|
| `card-stack` | CardStackLayout | Vertical stack with gap |
| `section-list` | SectionListLayout | Vertical list with gap |
| `card` | CardLayout | Bordered card with slots, selection |
| `section` | SectionLayout | Collapsible section with slots |
| `card-content` | CardContentLayout | Single value as card (wrapper) |
| (default) | DefaultLayout | Simple container |

### Role Types (Slot Assignment)

Mapped via `getSlotFromRole()`:

| Value | Slot | Description |
|-------|------|-------------|
| `card-title` | title | Primary heading |
| `section-title` | title | Primary heading |
| `card-subtitle` | subtitle | Secondary text |
| `section-summary` | subtitle | Secondary text |
| `section-badge` | badge | Inline badge |
| (none) | body | Default content |

### Terminal Types

Handled by TerminalRenderer:

| Value | Renderer | Description |
|-------|----------|-------------|
| `text` | TextRenderer | Plain text |
| `color` | ColorRenderer | Color swatch + hex |
| `url` | UrlRenderer | Clickable link |
| `datetime` | DateTimeRenderer | Formatted date/time |
| `number` | NumberRenderer | Formatted number |
| `image` | ImageRenderer | Image display |

### Special Flags

| Flag | Effect |
|------|--------|
| `highlight: true` | Assigns to "highlight" slot (can combine with role) |
| `selectable: true` | Layout handles selection via useSelectable |
| `display: "passthrough"` | Render children without wrapper |

---

## Schema Migration Required

### Arrays Needing Item `render_as` (6 changes)

| Workflow | File | Change |
|----------|------|--------|
| OMS | aesthetic_display_schema.json | Add `items.render_as: "section"` |
| OMS | paragraph_display_schema.json | Add nested `items.render_as: "card"` |
| CC | cc_text_overlays_display_schema.json | Add `items.render_as: "section"` |
| CC | cc_music_options_display_schema.json | Add `items.render_as: "section"` |
| CC | cc_image_prompts_display_schema.json | Refactor (section-list on object) |
| CC | cc_video_prompts_display_schema.json | Refactor (section-list on object) |

### Objects Needing `display: "passthrough"` (9 changes)

| Workflow | File | Path |
|----------|------|------|
| OMS | leonardo_display_schema.json | `properties.prompts` |
| OMS | midjourney_display_schema.json | `properties.prompts` |
| OMS | sora_display_schema.json | `properties.prompts` |
| OMS | stable_diffusion_display_schema.json | `properties.prompts` |
| OMS | midjourney_animate_display_schema.json | `properties.prompts` |
| OMS | motion_2_0_display_schema.json | `properties.prompts` |
| OMS | color_display_schema.json | `properties.themes.items` |
| CC | cc_image_prompts_display_schema.json | `properties.prompts` |
| CC | cc_video_prompts_display_schema.json | `properties.prompts` |

---

## File Structure

```
schema-interaction/
├── SchemaRenderer.tsx              # Pure router (~20 lines)
├── ArraySchemaRenderer.tsx         # Array handler (~60 lines)
├── ObjectSchemaRenderer.tsx        # Object handler (~120 lines)
├── TerminalRenderer.tsx            # Primitive handler (~60 lines)
├── useSelectable.ts                # Selection hook (existing)
├── layouts/
│   ├── index.ts                    # Registry + getLayout + registerLayout
│   ├── types.ts                    # LayoutProps
│   ├── groupBySlot.ts              # Slot grouping utility
│   ├── CardLayout.tsx              # ~80 lines
│   ├── CardStackLayout.tsx         # ~15 lines
│   ├── CardContentLayout.tsx       # ~25 lines
│   ├── SectionLayout.tsx           # ~90 lines
│   ├── SectionListLayout.tsx       # ~15 lines
│   └── DefaultLayout.tsx           # ~10 lines
├── terminals/
│   ├── TextRenderer.tsx
│   ├── ColorRenderer.tsx
│   └── ... (existing)
└── types.ts                        # SchemaProperty, DisplayMode
```

---

## Line Count Estimate

| Component | Lines |
|-----------|-------|
| SchemaRenderer.tsx | ~20 |
| ArraySchemaRenderer.tsx | ~60 |
| ObjectSchemaRenderer.tsx | ~120 |
| TerminalRenderer.tsx | ~60 |
| layouts/index.ts | ~20 |
| layouts/types.ts | ~15 |
| layouts/groupBySlot.ts | ~20 |
| layouts/CardLayout.tsx | ~80 |
| layouts/CardStackLayout.tsx | ~15 |
| layouts/CardContentLayout.tsx | ~25 |
| layouts/SectionLayout.tsx | ~90 |
| layouts/SectionListLayout.tsx | ~15 |
| layouts/DefaultLayout.tsx | ~10 |
| **Total** | **~550** |

Current implementation: ~1200+ lines

**Reduction: ~55%** (with much cleaner architecture)

---

## Implementation Plan

### Phase 1: Create New Structure

1. Create `layouts/` folder with registry
2. Create `groupBySlot.ts` utility
3. Create layout components (Card, CardStack, Section, SectionList, CardContent, Default)
4. Create `ArraySchemaRenderer.tsx`
5. Create `ObjectSchemaRenderer.tsx`
6. Simplify `SchemaRenderer.tsx` to pure router

### Phase 2: Update Display Schemas

1. Add missing `render_as` to array items (6 schemas)
2. Add `display: "passthrough"` to structural objects (9 schemas)
3. Refactor CC schemas using section-list on objects (2 schemas)

### Phase 3: TUI Adapter

1. Create adapter to interpret new display values
2. Map `"visible"` → current true handling
3. Map `"passthrough"` → traverse children without wrapper
4. Map `"hidden"` → skip (default)

### Phase 4: Cleanup

1. Remove old renderer files
2. Remove Field from Renderer interface
3. Remove isWrapper hack
4. Remove strictMode
5. Update types

### Phase 5: Testing

1. Test all OMS steps
2. Test all CC steps
3. Verify selection works in all containers
4. Verify nested containers (section with card-stack inside)
5. Verify card-content renders correctly

---

## Summary of Changes from R3

| Aspect | R3 | R4 |
|--------|----|----|
| Field pattern | Discussed options | Eliminated - schemas explicit |
| Schema changes | Not counted | 15 changes identified |
| Selection | External wrapper option | Container-owned only |
| Slots | Implied singular | Explicit plural wrapping |
| card-content | Discussed | Defined as wrapper layout |
| highlight | Unclear | Flag that maps to slot |
| Implementation plan | Not included | Phased plan included |
