# Shared Package - State Handling Strategy (r2.2)

## The Problem

The rendering system (`SchemaRenderer` and children) needs access to:
1. **Template state** - For Jinja2/Nunjucks rendering (`{{ state.foo }}`)
2. **Debug mode** - For edit buttons in debug mode
3. **Workflow store** - For updating interaction data in debug mode

These are currently accessed via:
- `useWorkflowStateContext()` - Template state
- `useWorkflowStore()` - Zustand store
- `getDebugMode()` - localStorage flag

## Complete State Access Analysis

After thorough analysis, here are all files that access webui state:

### Files with State Dependencies (Need Adapter)

| File | State Access | Purpose |
|------|-------------|---------|
| `SchemaRenderer.tsx` | `useWorkflowStateContext`, `useWorkflowStore`, `getDebugMode` | Template state, debug editing |
| `ObjectSchemaRenderer.tsx` | `useWorkflowStateContext` | Template state for computed fields |
| `InputSchemaComposer.tsx` | `useWorkflowStateContext`, `getDebugMode` | Template state for source_data, debug sync |
| `InteractionHost.tsx` | `useDebugMode`, `useWorkflowStore` | Debug editing of display_data |
| `SubActionProvider` | `api`, `useWorkflowStore` | Sub-action execution |

### Files with NO State Dependencies (Clean to Move)

All other files in `interactions/` have no external state dependencies.

## Solution: Context Adapter Pattern

Two adapters needed:

1. **RenderContext** - For template rendering and debug mode
2. **SubActionAdapter** - For sub-action execution (injectable)

## Adapter 1: RenderContext

### Interface Definition (in shared)

```typescript
// shared/src/contexts/RenderContext.tsx

export interface RenderContextValue {
  /** State for template rendering ({{ state.foo }}) */
  templateState: Record<string, unknown>;
  
  /** Whether debug mode is enabled */
  debugMode: boolean;
  
  /** Callback to update display data (debug mode only) */
  onUpdateDisplayData?: (path: string[], data: unknown, schema: unknown) => void;
}

const defaultContext: RenderContextValue = {
  templateState: {},
  debugMode: false,
  onUpdateDisplayData: undefined,
};
```

### Files that use RenderContext

- `SchemaRenderer.tsx`
- `ObjectSchemaRenderer.tsx`
- `InputSchemaComposer.tsx`

## Adapter 2: SubActionAdapter

### Current SubActionProvider Dependencies

```typescript
// Current implementation uses:
const workflowRunId = useWorkflowStore((s) => s.workflowRunId);
const selectedProvider = useWorkflowStore((s) => s.selectedProvider);
const selectedModel = useWorkflowStore((s) => s.selectedModel);
api.streamSubAction(workflowRunId, request, handleEvent, handleError);
```

### Interface Definition (in shared)

```typescript
// shared/src/contexts/SubActionContext.tsx

export interface SubActionExecutor {
  /**
   * Execute a sub-action and stream results.
   * @param subActionId - The sub-action ID
   * @param params - Parameters for the sub-action
   * @param onProgress - Progress callback
   * @param onComplete - Completion callback with result
   * @param onError - Error callback
   */
  execute: (
    subActionId: string,
    params: Record<string, unknown>,
    callbacks: {
      onProgress?: (message: string) => void;
      onComplete?: (result: unknown) => void;
      onError?: (error: string) => void;
    }
  ) => void;
}

export interface SubActionContextConfig {
  /** Sub-action definitions from display_data */
  subActions: SubActionDef[];
  /** Executor implementation (webui provides real, editor provides mock) */
  executor?: SubActionExecutor;
  /** Called when sub-action completes */
  onComplete?: () => void;
}
```

### webui Implementation

```typescript
// webui/src/adapters/WebUISubActionExecutor.ts

export function createWebUISubActionExecutor(
  workflowRunId: string,
  interactionId: string,
  aiConfig?: { provider?: string; model?: string }
): SubActionExecutor {
  return {
    execute: (subActionId, params, callbacks) => {
      const request = {
        interaction_id: interactionId,
        sub_action_id: subActionId,
        params,
        ai_config: aiConfig,
      };
      
      api.streamSubAction(workflowRunId, request, (eventType, data) => {
        switch (eventType) {
          case "progress":
            callbacks.onProgress?.(data.message as string);
            break;
          case "complete":
            callbacks.onComplete?.(data);
            break;
          case "error":
            callbacks.onError?.(data.message as string);
            break;
        }
      }, (err) => {
        callbacks.onError?.(err.message);
      });
    },
  };
}
```

### Editor Mock Implementation

```typescript
// editor/src/adapters/MockSubActionExecutor.ts

export function createMockSubActionExecutor(
  mockResults: Record<string, unknown>
): SubActionExecutor {
  return {
    execute: (subActionId, params, callbacks) => {
      // Simulate progress
      callbacks.onProgress?.("Generating preview...");
      
      // Return mock result after delay
      setTimeout(() => {
        const result = mockResults[subActionId] || { success: true };
        callbacks.onComplete?.(result);
      }, 500);
    },
  };
}
```

## What Moves to Shared

### Everything in interactions/ EXCEPT:

Nothing stays - everything moves to shared with adapters.

### Complete File List

**Contexts (new):**
- `contexts/RenderContext.tsx` - Template state + debug mode
- `contexts/SubActionContext.tsx` - Sub-action execution (refactored)

**Types:**
- `types/index.ts` (from `core/types.ts`)
- `types/interactions.ts` (from `interactions/types.ts`)  
- `types/schema.ts` (from `interactions/schema/types.ts`)
- `types/layouts.ts` (from `interactions/layouts/types.ts`)

**Utils:**
- `utils/cn.ts` (from `core/utils.ts`)
- `utils/template-service.ts` (from `lib/template-service.ts`)
- `utils/ux-utils.ts`
- `utils/schema-utils.ts`
- `utils/layout-utils.ts`
- `utils/interaction-utils.ts` (from `lib/interaction-utils.ts`)
- `utils/interaction-state.ts` (from `state/interaction-state.ts`)

**UI Components:**
- All `components/ui/*` (27 files)
- `components/theme-provider.tsx`

**Renderers:**
- All `interactions/renderers/*` (17 files)

**Layouts:**
- All `interactions/layouts/*` (8 files)

**Schema:**
- All `interactions/schema/*` (~15 files)
- Updates needed: `SchemaRenderer`, `ObjectSchemaRenderer`, `InputSchemaComposer`

**Interaction System:**
- `InteractionHost.tsx` - **UPDATE**: Use RenderContext, accept executor prop
- `interaction-context.tsx` - Move as-is (self-contained)
- `sub-action-context.tsx` - **REFACTOR**: Use injectable executor
- `validation-context.tsx` - Move as-is (self-contained)

**Interaction Types:**
- `types/text-input/*`
- `types/file-input/*`
- `types/file-download/*`
- `types/structured-select/*`
- `types/review-grouped/*`
- `types/form-input/*`
- `types/media-generation/*`

**Routers:**
- `InputRenderer.tsx`
- `TerminalRenderer.tsx`

## What Stays in webui

```
ui/webui/src/
  adapters/
    WebUIRenderProvider.tsx      # Provides RenderContext from webui state
    WebUISubActionExecutor.ts    # Real sub-action execution via API
    
  components/
    layout/
      header.tsx                 # App navigation
    AccessDeniedView.tsx         # Error view
    
  core/
    api.ts                       # REST + SSE API client
    config.ts                    # Environment config
    
  features/
    debug-panel/                 # Debug mode panel
    workflow-files/              # File tree viewer
    
  lib/
    capabilities.ts              # Capability checking
    
  pages/
    WorkflowPage.tsx             # Main workflow page
    WorkflowHistoryPage.tsx      # History view
    LandingPage.tsx              # Template selector
    
  state/
    workflow-store.ts            # Zustand store
    WorkflowStateContext.tsx     # SSE state sync
    hooks/
      useDebugMode.ts            # Debug flag
      useWorkflowState.ts        # SSE hook
      useWorkflowExecution.ts    # Workflow execution
      
  App.tsx                        # Router + providers
  main.tsx                       # Entry point
  index.css                      # Imports shared + app styles
```

**Total: ~15-20 files** remaining in webui, all app-specific:
- Pages/routing
- API client
- Zustand store
- SSE state sync
- Adapters that bridge shared to webui state

## webui Usage After Migration

```typescript
// webui/src/pages/WorkflowPage.tsx

import { 
  InteractionHost,
  RenderProvider,
  SubActionProvider,
} from "@wfm/shared";
import { useWorkflowStateContext } from "@/state/WorkflowStateContext";
import { useWorkflowStore } from "@/state/workflow-store";
import { createWebUISubActionExecutor } from "@/adapters/WebUISubActionExecutor";

function WorkflowInteraction({ interaction }) {
  const { state } = useWorkflowStateContext();
  const workflowRunId = useWorkflowStore((s) => s.workflowRunId);
  const selectedProvider = useWorkflowStore((s) => s.selectedProvider);
  const selectedModel = useWorkflowStore((s) => s.selectedModel);
  
  const executor = useMemo(() => 
    createWebUISubActionExecutor(workflowRunId, interaction.interaction_id, {
      provider: selectedProvider,
      model: selectedModel,
    }),
    [workflowRunId, interaction.interaction_id, selectedProvider, selectedModel]
  );
  
  return (
    <RenderProvider value={{
      templateState: state.state_mapped || {},
      debugMode: getDebugMode(),
    }}>
      <InteractionHost
        request={interaction}
        onSubmit={handleSubmit}
        subActionExecutor={executor}
      />
    </RenderProvider>
  );
}
```

## Editor Usage

```typescript
// editor/src/components/preview/ModulePreview.tsx

import {
  InteractionHost,
  RenderProvider,
} from "@wfm/shared";
import { createMockSubActionExecutor } from "@/adapters/MockSubActionExecutor";

function ModulePreview({ moduleConfig, exampleData, mockResults }) {
  const executor = useMemo(() => 
    createMockSubActionExecutor(mockResults),
    [mockResults]
  );
  
  return (
    <RenderProvider value={{
      templateState: exampleData || {},
      debugMode: false,
    }}>
      <InteractionHost
        request={buildPreviewRequest(moduleConfig)}
        onSubmit={() => {}} // Preview only
        subActionExecutor={executor}
      />
    </RenderProvider>
  );
}
```

## Migration Order

1. **Create shared package structure**
2. **Create RenderContext** in shared
3. **Move types** (no dependencies)
4. **Move utils** (depends on types)
5. **Move UI components** (depends on utils)
6. **Move renderers** (depends on types, utils, UI)
7. **Move layouts** (depends on types, utils, UI)
8. **Move schema core** with RenderContext updates
9. **Move interaction-context, validation-context** (self-contained)
10. **Refactor and move sub-action-context** (injectable executor)
11. **Move InteractionHost** with adapter props
12. **Move all interaction types**
13. **Create webui adapters**
14. **Update webui imports**
15. **Verify webui builds and runs**

## Files Requiring Code Changes (not just import updates)

| File | Change |
|------|--------|
| `SchemaRenderer.tsx` | Use RenderContext instead of 3 webui imports |
| `ObjectSchemaRenderer.tsx` | Use RenderContext instead of 1 webui import |
| `InputSchemaComposer.tsx` | Use RenderContext instead of 2 webui imports |
| `sub-action-context.tsx` | Refactor to use injectable executor |
| `InteractionHost.tsx` | Accept executor prop, use RenderContext for debug |

## Summary

After migration:
- **Shared package**: ~80 files (complete interaction rendering system)
- **webui**: ~15-20 files (pages, API, state, adapters)
- **Editor**: Can import and use entire interaction system with mock adapters

The adapter pattern enables:
1. Full interaction preview in editor with mock data/results
2. Sub-action simulation with configurable mock responses
3. Template rendering with example state
4. No debug mode in editor (not needed for preview)
