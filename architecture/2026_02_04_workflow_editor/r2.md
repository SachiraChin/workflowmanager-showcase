# Workflow Editor - Architecture Document (r2)

## Summary

Visual node-based workflow editor at `/editor` path. Users can create new 
workflows or edit existing versions from `workflow_versions` collection. Each
save creates a new immutable version.

## Decisions Made

| Topic | Decision |
|-------|----------|
| Library | React Flow (`@xyflow/react`) |
| Architecture | Option B - Shared package (`ui/shared`) |
| Step visualization | Flat canvas with visual groupings (Option C) |
| Connections | Hybrid - visual + state-based (Option C) |
| Module config | Hybrid - custom UI for known, JSON for unknown |
| Preview | Basic static preview using existing renderers |
| Auto-save | Yes, localStorage for crash recovery |
| Versioning | Same as current (immutable, content-hash based) |
| Module registry | From `backend/server/modules/` |

## Architecture: Shared Package Approach

### Package Structure

```
ui/
  package.json              # NEW: workspace root
  shared/                   # NEW: shared rendering package
    package.json
    tsconfig.json
    vite.config.ts
    src/
      index.ts              # Main exports
      types/                # Shared types
      utils/                # cn(), template-service
      components/           # UI primitives (shadcn)
      renderers/            # Terminal renderers
      layouts/              # Layout system
      schema/               # Schema rendering core
  webui/                    # EXISTING: workflow runner app
    package.json            # Updated: depends on @wfm/shared
    ...
  editor/                   # NEW: workflow editor app
    package.json            # depends on @wfm/shared
    ...
```

### Workspace Configuration

Root `ui/package.json`:
```json
{
  "name": "workflow-manager-ui",
  "private": true,
  "workspaces": ["shared", "webui", "editor"]
}
```

### Shared Package Scope

What goes in `@wfm/shared`:

| Category | Files | Notes |
|----------|-------|-------|
| Types | `core/types.ts` | All shared TypeScript types |
| Utils | `core/utils.ts` (cn) | Class name utility |
| Utils | `lib/template-service.ts` | Nunjucks template rendering |
| UI Components | `components/ui/*` | All shadcn primitives |
| Renderers | `interactions/renderers/*` | Terminal renderers |
| Layouts | `interactions/layouts/*` | Layout registry + components |
| Schema Core | `interactions/schema/types.ts` | Schema types |
| Schema Core | `interactions/schema/*-utils.ts` | Schema utilities |
| Schema Core | `interactions/schema/selection/*` | Selection context |
| Schema Core | `interactions/schema/input/*` | Input schema context |
| Schema Core | `interactions/schema/tabs/*` | Tabs context |
| Schema Renderers | `interactions/schema/*Renderer.tsx` | Object/Array/Table/etc |

What stays in webui (tightly coupled to workflow execution):

| Category | Files | Notes |
|----------|-------|-------|
| State | `state/*` | Zustand store, contexts |
| Interaction Host | `interactions/InteractionHost.tsx` | Orchestration |
| Interaction Types | `interactions/types/*` | Full interaction components |
| Features | `features/*` | Workflow-specific features |
| Pages | `pages/*` | Route components |

## Editor Application Structure

```
ui/editor/
  package.json
  tsconfig.json
  vite.config.ts
  index.html
  src/
    main.tsx
    App.tsx
    index.css                   # Tailwind styles
    
    state/
      editor-store.ts           # Zustand store for editor
      
    components/
      layout/
        EditorHeader.tsx        # Save, version info, nav
        EditorLayout.tsx        # 3-panel layout
      canvas/
        EditorCanvas.tsx        # React Flow wrapper
        nodes/
          StepGroupNode.tsx     # Visual step grouping
          ModuleNode.tsx        # Module node
        edges/
          DataFlowEdge.tsx      # Connection edge
      panels/
        StepListPanel.tsx       # Left: step list
        PropertiesPanel.tsx     # Right: selected node config
        ModulePalette.tsx       # Available modules to add
      preview/
        PreviewPanel.tsx        # Module preview using shared
        
    features/
      module-config/
        ModuleConfigForm.tsx    # Module configuration
        configs/                # Per-module-type custom forms
          LLMConfig.tsx
          SelectConfig.tsx
          TransformConfig.tsx
          ...
          
    hooks/
      useWorkflowNodes.ts       # Convert workflow <-> React Flow
      useAutoSave.ts            # localStorage persistence
      useSaveWorkflow.ts        # API save
      
    utils/
      workflow-to-nodes.ts      # Workflow JSON -> React Flow nodes
      nodes-to-workflow.ts      # React Flow nodes -> Workflow JSON
      
    api/
      editor-api.ts             # Editor-specific API calls
```

## Data Flow

### Loading a Workflow for Edit

```
1. User clicks "Edit" on template version
2. Navigate to /editor?version={workflow_version_id}
3. Editor fetches workflow from API
4. workflow-to-nodes.ts converts to React Flow format
5. Canvas renders nodes and edges
```

### Saving Changes

```
1. User makes changes (nodes move, config updates, connections)
2. Auto-save to localStorage every N seconds
3. User clicks "Save"
4. nodes-to-workflow.ts converts back to workflow JSON
5. POST to API creates new workflow_version
6. New version_id returned, URL updated
```

### Preview Flow

```
1. User selects a module node
2. Properties panel shows config form
3. Preview panel renders using shared schema renderers
4. Preview uses example data defined in module config
```

## React Flow Node Types

### StepGroupNode

Visual container for modules in a step. Not a true parent-child in React Flow
(which doesn't support nesting well), but a background rectangle that moves
with its modules.

```typescript
interface StepGroupNodeData {
  stepId: string;
  stepName: string;
  stepIndex: number;
  color: string;           // Visual distinction
  collapsed: boolean;      // Can collapse to hide modules
}
```

### ModuleNode

Individual module within a step.

```typescript
interface ModuleNodeData {
  moduleId: string;        // e.g., "api.llm"
  moduleName: string;      // Instance name
  stepId: string;          // Parent step
  inputs: Record<string, unknown>;
  outputsToState: Record<string, string>;
  
  // Computed for display
  inputPorts: PortDefinition[];
  outputPorts: PortDefinition[];
}

interface PortDefinition {
  id: string;
  label: string;
  type: 'state' | 'direct';  // state = reads from state, direct = explicit
  stateKey?: string;
}
```

## Connection Model (Hybrid)

### Explicit Connections

User can drag from output port to input port. Creates visible edge.

### State-Based (Inferred)

When a module's input references `{{ state.foo }}` and another module writes
to `state.foo` via `outputs_to_state`, show a dotted/faded connection line.
These are computed, not stored.

### Visual Distinction

| Type | Style | Editable |
|------|-------|----------|
| Explicit | Solid line, bright color | Yes |
| Inferred | Dotted line, muted color | No (edit via config) |

## API Endpoints

### Existing (verify availability)

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/workflow-templates` | GET | List templates |
| `/workflow/definition/{version_id}` | GET | Get workflow definition |

### New Required

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/workflow-version/{id}/raw` | GET | Get editable workflow JSON |
| `/workflow-version` | POST | Create new version |
| `/workflow-template` | POST | Create new template |
| `/modules/registry` | GET | List available module types |

## Entry Points (Post-Implementation)

### Header Navigation

Add "Create Workflow" button to header component.

```typescript
// In header.tsx
<Button onClick={() => navigate('/editor')}>
  <Plus /> Create Workflow
</Button>
```

### Template Selector

Add "Edit" button next to each version.

```typescript
// In TemplateSelector.tsx, version dropdown
<Button onClick={() => navigate(`/editor?version=${version.workflow_version_id}`)}>
  <Edit2 /> Edit
</Button>
```

## Module Registry

Backend modules in `backend/server/modules/` define:
- `module_id`: Category.name (e.g., `api.llm`)
- `inputs`: List of ModuleInput with name, type, required, default, description
- `outputs`: List of ModuleOutput with name, type, description

Editor will fetch this registry and use it for:
- Module palette (what modules can be added)
- Properties panel (what fields to show)
- Validation (required inputs)

## Preview System

For v1, preview uses:
1. Schema from module definition
2. Example data (hardcoded or from module config)
3. Shared schema renderers from `@wfm/shared`

No runtime execution in v1 - just static rendering with sample data.

## Open Items for Implementation

1. Confirm API endpoint availability/creation needed
2. Define module registry endpoint response format
3. Decide on step color scheme / visual grouping style
4. Define localStorage auto-save format and recovery UX
