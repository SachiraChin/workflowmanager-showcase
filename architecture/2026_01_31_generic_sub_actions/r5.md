# Generic Sub-Actions Architecture - Revision 5

## Summary

Design a generic sub-action system that allows executing operations from within
an interaction without completing it. Two action types:

1. **`target_sub_action`**: Execute a child workflow (sandbox) with modules
   defined inline, then map results back to parent state
2. **`self_sub_action`**: Invoke the current module's own `sub_action()` method
   (e.g., media generation)

## Design Evolution (Key Decisions from Discussion)

### Decision 1: Child Workflow Sandbox Approach

**Problem**: Initially considered executing sub-action modules within parent's
execution context using a "virtual step". This risked interfering with parent's
state, events, and execution logic.

**Solution**: Create a separate child workflow run that executes in isolation:
- Child has its own `workflow_run_id`
- Child stores its own events
- Child has `parent_workflow_id` reference
- Child has `visible_in_ui=false` (can still access via direct link for debug)

**Benefits**:
- Complete isolation — no risk of corrupting parent workflow
- Clean separation of concerns
- Debuggable — child workflow can be inspected separately
- Reuses existing `execute_step_modules()` without modification

### Decision 2: State Seeding via Parameter (Not Event Copying)

**Problem**: Child workflow needs access to parent's state for Jinja resolution
(e.g., `{{ state.keyword_exclusions_selected }}`).

**Considered Options**:
1. Copy parent's `module_completed` events to child
2. New event type `INITIAL_STATE_SEEDED`
3. Store `initial_module_outputs` in workflow_run document

**Solution**: None of the above! The `execute_step_modules()` method accepts
`module_outputs` as a parameter:

```python
def execute_step_modules(
    self,
    workflow_run_id: str,      # Child's ID — events stored here
    module_outputs: Dict,       # Parent's state — used for Jinja resolution
    ...
)
```

**How it works**:
1. Get parent's state: `parent_outputs = db.state_repo.get_module_outputs(parent_id)`
2. Pass to executor: `execute_step_modules(workflow_run_id=child_id, module_outputs=parent_outputs, ...)`
3. Child modules use `parent_outputs` for Jinja resolution
4. Child modules store events under `child_id`
5. Dict is mutated in-place during execution (so Module 2 sees Module 1's output)
6. After execution, get child's outputs: `child_state = db.state_repo.get_module_outputs(child_id)`

**Key insight**: The dict mutation during execution is only for the loop to
work (Module 2 needs Module 1's output). The final state reconstruction uses
events, not the dict.

### Decision 3: Result Persistence via `_state_mapped` Pattern

**Problem**: After sub-action completes, how do we persist results to parent's
state so `get_module_outputs(parent_id)` returns updated values?

**Solution**: Store `sub_action_completed` event in parent with `_state_mapped`
field — same pattern as `module_completed` events:

```python
db.event_repo.store_event(
    workflow_run_id=parent_id,  # PARENT!
    event_type="sub_action_completed",
    data={
        "sub_action_id": sub_action_id,
        "child_workflow_id": child_id,
        "child_state": child_state,
        "_state_mapped": out_state  # Same pattern as module_completed
    }
)
```

When `get_module_outputs(parent_id)` replays events, it extracts `_state_mapped`
values from `sub_action_completed` events just like it does for `module_completed`.

**No special handling needed** — existing pattern handles it.

### Decision 4: No Workflow Definition Storage

**Considered**: Storing child workflow definition in `workflow_templates` and
`workflow_versions` tables for debugging.

**Decision**: Don't store for now. Would pollute tables significantly and
require additional management logic. Child workflow definition is built
dynamically from `actions` array. Can revisit later if debugging becomes
an issue.

### Decision 5: No `{{sub_action_id}}` Placeholders Needed

**Previous approach** (when considering virtual step in parent): Used
`{{sub_action_id}}` placeholders in state keys to prevent namespace collisions:
- `scene_concepts_{{sub_action_id}}` instead of `scene_concepts`
- Required placeholder replacement logic in server
- Complex `result_mapping` with different source/target keys

**With child workflow sandbox**: Placeholders are unnecessary because:
- Child has its own `workflow_run_id` and events
- Child's `scene_concepts` is completely separate from parent's `scene_concepts`
- No namespace collision possible
- `result_mapping` becomes simple: `source: "scene_concepts"` → `target: "scene_concepts"`

**Benefits**:
- Simpler schema (no placeholder syntax)
- No placeholder replacement logic needed
- Actions can reference modules exactly as they are defined
- `result_mapping` is straightforward

## Core Rules

1. **Streaming-only**: Sub-action endpoint is always SSE. Client waits for
   stream completion to get final data.

2. **State Isolation**: Child workflow has its own state. Parent's state is
   passed for Jinja resolution but not modified during child execution.

3. **Event Tracking**: Two events stored in PARENT workflow:
   - `sub_action_started`: Before execution, stores request data
   - `sub_action_completed`: After execution, stores result with `_state_mapped`

4. **No Interactive Modules in Child**: Child workflow cannot have interactive
   modules (would return `AWAITING_INPUT` and break flow). Validate early.

5. **Cancellation**: If parent workflow is cancelled, child should be cancelled.

6. **No Type Mixing**: A sub_action uses either `target_sub_action` actions
   OR `self_sub_action`, not both.

## Schema Format

### Type 1: target_sub_action (Child Workflow)

```json
{
  "sub_actions": [
    {
      "id": "regenerate_scenes",
      "label": "Generate New Scenes",
      "loading_label": "Generating new scenes...",

      "actions": [
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "generate_scenes"
          }
        },
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "flatten_keywords"
          }
        },
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "save_keywords"
          }
        }
      ],

      "result_mapping": [
        {
          "source": "scene_concepts",
          "target": "scene_concepts",
          "mode": "replace"
        }
      ],

      "feedback": {
        "enabled": true,
        "prompt": "What would you like different in the new scenes?",
        "state_key": "_retry_feedback"
      }
    }
  ]
}
```

Note: No `overrides` needed for output keys — child workflow uses the same keys
as the original modules. Child's state is completely isolated from parent's.

**Action Resolution Rules:**

| Has `ref`? | Has full config? | Behavior |
|------------|------------------|----------|
| Yes | No | Load from ref, apply overrides |
| Yes | Yes | Load from ref, merge with config, apply overrides |
| No | Yes | Use config directly (must be valid module def) |
| No | No | Error: insufficient configuration |

### Type 2: self_sub_action (Module Self-Invocation)

```json
{
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "loading_label": "Generating...",

      "actions": [
        {
          "type": "self_sub_action",
          "params": {
            "action_type": "txt2img"
          }
        }
      ],

      "result_key": "generations"
    }
  ]
}
```

## Execution Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. STORE sub_action_started EVENT (parent workflow)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│ {                                                                           │
│   event_type: "sub_action_started",                                         │
│   workflow_run_id: parent_id,                                               │
│   step_id: "scene_generation",                                              │
│   module_name: "select_scene",                                              │
│   data: {                                                                   │
│     sub_action_id: "regenerate_scenes_abc123",                              │
│     request: { ...complete request data via model_dump()... }               │
│   }                                                                         │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. GET PARENT STATE                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│ parent_outputs = db.state_repo.get_module_outputs(parent_id)                │
│                                                                             │
│ Returns: {                                                                  │
│   "keyword_exclusions_selected": [...],                                     │
│   "keyword_exclusions_generated": [...],                                    │
│   "scene_concepts": {...original scenes...},                                │
│   ...                                                                       │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. CREATE CHILD WORKFLOW RUN                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│ child_id = create_workflow_run(                                             │
│   parent_workflow_id: parent_id,                                            │
│   visible_in_ui: False                                                      │
│ )                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. BUILD VIRTUAL STEP FROM ACTIONS                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│ For each action in actions array:                                           │
│   1. If ref exists, load module config from referenced step/module          │
│   2. Merge inline config (inputs, outputs_to_state, name) if any            │
│   3. Apply overrides if any                                                 │
│                                                                             │
│ No placeholder replacement needed — child workflow is fully isolated.       │
│                                                                             │
│ virtual_step = {                                                            │
│   "step_id": f"sub_action_{sub_action_id}",                                 │
│   "modules": [resolved_module_1, resolved_module_2, resolved_module_3]      │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. VALIDATE NO INTERACTIVE MODULES                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│ for module_config in virtual_step["modules"]:                               │
│     module = registry.get_module(module_config["module_id"])                │
│     if isinstance(module, InteractiveModule):                               │
│         raise ValueError("Sub-action cannot contain interactive module")   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. EXECUTE CHILD WORKFLOW                                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│ executor.execute_step_modules(                                              │
│   workflow_run_id: child_id,            ← Events stored under child         │
│   module_outputs: parent_outputs,       ← For Jinja resolution              │
│   step: virtual_step,                                                       │
│   step_id: f"sub_action_{sub_action_id}",                                   │
│   module_start: 0,                                                          │
│   services: services,                                                       │
│   config: workflow_config,                                                  │
│   workflow_def: virtual_workflow_def                                        │
│ )                                                                           │
│                                                                             │
│ Inside the loop:                                                            │
│ ┌─────────────────────────────────────────────────────────────────────┐     │
│ │ Module 1: generate_scenes                                           │     │
│ │   - Resolves {{ state.keyword_exclusions_selected }} from parent    │     │
│ │   - Stores event under child_id                                     │     │
│ │   - Updates dict["scene_concepts"] in place                         │     │
│ ├─────────────────────────────────────────────────────────────────────┤     │
│ │ Module 2: flatten_keywords                                          │     │
│ │   - Resolves {{ state.scene_concepts.scenes }} from updated dict    │     │
│ │   - Stores event under child_id                                     │     │
│ ├─────────────────────────────────────────────────────────────────────┤     │
│ │ Module 3: save_keywords                                             │     │
│ │   - Stores event under child_id                                     │     │
│ └─────────────────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 7. GET CHILD STATE                                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│ child_state = db.state_repo.get_module_outputs(child_id)                    │
│                                                                             │
│ Returns (from CHILD's events only):                                         │
│ {                                                                           │
│   "scene_concepts": {...new scenes...},                                     │
│   "flattened_keywords": [...],                                              │
│   "keywords_saved_count": 5                                                 │
│ }                                                                           │
│                                                                             │
│ Note: Uses same keys as original modules. Child's "scene_concepts" is       │
│ completely separate from parent's "scene_concepts" — different workflow_id. │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 8. APPLY result_mapping ARRAY                                               │
├─────────────────────────────────────────────────────────────────────────────┤
│ result_mapping = [                                                          │
│   { source: "scene_concepts", target: "scene_concepts", mode: "replace" }   │
│ ]                                                                           │
│                                                                             │
│ out_state = {}                                                              │
│ for mapping in result_mapping:                                              │
│     source_key = mapping["source"]                                          │
│     target_key = mapping["target"]                                          │
│                                                                             │
│     if mapping["mode"] == "replace":                                        │
│         out_state[target_key] = child_state[source_key]                     │
│     elif mapping["mode"] == "merge":                                        │
│         existing = parent_outputs.get(target_key, [])                       │
│         out_state[target_key] = [*existing, *child_state[source_key]]       │
│                                                                             │
│ Result: out_state = { "scene_concepts": {...new scenes...} }                │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 9. STORE sub_action_completed EVENT (parent workflow)                       │
├─────────────────────────────────────────────────────────────────────────────┤
│ {                                                                           │
│   event_type: "sub_action_completed",                                       │
│   workflow_run_id: parent_id,           ← PARENT!                           │
│   step_id: "scene_generation",                                              │
│   module_name: "select_scene",                                              │
│   data: {                                                                   │
│     sub_action_id: "regenerate_scenes_abc123",                              │
│     child_workflow_id: child_id,                                            │
│     child_state: {...full child state for debugging...},                    │
│     _state_mapped: {                    ← Same pattern as module_completed  │
│       "scene_concepts": {...new scenes...}                                  │
│     }                                                                       │
│   }                                                                         │
│ }                                                                           │
│                                                                             │
│ When get_module_outputs(parent_id) is called later:                         │
│   - Replays all events including sub_action_completed                       │
│   - Extracts _state_mapped values (same as module_completed)                │
│   - Parent's scene_concepts now has new scenes!                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 10. STREAM COMPLETION TO UI                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│ yield StreamEvent(                                                          │
│   type: "complete",                                                         │
│   data: {                                                                   │
│     sub_action_id: sub_action_id,                                           │
│     updated_state: out_state                                                │
│   }                                                                         │
│ )                                                                           │
│                                                                             │
│ UI receives updated data and refreshes the card to show new scenes.         │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Server Implementation

### 1. Sub-Action Request Model

```python
class SubActionRequest(BaseModel):
    """Generic sub-action request."""
    interaction_id: str
    action_id: str
    params: Dict[str, Any] = {}
```

### 2. Sub-Action Endpoint (Streaming)

```python
@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db),
    processor = Depends(get_processor)
):
    """
    Execute a sub-action via SSE streaming.
    All event storage happens in the processor.
    """
    async def event_generator():
        try:
            async for event in processor.execute_sub_action(
                workflow_run_id=workflow_run_id,
                request=request
            ):
                yield {"event": event.type.value, "data": json.dumps(event.data)}

        except Exception as e:
            yield {"event": "error", "data": json.dumps({"message": str(e)})}

    return EventSourceResponse(event_generator())
```

### 3. Sub-Action Processor

```python
class SubActionProcessor:
    """Processes sub-action execution."""

    def __init__(self, db: Database, executor: WorkflowExecutor):
        self.db = db
        self.executor = executor

    async def execute_sub_action(
        self,
        workflow_run_id: str,
        request: SubActionRequest
    ) -> AsyncIterator[StreamEvent]:
        """Execute sub-action and yield progress events."""

        # 1. Generate unique sub_action_id
        sub_action_id = f"{request.action_id}_{uuid7().hex}"

        # 2. Get interaction and module config
        interaction = self._get_interaction(request.interaction_id)
        step_id = interaction.get("step_id")
        module_name = interaction.get("module_name")
        module_config = self._get_module_config(interaction)
        sub_action_def = self._find_sub_action(module_config, request.action_id)

        # 3. Store sub_action_started event (complete request data)
        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,
            event_type=DbEventType.SUB_ACTION_STARTED,
            step_id=step_id,
            module_name=module_name,
            data={
                "sub_action_id": sub_action_id,
                "request": request.model_dump()
            }
        )

        # 4. Determine action type and execute
        actions = sub_action_def.get("actions", [])
        if not actions:
            raise ValueError(f"Sub-action '{request.action_id}' has no actions")

        first_action = actions[0]
        action_type = first_action.get("type")

        if action_type == "target_sub_action":
            child_state = await self._execute_target_sub_actions(
                workflow_run_id, sub_action_id, sub_action_def, request.params
            )
        elif action_type == "self_sub_action":
            async for event in self._execute_self_sub_action(
                workflow_run_id, sub_action_id, interaction,
                sub_action_def, request.params
            ):
                yield event

            <!--dont do following, follow the logic path, all subactions should
            do the storage and other common management stuff in this method. by
                adding this logic for that method, it will just confuse reader
                in the future.-->

            return  # self_sub_action handles its own completion
        else:
            raise ValueError(f"Unknown action type: {action_type}")

        # 5. Get parent state for merge mode
        parent_outputs = self.db.state_repo.get_module_outputs(workflow_run_id)

        # 6. Apply result_mapping
        out_state = self._apply_result_mapping(
            sub_action_def, child_state, parent_outputs
        )

        # 7. Store sub_action_completed event in PARENT
        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,  # PARENT!
            event_type=DbEventType.SUB_ACTION_COMPLETED,
            step_id=step_id,
            module_name=module_name,
            data={
                "sub_action_id": sub_action_id,
                "child_state": child_state,
                "_state_mapped": out_state
            }
        )

        # 8. Yield completion
        yield StreamEvent(
            type=EventType.COMPLETE,
            data={
                "sub_action_id": sub_action_id,
                "updated_state": out_state
            }
        )

    async def _execute_target_sub_actions(
        self,
        parent_workflow_run_id: str,
        sub_action_id: str,
        sub_action_def: Dict,
        params: Dict
    ) -> Dict:
        """Execute target_sub_action chain as child workflow."""

        # Get parent's state for Jinja resolution
        parent_outputs = self.db.state_repo.get_module_outputs(
            parent_workflow_run_id
        )

        # Get workflow context
        workflow = self.db.workflow_repo.get_workflow(parent_workflow_run_id)
        workflow_def = get_workflow_def(workflow, self.db)
        services = rebuild_services(workflow, workflow_def, self.db)

        # Inject feedback if provided
        if params.get("feedback"):
            feedback_key = sub_action_def.get("feedback", {}).get(
                "state_key", "_retry_feedback"
            )
            parent_outputs[feedback_key] = params["feedback"]

        # Resolve actions to module configs
        actions = sub_action_def.get("actions", [])
        resolved_modules = []
        for action in actions:
            module_config = self._resolve_action_to_module(action, workflow_def)
            resolved_modules.append(module_config)

        # Validate no interactive modules
        for module_config in resolved_modules:
            module = self.executor.registry.get_module(
                module_config["module_id"]
            )
            if isinstance(module, InteractiveModule):
                raise ValueError(
                    f"Sub-action cannot contain interactive module: "
                    f"{module_config['module_id']}"
                )

        # Build virtual step
        virtual_step = {
            "step_id": f"sub_action_{sub_action_id}",
            "modules": resolved_modules
        }

        # Create child workflow run
        child_id = self._create_child_workflow_run(
            parent_workflow_run_id, sub_action_id
        )

        # Execute using existing executor
        response = self.executor.execute_step_modules(
            workflow_run_id=child_id,
            step=virtual_step,
            step_id=virtual_step["step_id"],
            module_start=0,
            module_outputs=parent_outputs,  # For Jinja resolution
            services=services,
            config=workflow_def.get("config", {}),
            workflow_def=workflow_def
        )

        if response.status == WorkflowStatus.ERROR:
            raise ValueError(f"Sub-action failed: {response.error}")

        # Get child's state from its events
        child_state = self.db.state_repo.get_module_outputs(child_id)
        return child_state

    def _create_child_workflow_run(
        self,
        parent_workflow_run_id: str,
        sub_action_id: str
    ) -> str:
        """Create child workflow run for sub-action execution."""
        child_id = f"wf_sub_{uuid7().hex}"

        self.db.workflow_runs.insert_one({
            "workflow_run_id": child_id,
            "parent_workflow_id": parent_workflow_run_id,
            "sub_action_id": sub_action_id,
            "visible_in_ui": False,
            "status": "processing",
            "created_at": datetime.utcnow()
        })

        # Create initial branch for child
        branch_id = f"br_{uuid7().hex}"
        self.db.branches.insert_one({
            "branch_id": branch_id,
            "workflow_run_id": child_id,
            "lineage": [{"branch_id": branch_id, "cutoff_event_id": None}],
            "created_at": datetime.utcnow()
        })

        self.db.workflow_runs.update_one(
            {"workflow_run_id": child_id},
            {"$set": {"current_branch_id": branch_id}}
        )

        return child_id

    def _resolve_action_to_module(
        self,
        action: Dict,
        workflow_def: Dict
    ) -> Dict:
        """Resolve action to full module configuration."""
        config = {}

        # Load from ref if specified
        ref = action.get("ref")
        if ref:
            ref_config = self._load_module_from_ref(workflow_def, ref)
            config = deep_copy(ref_config)

        # Merge inline fields
        for key in ["module_id", "inputs", "outputs_to_state", "name"]:
            if key in action:
                if key in config and isinstance(config[key], dict):
                    config[key] = deep_merge(config[key], action[key])
                else:
                    config[key] = action[key]

        # Apply overrides
        overrides = action.get("overrides", {})
        for key, value in overrides.items():
            if key in config and isinstance(config[key], dict):
                config[key] = deep_merge(config[key], value)
            else:
                config[key] = value

        # No placeholder replacement needed — child workflow is fully isolated

        return config

    def _load_module_from_ref(self, workflow_def: Dict, ref: Dict) -> Dict:
        """Load module config from workflow by step_id and module_name."""
        step_id = ref.get("step_id")
        module_name = ref.get("module_name")

        for step in workflow_def.get("steps", []):
            if step.get("step_id") == step_id:
                for module in step.get("modules", []):
                    if module.get("name") == module_name:
                        return module

        raise ValueError(
            f"Module ref not found: step={step_id}, module={module_name}"
        )

    def _apply_result_mapping(
        self,
        sub_action_def: Dict,
        child_state: Dict,
        parent_outputs: Dict
    ) -> Dict:
        """Apply result_mapping array to build out_state."""
        result_mapping = sub_action_def.get("result_mapping", [])
        out_state = {}

        for mapping in result_mapping:
            source_key = mapping["source"]
            target_key = mapping["target"]
            mode = mapping.get("mode", "replace")

            if mode == "replace":
                out_state[target_key] = child_state.get(source_key)
            elif mode == "merge":
                existing = parent_outputs.get(target_key, [])
                new_value = child_state.get(source_key, [])
                out_state[target_key] = [*existing, *new_value]

        return out_state

    async def _execute_self_sub_action(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        interaction: Dict,
        sub_action_def: Dict,
        params: Dict
    ) -> AsyncIterator[StreamEvent]:
        """Execute self_sub_action (module's own sub_action method)."""
        module_id = interaction.get("data", {}).get("module_id")
        module = self.executor.registry.get_module(module_id)

        if not hasattr(module, "sub_action"):
            raise ValueError(
                f"Module '{module_id}' does not implement sub_action()"
            )

        action = sub_action_def.get("actions", [{}])[0]
        action_params = action.get("params", {})

        context = SubActionContext(
            workflow_run_id=workflow_run_id,
            sub_action_id=sub_action_id,
            interaction_id=interaction.get("data", {}).get("interaction_id"),
            db=self.db,
            params={**action_params, **params}
        )

        async for event in module.sub_action(context):
            yield event
```

### 4. Helper Functions

```python
def deep_merge(base: Dict, override: Dict) -> Dict:
    """Deep merge two dicts, override takes precedence."""
    result = base.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result
```

Note: No `replace_placeholders_recursive` function needed — child workflow
isolation eliminates the need for `{{sub_action_id}}` namespacing.

### 5. Event Types

```python
class DbEventType(Enum):
    # ... existing types ...
    SUB_ACTION_STARTED = "sub_action_started"
    SUB_ACTION_COMPLETED = "sub_action_completed"
```

### 6. Update get_module_outputs

The existing `get_module_outputs` method should already handle `sub_action_completed`
events because it extracts `_state_mapped` from any event with that field.
Verify this works, or add explicit handling:

```python
def get_module_outputs(self, workflow_run_id: str, branch_id: str = None) -> Dict:
    events = self.get_lineage_events(
        workflow_run_id=workflow_run_id,
        branch_id=branch_id,
        event_type=["module_completed", "sub_action_completed"],  # Add this
    )

    outputs = {}
    for event in events:
        # ... existing module_name handling ...

        # Extract state-mapped values (works for both event types)
        state_mapped = event.get("data", {}).get("_state_mapped", {})
        for state_key, value in state_mapped.items():
            outputs[state_key] = value

    return outputs
```

## UI Updates

After sub-action completes, UI needs to refresh the interaction card with new
data. The completion event includes `updated_state`:

```typescript
// Handle sub-action completion
const handleSubActionComplete = (event: SubActionCompleteEvent) => {
  const { updated_state } = event.data;

  // Update local state with new data
  // e.g., scene_concepts now has new scenes
  setData((prev) => ({
    ...prev,
    ...updated_state,
  }));
};
```

## Files Affected

**Server:**
- `backend/server/api/routes/streaming.py` - Simplified endpoint
- `backend/server/api/models.py` - SubActionRequest model
- `backend/server/workflow/sub_action.py` - New: SubActionProcessor
- `backend/server/modules/media/generate.py` - Implement sub_action()
- `backend/db/event_types.py` - Add SUB_ACTION_STARTED, SUB_ACTION_COMPLETED
- `backend/db/repos/state.py` - Update get_module_outputs if needed

**Workflows:**
- `workflows/cc/steps/2_scene_generation/step.json` - Add sub_actions

**UI:**
- `ui/webui/src/core/types.ts` - Sub-action types
- `ui/webui/src/core/api.ts` - Update streamSubAction
- `ui/webui/src/interactions/` - Handle sub-action completion

## Open Items

1. **UI Card Refresh**: Need mechanism to refresh interaction card with new
   data after sub-action completes. Options:
   - UI updates local state from completion event (simplest)
   - UI refetches interaction data from server
   - Server pushes updated interaction via separate event
   <!--i would go for 2 as its the one most realiable.-->

2. **Progress Streaming**: For long-running sub-actions, may want to stream
   progress events during child workflow execution (module-by-module progress).
   <!--we dont need above for now.-->

3. **Cancellation Propagation**: Need to ensure child workflow is cancelled
   if parent is cancelled during sub-action execution.
