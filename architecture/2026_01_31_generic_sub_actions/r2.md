# Generic Sub-Actions Architecture - Revision 2

## Summary

Design a generic sub-action system that allows executing partial module chains
from within an interaction, without completing the interaction. The system
must support:

1. **Step 2 (scene_generation)**: Run `generate_scenes` → `flatten_keywords` →
   `save_keywords` chain, update interaction data, let user re-select
2. **Steps 3, 5, 7 (media generation)**: Keep existing behavior (async task
   queue for image/video/audio generation)

## Problem Analysis (Revised)

### Current State

**Retry (retryable)**:
- Uses `executor.execute_from_module()` to run module chain
- Runs from `target_module` to end of step, including the interactive module
- Completes the interaction, restarts from target module
- UI refreshes entirely

**Media Sub-Actions**:
- Single async operation via TaskQueue → Worker → Media Actor
- Results stored in content repository (not interaction data)
- UI appends results to local state
- Interaction stays open

### The Gap

For scene regeneration we need:
- Run a **module chain** (not single operation)
- **Update interaction's display_data** (not separate content repo)
- **Stay on same interaction** (like media sub-actions)
- **UI refreshes data** but preserves interaction state

Neither `retryable` nor current sub-actions support this.

## Design Proposal

<!--

I read the following proposals, and I don't think 100% there, I will write
below what I think, and we can go from there.

Rule 1: subaction stream itself is a streaming endpoint. no sync calls, when
request is submiited, calls has to wait till stream complete to get data Rule

Rule 2: subaction nodes can have special replacement sequence
{{sub_action_id}}, we always do **string replacement** for "{{sub_action_id}}"
for current sub action id. 

Rule 3: we always create new sub_action_id at the start of sub action, and
store all input data in events collection with event typee
"sub_action_requested". the
data.sub_action_id="{sub_action}_{uuid_v7}"=event_id. On completion of
sub_action, we store event type "sub_action_response" with
data.sub_action_id=same id above. check how we store events, follow same
pattern. ask any question. 

Array, by-ref sub action are meant to call any module other than self,
target_sub_action targets specific module, optionally we can set ref for
existing module in workflow, and set overrides which overrides the items for
given module. idea here is not to run target module, but to emulate target
module.

{
  "sub_actions": [
    {
      "id": "regenerate_scenes",
      "label": "Generate New Scenes",
      "loading_label": "Generating new scenes...",
      "actions": [
        {
          "module_id": "api.llm",
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_id": "generate_scenes"
          },
          "overrides": {
            "outputs_to_state": {
              "response": "scene_concepts_{{sub_action_id}}"
            }
          }
        },
        {
          "module_id": "transform.query",
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_id": "flatten_keywords"
          },
          "overrides": {
            "inputs": {
              "data": "{{ state.scene_concepts_{{sub_action_id}}.scenes }}"
            },
            "outputs_to_state": {
              "result": "flattened_keywords_{{sub_action_id}}"
            }
          }
        },
        {
          "module_id": "io.weighted_keywords",
          "type": "target_sub_action",
          "inputs": {
            "resolver_schema": {
              "type": "object",
              "properties": {
                "weighted_keywords": {
                  "resolver": "server"
                }
              }
            },
            "mode": "save",
            "weighted_keywords": "{{ flattened_keywords_{{sub_action_id}} }}"
          },
          "outputs_to_state": {
            "saved_count": "keywords_saved_count_{{sub_action_id}}"
          },
          "name": "save_keywords"
        }
      ],
      "result_mapping": {
        "source": "state.scene_concepts_{{sub_action_id}}.scenes",
        "target": "state.scene_concepts.scenes",
        "mode": "merge/replace"
      }
    }
  ]
}

Target, self ref, sub-action. All modules optionally implement sub_action()
method from base, when self_sub_action is invoked, it will always call the
sub_action() of module sub action included. in situation like generations, the
media.generation.sub_action() method will be responsible for whole process of
the sub_action resulting images/videos/audios.

{
  "id": "regenerate_scenes",
  "label": "Generate New Scenes",
  "loading_label": "Generating new scenes...",
  "actions": [
    {
      "type": "self_sub_action",
      "params": {}
    }
  ]
}

Retrieval of sub action data: currently sub action data are not in the response
of api request for module load. we have to update api response to include data
generated by subaction as part of the response rather than making another api
call to retrieve data. but this can be addressed later.

-->

### Core Concept: Sub-Action Module Chains

Sub-actions define a **module range** to execute, plus how results map back
to the interaction data.

```
sub_actions: [
  {
    id: "regenerate_scenes",

    // What modules to run (within current step)
    execution: {
      start_module: "generate_scenes",
      end_module: "save_keywords"  // inclusive, stops BEFORE interactive module
    },

    // How to map results back to interaction data
    result_mapping: {
      source: "state.scene_concepts",
      target: "display_data.data"
    }
  }
]
```

### Execution Flow

```
1. UI triggers sub-action (POST /workflow/{id}/sub-action)
2. Server:
   a. Looks up sub_action config from current module's schema
   b. Finds module range (start_module → end_module)
   c. Executes modules in sequence (reusing executor logic)
   d. Maps results to interaction's display_data
   e. Returns updated data to UI
3. UI:
   a. Receives updated display_data
   b. Re-renders with new data
   c. User continues selecting (interaction still open)
```

### Three Execution Modes

| Mode | Use Case | How It Works |
|------|----------|--------------|
| `module_chain` | Scene regeneration | Run modules, update interaction data |
| `task_queue` | Media generation | Enqueue async task, stream progress |
| `inline` | Simple transforms | Execute immediately, return result |

### Schema Format

```json
{
  "sub_actions": [
    {
      "id": "regenerate_scenes",
      "label": "Generate New Scenes",
      "shortcut": "r",
      "loading_label": "Generating new scenes...",

      "execution": {
        "mode": "module_chain",
        "start_module": "generate_scenes",
        "end_module": "save_keywords"
      },

      "result_mapping": {
        "source": "state.scene_concepts",
        "target": "display_data.data"
      },

      "feedback": {
        "enabled": true,
        "prompt": "What would you like different in the new scenes?",
        "inject_as": "_retry_feedback"
      }
    }
  ]
}
```

For existing media generation (backward compatible):

```json
{
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "loading_label": "Generating...",

      "execution": {
        "mode": "task_queue",
        "actor": "media",
        "action_type": "txt2img"
      },

      "result_key": "generations"
    }
  ]
}
```

## Server Implementation

### 1. Refactored Sub-Action Endpoint

```python
@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,  # Generic: {interaction_id, action_id, params}
    db = Depends(get_db),
    processor = Depends(get_processor)
):
    # 1. Get interaction and its module config
    interaction = db.events.find_one({
        "data.interaction_id": request.interaction_id
    })
    module_config = get_module_config(interaction)

    # 2. Find sub_action definition
    sub_action = find_sub_action(module_config, request.action_id)

    # 3. Route by execution mode
    mode = sub_action["execution"]["mode"]

    if mode == "module_chain":
        return await execute_module_chain_sub_action(
            workflow_run_id, interaction, sub_action, request.params, db
        )
    elif mode == "task_queue":
        return await execute_task_queue_sub_action(
            workflow_run_id, interaction, sub_action, request, db
        )
    elif mode == "inline":
        return await execute_inline_sub_action(
            workflow_run_id, interaction, sub_action, request.params, db
        )
```

### 2. Module Chain Execution

```python
async def execute_module_chain_sub_action(
    workflow_run_id: str,
    interaction: Dict,
    sub_action: Dict,
    params: Dict,
    db: Database
) -> Dict:
    """Execute a range of modules and update interaction data."""

    execution = sub_action["execution"]
    start_module = execution["start_module"]
    end_module = execution["end_module"]

    # Get workflow definition
    workflow = db.workflow_repo.get_workflow(workflow_run_id)
    workflow_def = get_workflow_def(workflow, db)

    # Find current step and module indices
    current_step = interaction["data"]["step_id"]
    start_idx = find_module_index(workflow_def, current_step, start_module)
    end_idx = find_module_index(workflow_def, current_step, end_module)

    # Inject feedback if provided
    module_outputs = db.state_repo.get_module_outputs(workflow_run_id)
    if params.get("feedback"):
        module_outputs["_retry_feedback"] = params["feedback"]

    # Execute module range (reuse existing executor logic)
    # Note: This is synchronous - consider streaming for long chains
    executor = WorkflowExecutor(db)
    result = executor.execute_module_range(
        workflow_run_id=workflow_run_id,
        step_id=current_step,
        start_module_idx=start_idx,
        end_module_idx=end_idx,
        module_outputs=module_outputs
    )

    # Map result to interaction display_data
    mapping = sub_action["result_mapping"]
    source_value = extract_path(result, mapping["source"])

    # Update interaction event with new data
    db.events.update_one(
        {"_id": interaction["_id"]},
        {"$set": {f"data.{mapping['target']}": source_value}}
    )

    # Return updated data for UI
    return {
        "status": "complete",
        "updated_data": source_value
    }
```

### 3. New Executor Method

Add to `WorkflowExecutor`:

```python
def execute_module_range(
    self,
    workflow_run_id: str,
    step_id: str,
    start_module_idx: int,
    end_module_idx: int,
    module_outputs: Dict
) -> Dict:
    """
    Execute a range of modules within a step.

    Unlike execute_from_module, this:
    - Stops at end_module_idx (doesn't run to end of step)
    - Returns state after execution (doesn't trigger interactions)
    - Preserves existing interaction
    """
    # Similar to execute_step_modules but with explicit end boundary
    ...
```

## UI Implementation

### 1. Sub-Action Types

```typescript
// Discriminated union for sub-action execution modes
interface ModuleChainExecution {
  mode: "module_chain";
  start_module: string;
  end_module: string;
}

interface TaskQueueExecution {
  mode: "task_queue";
  actor: string;
  action_type: string;
}

interface InlineExecution {
  mode: "inline";
  transform: string;
}

type SubActionExecution =
  | ModuleChainExecution
  | TaskQueueExecution
  | InlineExecution;

interface SubActionConfig {
  id: string;
  label: string;
  shortcut?: string;
  loading_label?: string;
  execution: SubActionExecution;
  result_mapping?: ResultMapping;
  feedback?: FeedbackConfig;
  // Legacy compatibility
  action_type?: string;  // Deprecated, use execution.action_type
  result_key?: string;   // Deprecated, use result_mapping
}
```

### 2. Generic Sub-Action Handler

```typescript
async function executeSubAction(
  workflowRunId: string,
  interactionId: string,
  action: SubActionConfig,
  params: Record<string, unknown>
): Promise<SubActionResult> {

  const mode = action.execution?.mode ?? "task_queue"; // Legacy default

  switch (mode) {
    case "module_chain":
      // Synchronous call, returns updated data
      return api.executeModuleChainSubAction(
        workflowRunId,
        interactionId,
        action.id,
        params
      );

    case "task_queue":
      // Async task, stream progress
      return api.streamSubAction(request, onEvent, onError);

    case "inline":
      // Immediate execution
      return api.executeInlineSubAction(
        workflowRunId,
        interactionId,
        action.id,
        params
      );
  }
}
```

### 3. UI Data Update Flow

For `module_chain` mode (scene regeneration):

```typescript
// In the interaction component
const handleSubAction = async (action: SubActionConfig) => {
  setLoading(true);

  const result = await executeSubAction(
    workflowRunId,
    interactionId,
    action,
    { feedback: userFeedback }
  );

  if (result.status === "complete") {
    // Update local data state with new data from server
    setData(result.updated_data);
  }

  setLoading(false);
};
```

## Migration Path

### Phase 1: Add Module Chain Support
1. Add `execute_module_range()` to executor
2. Refactor `/sub-action` endpoint to route by mode
3. Add `module_chain` handler

### Phase 2: Update Step 2 Schema
1. Add `sub_actions` to `select_scene` module config
2. Remove or keep `retryable` (can coexist for different options)

### Phase 3: UI Updates
1. Add generic sub-action handling in interaction components
2. Support `module_chain` result updates
3. Add feedback input UI for sub-actions

### Phase 4: Migrate Existing (Optional)
1. Update step 3, 5, 7 schemas to explicit `execution.mode: "task_queue"`
2. Deprecate implicit mode detection

## Open Questions

1. **Streaming for Module Chains**: Should `module_chain` mode support SSE
   streaming for progress? LLM modules can be slow.

2. **Error Recovery**: If a module in the chain fails, should we:
   - Return error and let user retry sub-action?
   - Partial rollback?
   - Keep previous data?

3. **Concurrent Sub-Actions**: Can user trigger multiple sub-actions? Should
   we queue them or reject while one is running?

4. **State Isolation**: Module chain execution modifies workflow state. Should
   sub-action results be isolated until interaction completes?

## Files Affected

**Server:**
- `backend/server/api/routes/streaming.py` - Refactor endpoint routing
- `backend/server/api/models.py` - Update SubActionRequest
- `backend/server/workflow/executor.py` - Add execute_module_range()
- `backend/server/workflow/sub_action.py` - New: sub-action handlers

**Workflows:**
- `workflows/cc/steps/2_scene_generation/step.json` - Add sub_actions

**UI:**
- `ui/webui/src/core/types.ts` - Sub-action types
- `ui/webui/src/core/api.ts` - New API methods
- `ui/webui/src/interactions/` - Sub-action handling in components

**Contracts:**
- `contracts/sub_action.py` - Shared sub-action types
