# Generic Sub-Actions Architecture - Revision 6

## Summary

Design a generic sub-action system that allows executing operations from within
an interaction without completing it. Two action types:

1. **`target_sub_action`**: Execute a child workflow (sandbox) with modules
   defined inline, then map results back to parent state
2. **`self_sub_action`**: Invoke the current module's own `sub_action()` method
   (e.g., media generation)

## Changes from R5

- **self_sub_action flow unified**: Removed early return for `self_sub_action`.
  All sub-action types now follow the same logic path for storage and common
  management (event storage, result mapping, completion streaming).
- **UI refresh decided**: Using option 2 (refetch from server) for reliability.
- **Progress streaming**: Deferred - not needed for initial implementation.

## Design Evolution (Key Decisions from Discussion)

### Decision 1: Child Workflow Sandbox Approach

**Problem**: Initially considered executing sub-action modules within parent's
execution context using a "virtual step". This risked interfering with parent's
state, events, and execution logic.

**Solution**: Create a separate child workflow run that executes in isolation:
- Child has its own `workflow_run_id`
- Child stores its own events
- Child has `parent_workflow_id` reference
- Child has `visible_in_ui=false` (can still access via direct link for debug)

**Benefits**:
- Complete isolation — no risk of corrupting parent workflow
- Clean separation of concerns
- Debuggable — child workflow can be inspected separately
- Reuses existing `execute_step_modules()` without modification

### Decision 2: State Seeding via Parameter (Not Event Copying)

**Problem**: Child workflow needs access to parent's state for Jinja resolution
(e.g., `{{ state.keyword_exclusions_selected }}`).

**Considered Options**:
1. Copy parent's `module_completed` events to child
2. New event type `INITIAL_STATE_SEEDED`
3. Store `initial_module_outputs` in workflow_run document

**Solution**: None of the above! The `execute_step_modules()` method accepts
`module_outputs` as a parameter:

```python
def execute_step_modules(
    self,
    workflow_run_id: str,      # Child's ID — events stored here
    module_outputs: Dict,       # Parent's state — used for Jinja resolution
    ...
)
```

**How it works**:
1. Get parent's state: `parent_outputs = db.state_repo.get_module_outputs(parent_id)`
2. Pass to executor: `execute_step_modules(workflow_run_id=child_id, module_outputs=parent_outputs, ...)`
3. Child modules use `parent_outputs` for Jinja resolution
4. Child modules store events under `child_id`
5. Dict is mutated in-place during execution (so Module 2 sees Module 1's output)
6. After execution, get child's outputs: `child_state = db.state_repo.get_module_outputs(child_id)`

**Key insight**: The dict mutation during execution is only for the loop to
work (Module 2 needs Module 1's output). The final state reconstruction uses
events, not the dict.

### Decision 3: Result Persistence via `_state_mapped` Pattern

**Problem**: After sub-action completes, how do we persist results to parent's
state so `get_module_outputs(parent_id)` returns updated values?

**Solution**: Store `sub_action_completed` event in parent with `_state_mapped`
field — same pattern as `module_completed` events:

```python
db.event_repo.store_event(
    workflow_run_id=parent_id,  # PARENT!
    event_type="sub_action_completed",
    data={
        "sub_action_id": sub_action_id,
        "child_workflow_id": child_id,
        "child_state": child_state,
        "_state_mapped": out_state  # Same pattern as module_completed
    }
)
```

When `get_module_outputs(parent_id)` replays events, it extracts `_state_mapped`
values from `sub_action_completed` events just like it does for `module_completed`.

**No special handling needed** — existing pattern handles it.

### Decision 4: No Workflow Definition Storage

**Considered**: Storing child workflow definition in `workflow_templates` and
`workflow_versions` tables for debugging.

**Decision**: Don't store for now. Would pollute tables significantly and
require additional management logic. Child workflow definition is built
dynamically from `actions` array. Can revisit later if debugging becomes
an issue.

### Decision 5: No `{{sub_action_id}}` Placeholders Needed

**Previous approach** (when considering virtual step in parent): Used
`{{sub_action_id}}` placeholders in state keys to prevent namespace collisions:
- `scene_concepts_{{sub_action_id}}` instead of `scene_concepts`
- Required placeholder replacement logic in server
- Complex `result_mapping` with different source/target keys

**With child workflow sandbox**: Placeholders are unnecessary because:
- Child has its own `workflow_run_id` and events
- Child's `scene_concepts` is completely separate from parent's `scene_concepts`
- No namespace collision possible
- `result_mapping` becomes simple: `source: "scene_concepts"` → `target: "scene_concepts"`

**Benefits**:
- Simpler schema (no placeholder syntax)
- No placeholder replacement logic needed
- Actions can reference modules exactly as they are defined
- `result_mapping` is straightforward

### Decision 6: Unified Sub-Action Flow

**All sub-action types** (both `target_sub_action` and `self_sub_action`) follow
the same execution path for:
- Event storage (`sub_action_started`, `sub_action_completed`)
- Result mapping
- Completion streaming

This keeps the code predictable and maintainable. The only difference is *how*
the child state is obtained:
- `target_sub_action`: Executes child workflow, gets state from child events
- `self_sub_action`: Module's `sub_action()` method returns the state directly

## Core Rules

1. **Streaming-only**: Sub-action endpoint is always SSE. Client waits for
   stream completion to get final data.

2. **State Isolation**: Child workflow has its own state. Parent's state is
   passed for Jinja resolution but not modified during child execution.

3. **Event Tracking**: Two events stored in PARENT workflow:
   - `sub_action_started`: Before execution, stores request data
   - `sub_action_completed`: After execution, stores result with `_state_mapped`

4. **No Interactive Modules in Child**: Child workflow cannot have interactive
   modules (would return `AWAITING_INPUT` and break flow). Validate early.

5. **Cancellation**: If parent workflow is cancelled, child should be cancelled.

6. **No Type Mixing**: A sub_action uses either `target_sub_action` actions
   OR `self_sub_action`, not both.

## Schema Format

### Type 1: target_sub_action (Child Workflow)

```json
{
  "sub_actions": [
    {
      "id": "regenerate_scenes",
      "label": "Generate New Scenes",
      "loading_label": "Generating new scenes...",

      "actions": [
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "generate_scenes"
          }
        },
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "flatten_keywords"
          }
        },
        {
          "type": "target_sub_action",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "save_keywords"
          }
        }
      ],

      "result_mapping": [
        {
          "source": "scene_concepts",
          "target": "scene_concepts",
          "mode": "replace"
        }
      ],

      "feedback": {
        "enabled": true,
        "prompt": "What would you like different in the new scenes?",
        "state_key": "_retry_feedback"
      }
    }
  ]
}
```

Note: No `overrides` needed for output keys — child workflow uses the same keys
as the original modules. Child's state is completely isolated from parent's.

**Action Resolution Rules:**

| Has `ref`? | Has full config? | Behavior |
|------------|------------------|----------|
| Yes | No | Load from ref, apply overrides |
| Yes | Yes | Load from ref, merge with config, apply overrides |
| No | Yes | Use config directly (must be valid module def) |
| No | No | Error: insufficient configuration |

### Type 2: self_sub_action (Module Self-Invocation)

```json
{
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "loading_label": "Generating...",

      "actions": [
        {
          "type": "self_sub_action",
          "params": {
            "action_type": "txt2img"
          }
        }
      ],

      "result_mapping": [
        {
          "source": "generations",
          "target": "generations",
          "mode": "merge"
        }
      ]
    }
  ]
}
```

Note: `self_sub_action` now uses `result_mapping` like `target_sub_action`. The
module's `sub_action()` method returns a dict, which is treated as the "child
state" for result mapping purposes.

## Execution Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. STORE sub_action_started EVENT (parent workflow)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│ {                                                                           │
│   event_type: "sub_action_started",                                         │
│   workflow_run_id: parent_id,                                               │
│   step_id: "scene_generation",                                              │
│   module_name: "select_scene",                                              │
│   data: {                                                                   │
│     sub_action_id: "regenerate_scenes_abc123",                              │
│     request: { ...complete request data via model_dump()... }               │
│   }                                                                         │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. GET PARENT STATE                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│ parent_outputs = db.state_repo.get_module_outputs(parent_id)                │
│                                                                             │
│ Returns: {                                                                  │
│   "keyword_exclusions_selected": [...],                                     │
│   "keyword_exclusions_generated": [...],                                    │
│   "scene_concepts": {...original scenes...},                                │
│   ...                                                                       │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. BRANCH BY ACTION TYPE                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────┐    ┌────────────────────────────────┐     │
│   │  target_sub_action          │    │  self_sub_action               │     │
│   │  ─────────────────────────  │    │  ────────────────────────────  │     │
│   │  Execute child workflow     │    │  Call module.sub_action()      │     │
│   │  (steps 3a-3d below)        │    │  Returns dict as child_state   │     │
│   └─────────────────────────────┘    └────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
        ┌───────────────────────────┴───────────────────────────┐
        │ target_sub_action path                                │
        ▼                                                       │
┌───────────────────────────────────────────────────────────────┤
│ 3a. CREATE CHILD WORKFLOW RUN                                 │
├───────────────────────────────────────────────────────────────┤
│ child_id = create_workflow_run(                               │
│   parent_workflow_id: parent_id,                              │
│   visible_in_ui: False                                        │
│ )                                                             │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ 3b. BUILD VIRTUAL STEP FROM ACTIONS                           │
├───────────────────────────────────────────────────────────────┤
│ For each action in actions array:                             │
│   1. If ref exists, load module config from workflow          │
│   2. Merge inline config (inputs, outputs_to_state, name)     │
│   3. Apply overrides if any                                   │
│                                                               │
│ virtual_step = {                                              │
│   "step_id": f"sub_action_{sub_action_id}",                   │
│   "modules": [resolved_module_1, ...]                         │
│ }                                                             │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ 3c. EXECUTE CHILD WORKFLOW                                    │
├───────────────────────────────────────────────────────────────┤
│ executor.execute_step_modules(                                │
│   workflow_run_id: child_id,                                  │
│   module_outputs: parent_outputs,                             │
│   step: virtual_step,                                         │
│   ...                                                         │
│ )                                                             │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ 3d. GET CHILD STATE                                           │
├───────────────────────────────────────────────────────────────┤
│ child_state = db.state_repo.get_module_outputs(child_id)      │
│                                                               │
│ Returns: { "scene_concepts": {...new...}, ... }               │
└───────────────────────────────────────────────────────────────┘
        │                                                       │
        └───────────────────────────┬───────────────────────────┘
                                    │ Both paths rejoin here
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. APPLY result_mapping ARRAY                                               │
├─────────────────────────────────────────────────────────────────────────────┤
│ result_mapping = [                                                          │
│   { source: "scene_concepts", target: "scene_concepts", mode: "replace" }   │
│ ]                                                                           │
│                                                                             │
│ out_state = {}                                                              │
│ for mapping in result_mapping:                                              │
│     if mode == "replace":                                                   │
│         out_state[target] = child_state[source]                             │
│     elif mode == "merge":                                                   │
│         out_state[target] = [*existing, *child_state[source]]               │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. STORE sub_action_completed EVENT (parent workflow)                       │
├─────────────────────────────────────────────────────────────────────────────┤
│ {                                                                           │
│   event_type: "sub_action_completed",                                       │
│   workflow_run_id: parent_id,           ← PARENT!                           │
│   step_id: "scene_generation",                                              │
│   module_name: "select_scene",                                              │
│   data: {                                                                   │
│     sub_action_id: "regenerate_scenes_abc123",                              │
│     child_workflow_id: child_id,        (only for target_sub_action)        │
│     child_state: {...full state...},                                        │
│     _state_mapped: { "scene_concepts": {...new scenes...} }                 │
│   }                                                                         │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. STREAM COMPLETION TO UI                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│ yield StreamEvent(                                                          │
│   type: "complete",                                                         │
│   data: {                                                                   │
│     sub_action_id: sub_action_id,                                           │
│     updated_state: out_state                                                │
│   }                                                                         │
│ )                                                                           │
│                                                                             │
│ UI receives completion → refetches interaction data from server.            │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Server Implementation

### 1. Sub-Action Request Model

```python
class SubActionRequest(BaseModel):
    """Generic sub-action request."""
    interaction_id: str
    action_id: str
    params: Dict[str, Any] = {}
```

### 2. Sub-Action Endpoint (Streaming)

```python
@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db),
    processor = Depends(get_processor)
):
    """
    Execute a sub-action via SSE streaming.
    All event storage happens in the processor.
    """
    async def event_generator():
        try:
            async for event in processor.execute_sub_action(
                workflow_run_id=workflow_run_id,
                request=request
            ):
                yield {"event": event.type.value, "data": json.dumps(event.data)}

        except Exception as e:
            yield {"event": "error", "data": json.dumps({"message": str(e)})}

    return EventSourceResponse(event_generator())
```

### 3. Sub-Action Processor

```python
class SubActionProcessor:
    """Processes sub-action execution."""

    def __init__(self, db: Database, executor: WorkflowExecutor):
        self.db = db
        self.executor = executor

    async def execute_sub_action(
        self,
        workflow_run_id: str,
        request: SubActionRequest
    ) -> AsyncIterator[StreamEvent]:
        """Execute sub-action and yield progress events."""

        # 1. Generate unique sub_action_id
        sub_action_id = f"{request.action_id}_{uuid7().hex}"

        # 2. Get interaction and module config
        interaction = self._get_interaction(request.interaction_id)
        step_id = interaction.get("step_id")
        module_name = interaction.get("module_name")
        module_config = self._get_module_config(interaction)
        sub_action_def = self._find_sub_action(module_config, request.action_id)

        # 3. Store sub_action_started event (complete request data)
        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,
            event_type=DbEventType.SUB_ACTION_STARTED,
            step_id=step_id,
            module_name=module_name,
            data={
                "sub_action_id": sub_action_id,
                "request": request.model_dump()
            }
        )

        # 4. Determine action type and execute
        actions = sub_action_def.get("actions", [])
        if not actions:
            raise ValueError(f"Sub-action '{request.action_id}' has no actions")

        first_action = actions[0]
        action_type = first_action.get("type")

        # 5. Execute based on type (both return child_state dict)
        if action_type == "target_sub_action":
            child_state, child_workflow_id = await self._execute_target_sub_actions(
                workflow_run_id, sub_action_id, sub_action_def, request.params
            )
        elif action_type == "self_sub_action":
            child_state = await self._execute_self_sub_action(
                workflow_run_id, sub_action_id, interaction,
                sub_action_def, request.params
            )
            child_workflow_id = None  # No child workflow for self_sub_action
        else:
            raise ValueError(f"Unknown action type: {action_type}")

        # 6. Get parent state for merge mode
        parent_outputs = self.db.state_repo.get_module_outputs(workflow_run_id)

        # 7. Apply result_mapping
        out_state = self._apply_result_mapping(
            sub_action_def, child_state, parent_outputs
        )

        # 8. Store sub_action_completed event in PARENT
        completed_data = {
            "sub_action_id": sub_action_id,
            "child_state": child_state,
            "_state_mapped": out_state
        }
        if child_workflow_id:
            completed_data["child_workflow_id"] = child_workflow_id

        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,  # PARENT!
            event_type=DbEventType.SUB_ACTION_COMPLETED,
            step_id=step_id,
            module_name=module_name,
            data=completed_data
        )

        # 9. Yield completion
        yield StreamEvent(
            type=EventType.COMPLETE,
            data={
                "sub_action_id": sub_action_id,
                "updated_state": out_state
            }
        )

    async def _execute_target_sub_actions(
        self,
        parent_workflow_run_id: str,
        sub_action_id: str,
        sub_action_def: Dict,
        params: Dict
    ) -> Tuple[Dict, str]:
        """
        Execute target_sub_action chain as child workflow.
        Returns (child_state, child_workflow_id).
        """

        # Get parent's state for Jinja resolution
        parent_outputs = self.db.state_repo.get_module_outputs(
            parent_workflow_run_id
        )

        # Get workflow context
        workflow = self.db.workflow_repo.get_workflow(parent_workflow_run_id)
        workflow_def = get_workflow_def(workflow, self.db)
        services = rebuild_services(workflow, workflow_def, self.db)

        # Inject feedback if provided
        if params.get("feedback"):
            feedback_key = sub_action_def.get("feedback", {}).get(
                "state_key", "_retry_feedback"
            )
            parent_outputs[feedback_key] = params["feedback"]

        # Resolve actions to module configs
        actions = sub_action_def.get("actions", [])
        resolved_modules = []
        for action in actions:
            module_config = self._resolve_action_to_module(action, workflow_def)
            resolved_modules.append(module_config)

        # Validate no interactive modules
        for module_config in resolved_modules:
            module = self.executor.registry.get_module(
                module_config["module_id"]
            )
            if isinstance(module, InteractiveModule):
                raise ValueError(
                    f"Sub-action cannot contain interactive module: "
                    f"{module_config['module_id']}"
                )

        # Build virtual step
        virtual_step = {
            "step_id": f"sub_action_{sub_action_id}",
            "modules": resolved_modules
        }

        # Create child workflow run
        child_id = self._create_child_workflow_run(
            parent_workflow_run_id, sub_action_id
        )

        # Execute using existing executor
        response = self.executor.execute_step_modules(
            workflow_run_id=child_id,
            step=virtual_step,
            step_id=virtual_step["step_id"],
            module_start=0,
            module_outputs=parent_outputs,  # For Jinja resolution
            services=services,
            config=workflow_def.get("config", {}),
            workflow_def=workflow_def
        )

        if response.status == WorkflowStatus.ERROR:
            raise ValueError(f"Sub-action failed: {response.error}")

        # Get child's state from its events
        child_state = self.db.state_repo.get_module_outputs(child_id)
        return child_state, child_id

    def _create_child_workflow_run(
        self,
        parent_workflow_run_id: str,
        sub_action_id: str
    ) -> str:
        """Create child workflow run for sub-action execution."""
        child_id = f"wf_sub_{uuid7().hex}"

        self.db.workflow_runs.insert_one({
            "workflow_run_id": child_id,
            "parent_workflow_id": parent_workflow_run_id,
            "sub_action_id": sub_action_id,
            "visible_in_ui": False,
            "status": "processing",
            "created_at": datetime.utcnow()
        })

        # Create initial branch for child
        branch_id = f"br_{uuid7().hex}"
        self.db.branches.insert_one({
            "branch_id": branch_id,
            "workflow_run_id": child_id,
            "lineage": [{"branch_id": branch_id, "cutoff_event_id": None}],
            "created_at": datetime.utcnow()
        })

        self.db.workflow_runs.update_one(
            {"workflow_run_id": child_id},
            {"$set": {"current_branch_id": branch_id}}
        )

        return child_id

    def _resolve_action_to_module(
        self,
        action: Dict,
        workflow_def: Dict
    ) -> Dict:
        """Resolve action to full module configuration."""
        config = {}

        # Load from ref if specified
        ref = action.get("ref")
        if ref:
            ref_config = self._load_module_from_ref(workflow_def, ref)
            config = deep_copy(ref_config)

        # Merge inline fields
        for key in ["module_id", "inputs", "outputs_to_state", "name"]:
            if key in action:
                if key in config and isinstance(config[key], dict):
                    config[key] = deep_merge(config[key], action[key])
                else:
                    config[key] = action[key]

        # Apply overrides
        overrides = action.get("overrides", {})
        for key, value in overrides.items():
            if key in config and isinstance(config[key], dict):
                config[key] = deep_merge(config[key], value)
            else:
                config[key] = value

        return config

    def _load_module_from_ref(self, workflow_def: Dict, ref: Dict) -> Dict:
        """Load module config from workflow by step_id and module_name."""
        step_id = ref.get("step_id")
        module_name = ref.get("module_name")

        for step in workflow_def.get("steps", []):
            if step.get("step_id") == step_id:
                for module in step.get("modules", []):
                    if module.get("name") == module_name:
                        return module

        raise ValueError(
            f"Module ref not found: step={step_id}, module={module_name}"
        )

    def _apply_result_mapping(
        self,
        sub_action_def: Dict,
        child_state: Dict,
        parent_outputs: Dict
    ) -> Dict:
        """Apply result_mapping array to build out_state."""
        result_mapping = sub_action_def.get("result_mapping", [])
        out_state = {}

        for mapping in result_mapping:
            source_key = mapping["source"]
            target_key = mapping["target"]
            mode = mapping.get("mode", "replace")

            if mode == "replace":
                out_state[target_key] = child_state.get(source_key)
            elif mode == "merge":
                existing = parent_outputs.get(target_key, [])
                new_value = child_state.get(source_key, [])
                out_state[target_key] = [*existing, *new_value]

        return out_state

    async def _execute_self_sub_action(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        interaction: Dict,
        sub_action_def: Dict,
        params: Dict
    ) -> Dict:
        """
        Execute self_sub_action (module's own sub_action method).
        Returns child_state dict for result mapping.
        """
        module_id = interaction.get("data", {}).get("module_id")
        module = self.executor.registry.get_module(module_id)

        if not hasattr(module, "sub_action"):
            raise ValueError(
                f"Module '{module_id}' does not implement sub_action()"
            )

        action = sub_action_def.get("actions", [{}])[0]
        action_params = action.get("params", {})

        context = SubActionContext(
            workflow_run_id=workflow_run_id,
            sub_action_id=sub_action_id,
            interaction_id=interaction.get("data", {}).get("interaction_id"),
            db=self.db,
            params={**action_params, **params}
        )

        # Module's sub_action returns a dict (the "child state")
        child_state = await module.sub_action(context)
        return child_state
```

### 4. Helper Functions

```python
def deep_merge(base: Dict, override: Dict) -> Dict:
    """Deep merge two dicts, override takes precedence."""
    result = base.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result
```

### 5. Event Types

```python
class DbEventType(Enum):
    # ... existing types ...
    SUB_ACTION_STARTED = "sub_action_started"
    SUB_ACTION_COMPLETED = "sub_action_completed"
```

### 6. Update get_module_outputs

The existing `get_module_outputs` method should already handle `sub_action_completed`
events because it extracts `_state_mapped` from any event with that field.
Verify this works, or add explicit handling:

```python
def get_module_outputs(self, workflow_run_id: str, branch_id: str = None) -> Dict:
    events = self.get_lineage_events(
        workflow_run_id=workflow_run_id,
        branch_id=branch_id,
        event_type=["module_completed", "sub_action_completed"],  # Add this
    )

    outputs = {}
    for event in events:
        # ... existing module_name handling ...

        # Extract state-mapped values (works for both event types)
        state_mapped = event.get("data", {}).get("_state_mapped", {})
        for state_key, value in state_mapped.items():
            outputs[state_key] = value

    return outputs
```

### 7. Module sub_action Method Contract

For `self_sub_action`, modules must implement:

```python
class MediaGenerateModule(InteractiveModule):
    async def sub_action(self, context: SubActionContext) -> Dict:
        """
        Execute sub-action and return result state.

        Args:
            context: SubActionContext with workflow_run_id, params, etc.

        Returns:
            Dict representing the "child state" for result mapping.
            Keys should match what's expected in result_mapping.source.
        """
        action_type = context.params.get("action_type")
        # ... perform generation ...

        return {
            "generations": generated_items  # Matches result_mapping source
        }
```

## UI Updates

After sub-action completes, UI refetches interaction data from server for
reliability. The completion event signals when to refetch:

```typescript
// Handle sub-action completion
const handleSubActionComplete = async (event: SubActionCompleteEvent) => {
  // Refetch interaction data from server for reliability
  const freshData = await api.getInteraction(workflowRunId, interactionId);
  setData(freshData);
};
```

This approach is more reliable than trying to merge `updated_state` locally,
as it ensures the UI always reflects the true server state.

## Files Affected

**Server:**
- `backend/server/api/routes/streaming.py` - Simplified endpoint
- `backend/server/api/models.py` - SubActionRequest model
- `backend/server/workflow/sub_action.py` - New: SubActionProcessor
- `backend/server/modules/media/generate.py` - Implement sub_action()
- `backend/db/event_types.py` - Add SUB_ACTION_STARTED, SUB_ACTION_COMPLETED
- `backend/db/repos/state.py` - Update get_module_outputs if needed

**Workflows:**
- `workflows/cc/steps/2_scene_generation/step.json` - Add sub_actions

**UI:**
- `ui/webui/src/core/types.ts` - Sub-action types
- `ui/webui/src/core/api.ts` - Update streamSubAction, add getInteraction
- `ui/webui/src/interactions/` - Handle sub-action completion with refetch

## Deferred Items

1. **Progress Streaming**: For long-running sub-actions, streaming progress
   events during child workflow execution (module-by-module progress) is not
   needed for initial implementation. Can add later if required.

2. **Cancellation Propagation**: Need to ensure child workflow is cancelled
   if parent is cancelled during sub-action execution. Will be addressed
   during implementation.
