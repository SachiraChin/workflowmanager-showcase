# Generic Sub-Actions Architecture - Revision 4

## Summary

Design a generic sub-action system that allows executing operations from within
an interaction without completing it. Two action types:

1. **`target_sub_action`**: Execute a mini-workflow of modules with state
   isolation, then merge results back to main state
2. **`self_sub_action`**: Invoke the current module's own `sub_action()` method
   (e.g., media generation)

## Core Rules

1. **Streaming-only**: Sub-action endpoint is always SSE. Client waits for
   stream completion to get final data.

2. **State Isolation**: All inner actions use `{{sub_action_id}}` replacement
   in state keys. Results only merge to main state via `result_mapping`.

3. **Event Tracking**: Every sub-action creates events:
   - `sub_action_requested`: At start, stores complete request
   - `sub_action_response`: At completion, stores result
   - Both events stored in processor (same context)

4. **No Type Mixing**: A sub_action uses either `target_sub_action` actions
   OR `self_sub_action`, not both.

5. **Reuse Executor**: For `target_sub_action`, build a virtual step and use
   existing `WorkflowExecutor.execute_step_modules()`.

## Schema Format

### Type 1: target_sub_action (Mini-Workflow)

```json
{
  "sub_actions": [
    {
      "id": "regenerate_scenes",
      "label": "Generate New Scenes",
      "loading_label": "Generating new scenes...",

      "actions": [
        {
          "type": "target_sub_action",
          "module_id": "api.llm",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "generate_scenes"
          },
          "overrides": {
            "outputs_to_state": {
              "response": "scene_concepts_{{sub_action_id}}"
            }
          }
        },
        {
          "type": "target_sub_action",
          "module_id": "transform.query",
          "ref": {
            "step_id": "scene_generation",
            "module_name": "flatten_keywords"
          },
          "overrides": {
            "inputs": {
              "data": "{{ state.scene_concepts_{{sub_action_id}}.scenes }}"
            },
            "outputs_to_state": {
              "result": "flattened_keywords_{{sub_action_id}}"
            }
          }
        },
        {
          "type": "target_sub_action",
          "module_id": "io.weighted_keywords",
          "inputs": {
            "resolver_schema": {
              "type": "object",
              "properties": {
                "weighted_keywords": { "resolver": "server" }
              }
            },
            "mode": "save",
            "weighted_keywords": "{{ state.flattened_keywords_{{sub_action_id}} }}"
          },
          "outputs_to_state": {
            "saved_count": "keywords_saved_count_{{sub_action_id}}"
          },
          "name": "save_keywords_{{sub_action_id}}"
        }
      ],

      "result_mapping": {
        "source": "state.scene_concepts_{{sub_action_id}}",
        "target": "state.scene_concepts",
        "mode": "replace"
      },

      "feedback": {
        "enabled": true,
        "prompt": "What would you like different in the new scenes?",
        "state_key": "_retry_feedback"
      }
    }
  ]
}
```

### Type 2: self_sub_action (Module Self-Invocation)

```json
{
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "loading_label": "Generating...",

      "actions": [
        {
          "type": "self_sub_action",
          "params": {
            "action_type": "txt2img"
          }
        }
      ],

      "result_key": "generations"
    }
  ]
}
```

## Server Implementation

### 1. Sub-Action Request Model

```python
class SubActionRequest(BaseModel):
    """Generic sub-action request."""
    interaction_id: str
    action_id: str
    params: Dict[str, Any] = {}
```

### 2. Sub-Action Endpoint (Streaming)

```python
@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db),
    processor = Depends(get_processor)
):
    """
    Execute a sub-action via SSE streaming.

    All event storage happens in the processor for consistency.
    """
    async def event_generator():
        try:
            async for event in processor.execute_sub_action(
                workflow_run_id=workflow_run_id,
                request=request  # Pass entire request object
            ):
                yield {"event": event.type.value, "data": json.dumps(event.data)}

        except Exception as e:
            yield {"event": "error", "data": json.dumps({"message": str(e)})}

    return EventSourceResponse(event_generator())
```

### 3. Sub-Action Processor

```python
class SubActionProcessor:
    """Processes sub-action execution."""

    def __init__(self, db: Database, executor: WorkflowExecutor):
        self.db = db
        self.executor = executor

    async def execute_sub_action(
        self,
        workflow_run_id: str,
        request: SubActionRequest
    ) -> AsyncIterator[StreamEvent]:
        """Execute sub-action and yield progress events."""

        # 1. Generate unique sub_action_id
        sub_action_id = f"{request.action_id}_{uuid7().hex}"

        # 2. Store sub_action_requested event (complete request data)
        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,
            event_type=DbEventType.SUB_ACTION_REQUESTED,
            event_id=sub_action_id,
            data={
                "sub_action_id": sub_action_id,
                **request.model_dump()  # Store entire request
            }
        )

        # 3. Get interaction and module config
        interaction = self._get_interaction(request.interaction_id)
        module_config = self._get_module_config(interaction)
        sub_action_def = self._find_sub_action(module_config, request.action_id)

        # 4. Determine action type and execute
        actions = sub_action_def.get("actions", [])
        if not actions:
            raise ValueError(f"Sub-action '{request.action_id}' has no actions")

        first_action = actions[0]
        action_type = first_action.get("type")

        result = None

        if action_type == "target_sub_action":
            async for event in self._execute_target_sub_actions(
                workflow_run_id, sub_action_id, sub_action_def, request.params
            ):
                yield event
                # Capture final result from completion event
                if event.type == EventType.MODULE_COMPLETE:
                    result = event.data.get("outputs")

        elif action_type == "self_sub_action":
            async for event in self._execute_self_sub_action(
                workflow_run_id, sub_action_id, interaction,
                sub_action_def, request.params
            ):
                yield event
                if event.type == EventType.COMPLETE:
                    result = event.data

        else:
            raise ValueError(f"Unknown action type: {action_type}")

        # 5. Apply result_mapping
        mapped_result = self._apply_result_mapping(
            workflow_run_id, sub_action_id, sub_action_def
        )

        # 6. Store sub_action_response event
        self.db.event_repo.store_event(
            workflow_run_id=workflow_run_id,
            event_type=DbEventType.SUB_ACTION_RESPONSE,
            event_id=sub_action_id,
            data={
                "sub_action_id": sub_action_id,
                "result": mapped_result
            }
        )

        # 7. Yield completion with updated data
        yield StreamEvent(
            type=EventType.COMPLETE,
            data={
                "sub_action_id": sub_action_id,
                "updated_data": mapped_result
            }
        )

    async def _execute_target_sub_actions(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        sub_action_def: Dict,
        params: Dict
    ) -> AsyncIterator[StreamEvent]:
        """
        Execute target_sub_action chain using existing WorkflowExecutor.

        Strategy: Build a virtual step from resolved actions, then call
        execute_step_modules() to reuse all existing executor logic.
        """

        # Get workflow context
        workflow = self.db.workflow_repo.get_workflow(workflow_run_id)
        workflow_def = get_workflow_def(workflow, self.db)
        services = rebuild_services(workflow, workflow_def, self.db)

        # Inject feedback if provided
        if params.get("feedback"):
            feedback_key = sub_action_def.get("feedback", {}).get(
                "state_key", "_retry_feedback"
            )
            self.db.state_repo.set_state_value(
                workflow_run_id, feedback_key, params["feedback"]
            )

        # Resolve actions to module configs
        actions = sub_action_def.get("actions", [])
        resolved_modules = []

        for action in actions:
            module_config = self._resolve_action_to_module(
                action, workflow_def, sub_action_id
            )
            resolved_modules.append(module_config)

        # Build virtual step
        virtual_step = {
            "step_id": f"sub_action_{sub_action_id}",
            "modules": resolved_modules
        }

        # Yield progress: starting
        yield StreamEvent(
            type=EventType.STARTED,
            data={
                "sub_action_id": sub_action_id,
                "total_modules": len(resolved_modules)
            }
        )

        # Execute using existing executor
        # Note: execute_step_modules is synchronous, wrap for streaming
        module_outputs = self.db.state_repo.get_module_outputs(workflow_run_id)

        response = self.executor.execute_step_modules(
            workflow_run_id=workflow_run_id,
            step=virtual_step,
            step_id=virtual_step["step_id"],
            module_start=0,
            module_outputs=module_outputs,
            services=services,
            config=workflow_def.get("config", {}),
            workflow_def=workflow_def
        )

        # Check result
        if response.status == WorkflowStatus.ERROR:
            yield StreamEvent(
                type=EventType.ERROR,
                data={"message": response.error}
            )
        else:
            yield StreamEvent(
                type=EventType.MODULE_COMPLETE,
                data={"outputs": module_outputs}
            )

    def _resolve_action_to_module(
        self,
        action: Dict,
        workflow_def: Dict,
        sub_action_id: str
    ) -> Dict:
        """
        Resolve a target_sub_action to a full module configuration.

        Resolution order:
        1. Load base config from ref (if specified)
        2. Merge inline fields (module_id, inputs, outputs_to_state, name)
        3. Apply overrides
        4. Replace {{sub_action_id}} placeholders
        """
        config = {}

        # 1. Load from ref if specified
        ref = action.get("ref")
        if ref:
            ref_config = self._load_module_from_ref(workflow_def, ref)
            config = deep_copy(ref_config)

        # 2. Merge inline fields
        for key in ["module_id", "inputs", "outputs_to_state", "name"]:
            if key in action:
                if key in config and isinstance(config[key], dict):
                    # Deep merge for dict fields
                    config[key] = deep_merge(config[key], action[key])
                else:
                    config[key] = action[key]

        # 3. Apply overrides
        overrides = action.get("overrides", {})
        for key, value in overrides.items():
            if key in config and isinstance(config[key], dict):
                config[key] = deep_merge(config[key], value)
            else:
                config[key] = value

        # 4. Replace {{sub_action_id}} placeholders
        config = replace_placeholders_recursive(
            config, "{{sub_action_id}}", sub_action_id
        )

        return config

    def _load_module_from_ref(
        self,
        workflow_def: Dict,
        ref: Dict
    ) -> Dict:
        """Load module config from workflow by step_id and module_name."""
        step_id = ref.get("step_id")
        module_name = ref.get("module_name")

        for step in workflow_def.get("steps", []):
            if step.get("step_id") == step_id:
                for module in step.get("modules", []):
                    if module.get("name") == module_name:
                        return module

        raise ValueError(
            f"Module ref not found: step={step_id}, module={module_name}"
        )

    async def _execute_self_sub_action(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        interaction: Dict,
        sub_action_def: Dict,
        params: Dict
    ) -> AsyncIterator[StreamEvent]:
        """Execute self_sub_action (module's own sub_action method)."""

        # Get module instance
        module_id = interaction.get("data", {}).get("module_id")
        module = self.executor.registry.get_module(module_id)

        if not hasattr(module, "sub_action"):
            raise ValueError(
                f"Module '{module_id}' does not implement sub_action()"
            )

        # Build context
        action = sub_action_def.get("actions", [{}])[0]
        action_params = action.get("params", {})

        context = SubActionContext(
            workflow_run_id=workflow_run_id,
            sub_action_id=sub_action_id,
            interaction_id=interaction.get("data", {}).get("interaction_id"),
            db=self.db,
            params={**action_params, **params}
        )

        # Execute module's sub_action method
        async for event in module.sub_action(context):
            yield event

    def _apply_result_mapping(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        sub_action_def: Dict
    ) -> Any:
        """Apply result_mapping to merge isolated state into main state."""

        mapping = sub_action_def.get("result_mapping")
        if not mapping:
            return None

        # Replace placeholder in source path
        source_path = mapping["source"].replace(
            "{{sub_action_id}}", sub_action_id
        )
        target_path = mapping["target"]
        mode = mapping.get("mode", "replace")

        # Get source value from state
        source_value = self.db.state_repo.get_state_by_path(
            workflow_run_id, source_path
        )

        # Apply to target based on mode
        if mode == "replace":
            self.db.state_repo.set_state_by_path(
                workflow_run_id, target_path, source_value
            )
        elif mode == "merge":
            existing = self.db.state_repo.get_state_by_path(
                workflow_run_id, target_path
            )
            merged = deep_merge(existing or {}, source_value or {})
            self.db.state_repo.set_state_by_path(
                workflow_run_id, target_path, merged
            )

        return source_value
```

### 4. Helper Functions

```python
def deep_merge(base: Dict, override: Dict) -> Dict:
    """Deep merge two dicts, override takes precedence."""
    result = base.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result


def replace_placeholders_recursive(obj: Any, placeholder: str, value: str) -> Any:
    """Replace placeholder string in all string values recursively."""
    if isinstance(obj, str):
        return obj.replace(placeholder, value)
    elif isinstance(obj, dict):
        return {k: replace_placeholders_recursive(v, placeholder, value)
                for k, v in obj.items()}
    elif isinstance(obj, list):
        return [replace_placeholders_recursive(item, placeholder, value)
                for item in obj]
    return obj
```

### 5. Module Interface Extension

```python
class BaseModule:
    """Base class for all modules."""

    async def sub_action(
        self,
        context: SubActionContext
    ) -> AsyncIterator[StreamEvent]:
        """
        Execute module-specific sub-action.

        Override to support self_sub_action type.
        """
        raise NotImplementedError(
            f"Module {self.module_id} does not implement sub_action()"
        )


class SubActionContext:
    """Context for sub-action execution."""

    def __init__(
        self,
        workflow_run_id: str,
        sub_action_id: str,
        interaction_id: str,
        db: Database,
        params: Dict[str, Any]
    ):
        self.workflow_run_id = workflow_run_id
        self.sub_action_id = sub_action_id
        self.interaction_id = interaction_id
        self.db = db
        self.params = params

    def get_state(self, key: str) -> Any:
        return self.db.state_repo.get_state_value(self.workflow_run_id, key)

    def set_state(self, key: str, value: Any) -> None:
        self.db.state_repo.set_state_value(self.workflow_run_id, key, value)
```

### 6. Media Generate Module Sub-Action

```python
class MediaGenerateModule(InteractiveModule):

    async def sub_action(
        self,
        context: SubActionContext
    ) -> AsyncIterator[StreamEvent]:
        """Handle media generation sub-action."""

        params = context.params
        provider = params.get("provider")
        action_type = params.get("action_type")
        prompt_id = params.get("prompt_id")

        if not provider or not action_type:
            raise ValueError("provider and action_type are required")

        yield StreamEvent(
            type=EventType.STARTED,
            data={"sub_action_id": context.sub_action_id}
        )

        # Enqueue task to worker
        queue = TaskQueue()
        task_id = queue.enqueue(
            actor="media",
            payload={
                "workflow_run_id": context.workflow_run_id,
                "interaction_id": context.interaction_id,
                "sub_action_id": context.sub_action_id,
                "provider": provider,
                "action_type": action_type,
                "prompt_id": prompt_id,
                "params": params.get("generation_params", {}),
                "source_data": params.get("source_data"),
            }
        )

        # Stream task progress
        async for event in self._stream_task(task_id):
            yield event
```

## Event Types

```python
class DbEventType(Enum):
    # ... existing types ...
    SUB_ACTION_REQUESTED = "sub_action_requested"
    SUB_ACTION_RESPONSE = "sub_action_response"
```

## Key Design Decisions

### 1. Reuse Executor Instead of Custom Runner

The `_execute_target_sub_actions` method:
- Resolves actions to module configs
- Builds a virtual step structure
- Calls `executor.execute_step_modules()`

This reuses all existing logic:
- Input resolution with `ParameterResolver`
- Jinja template evaluation via `StateProxy`
- Module validation
- Output storage
- Event tracking

### 2. Both Events Stored in Processor

Both `sub_action_requested` and `sub_action_response` events are stored in
the `SubActionProcessor`, ensuring:
- Consistent context
- Both events have access to same data
- Cleaner endpoint code

### 3. Store Complete Request Data

```python
data={
    "sub_action_id": sub_action_id,
    **request.model_dump()  # Captures all fields automatically
}
```

Using `model_dump()` ensures all request fields are captured without
explicit listing. Future fields are automatically included.

## Files Affected

**Server:**
- `backend/server/api/routes/streaming.py` - Simplified endpoint
- `backend/server/api/models.py` - Clean SubActionRequest
- `backend/server/workflow/sub_action.py` - New: SubActionProcessor
- `backend/server/engine/module_interface.py` - Add sub_action() method
- `backend/server/modules/media/generate.py` - Implement sub_action()
- `backend/db/event_types.py` - Add new event types

**Workflows:**
- `workflows/cc/steps/2_scene_generation/step.json` - Add sub_actions

**UI:**
- `ui/webui/src/core/types.ts` - Sub-action types
- `ui/webui/src/core/api.ts` - Simplified API calls
