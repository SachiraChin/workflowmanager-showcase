# Media Generation Workflow Integration Architecture - R3

## Summary

Design for sub-action system enabling iterative media generation within workflow interactions. Based on feedback: Option A with SSE streaming, module-config-driven approach, leveraging existing schema/form infrastructure.

---

## Design Decisions from Feedback

| Decision | Rationale |
|----------|-----------|
| **Option A (Sub-Action Endpoint)** | Follows current architecture, just a different module type |
| **SSE for sub-actions** | Media generation takes 30s-2min, need progress updates |
| **Module config drives behavior** | Generic system, not hardcoded handlers |
| **Leverage existing form/schema rendering** | Don't reinvent, extend current infrastructure |
| **Store all request data** | Can't rely on provider data, track everything we send |
| **Pass `generated_content_id` to state** | Next module uses ID to fetch image info |

---

## Module Configuration

The workflow module config defines everything:

```json
{
    "module_id": "media.generation",
    "inputs": {
        "title": "Generate Images for Prompts",
        "operation": "txt2img",
        <!--following wont be 1 provider, user may have selected 2 providers, and generated_prompts 
            will have prompts for both providers. -->
        "provider": "midapi",
        "data": "{{ state.generated_prompts }}",
        "data_schema": "{{ step.prompt_display_schema }}",
        "param_schema": "{{ step.generation_param_schema }}",
        "param_defaults": {
            "aspect_ratio": "16:9",
            "speed": "fast"
        }
    }
}
```

**Field purposes:**

| Field | Purpose |
|-------|---------|
| `operation` | Which media operation: `txt2img`, `img2img`, `img2vid`, etc. |
| `provider` | Which provider: `midapi`, `leonardo` |
| `data` | The source data to display (prompts, images, etc.) |
| `data_schema` | How to render `data` (leverages existing schema rendering) |
| `param_schema` | Schema for generation parameters (rendered as form) |
| `param_defaults` | Default values for params |

---

## Server Implementation

### New Endpoint: `POST /workflow/{id}/sub-action/stream`

Returns SSE stream for progress + result.

```python
# server/api/routes/sub_action.py

@router.post("/workflow/{workflow_run_id}/sub-action/stream")
async def stream_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db: Database = Depends(get_db)
):
    """
    Execute a sub-action with SSE streaming for progress.
    Does NOT advance workflow state.
    """
    return StreamingResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        media_type="text/event-stream"
    )
```

**Request:**
```python
class SubActionRequest(BaseModel):
    interaction_id: str
    operation: str          # "txt2img", "img2vid", etc.
    provider: str           # "midapi", "leonardo"
    params: Dict[str, Any]  # Generation parameters
    source_data: Any        # The prompt/image being processed (for association)
```

**SSE Events:**
```
event: started
data: {"action_id": "sub_xxx"}

event: progress
data: {"elapsed_ms": 5000, "message": "Generating..."}

event: progress
data: {"elapsed_ms": 15000, "message": "Processing results..."}

event: complete
data: {
    "urls": ["url1", "url2", "url3", "url4"],
    "metadata_id": "cgm_xxx",
    "content_ids": ["gc_xxx1", "gc_xxx2", "gc_xxx3", "gc_xxx4"]
}

-- OR --

event: error
data: {"error": "Generation failed", "details": {...}}
```

### Sub-Action Handler

```python
# server/workflow/sub_action.py

<!--following assumes that sub actions are always about media clients, which is not true, which is why
    i used media.{type} as type to identify where to look for correct executor. in your module config
    above, it would be operation + selected provider. following method only will route request to
    correct place, it could be router, or something else as we have to save data in db, but this is not
    the correct place to call provider directly and store data.-->

async def execute_sub_action_stream(
    workflow_run_id: str,
    request: SubActionRequest,
    db: Database
) -> AsyncGenerator[str, None]:
    """
    Execute media generation as sub-action.
    Stores results but does NOT change workflow state.
    """
    action_id = generate_action_id()

    yield sse_event("started", {"action_id": action_id})

    try:
        # Get the appropriate client
        client = get_media_client(request.provider)

        # Get the operation method
        operation_fn = getattr(client, request.operation)

        # Execute with progress callback
        start_time = time.time()

        def progress_callback():
            elapsed = int((time.time() - start_time) * 1000)
            # This is tricky with sync clients - may need threading
            pass

        # Execute generation (this blocks for 30s-2min)
        urls, raw_response = operation_fn(request.params)

        elapsed_ms = int((time.time() - start_time) * 1000)
        yield sse_event("progress", {
            "elapsed_ms": elapsed_ms,
            "message": "Storing results..."
        })

        # Store in database
        metadata_id = db.content_repo.store_generation(
            workflow_run_id=workflow_run_id,
            interaction_id=request.interaction_id,
            provider=request.provider,
            operation=request.operation,
            request_params=request.params,
            source_data=request.source_data,  # Store the prompt/source
            response_data=raw_response
        )

        content_ids = []
        for index, url in enumerate(urls):
            content_id = db.content_repo.store_content(
                metadata_id=metadata_id,
                workflow_run_id=workflow_run_id,
                index=index,
                provider_url=url,
                content_type=get_content_type(request.operation)
            )
            content_ids.append(content_id)

        yield sse_event("complete", {
            "urls": urls,
            "metadata_id": metadata_id,
            "content_ids": content_ids
        })

    except Exception as e:
        yield sse_event("error", {
            "error": str(e),
            "details": getattr(e, 'provider_error', None)
        })
```

### Progress During Long Operations

The media clients poll internally. We can add a callback mechanism:

```python
class MidAPIClient:
    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        # ... submit request ...

        while polling:
            if progress_callback:
                progress_callback(elapsed_ms, f"Polling... ({elapsed_ms/1000:.0f}s)")
            # ... poll ...
```

But since we're in async context and clients are sync, we'd need threading:

```python
async def execute_sub_action_stream(...):
    # Run sync client in thread pool with progress updates
    loop = asyncio.get_event_loop()

    progress_queue = asyncio.Queue()

    def run_with_progress():
        def callback(elapsed_ms, message):
            # Put progress in queue (thread-safe)
            loop.call_soon_threadsafe(
                progress_queue.put_nowait,
                {"elapsed_ms": elapsed_ms, "message": message}
            )
        return client.txt2img(params, progress_callback=callback)

    # Start generation in thread
    future = loop.run_in_executor(executor, run_with_progress)

    # Yield progress events while waiting
    while not future.done():
        try:
            progress = await asyncio.wait_for(progress_queue.get(), timeout=0.5)
            yield sse_event("progress", progress)
        except asyncio.TimeoutError:
            pass

    urls, raw_response = await future
    # ... store and yield complete ...
```

---

## WebUI Implementation

### New Interaction Type Component

```typescript
// components/workflow/interactions/media-generation/MediaGenerationInteraction.tsx

interface Props {
    request: InteractionRequest;
    mode: InteractionMode;
}

export function MediaGenerationInteraction({ request, mode }: Props) {
    const { display_data } = request;

    // Local state for accumulated generations
    const [generations, setGenerations] = useState<GenerationResult[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [isGenerating, setIsGenerating] = useState(false);
    const [progress, setProgress] = useState<ProgressInfo | null>(null);

    // Form state for generation params
    const [params, setParams] = useState(display_data.param_defaults || {});

    // Load existing generations on mount (for refresh resilience)
    useEffect(() => {
        loadExistingGenerations(request.interaction_id);
    }, [request.interaction_id]);

    // Register response builder with parent
    const { updateProvider } = useInteractionProvider();
    useEffect(() => {
        updateProvider({
            getResponse: () => ({
                selected_content_ids: selectedIds,
                all_generation_metadata_ids: generations.map(g => g.metadata_id)
            }),
            getState: () => ({ isValid: selectedIds.length > 0 })
        });
    }, [selectedIds, generations]);

    return (
        <div className="media-generation">
            {/* Source data display (prompts) - uses existing schema renderer */}
            <SchemaRenderer
                data={display_data.data}
                schema={display_data.data_schema}
            />

            {/* Generation parameters form - uses existing form infrastructure */}
            <ParamForm
                schema={display_data.param_schema}
                values={params}
                onChange={setParams}
                disabled={isGenerating}
            />

            {/* Generate button */}
            <Button
                onClick={() => handleGenerate(params)}
                disabled={isGenerating}
            >
                {isGenerating ? `Generating... ${progress?.message || ''}` : 'Generate'}
            </Button>

            {/* Progress indicator */}
            {isGenerating && progress && (
                <ProgressBar elapsed={progress.elapsed_ms} />
            )}

            {/* Results grid - accumulated from all generations */}
            <MediaGrid
                generations={generations}
                selectedIds={selectedIds}
                onSelectionChange={setSelectedIds}
                contentType={getContentType(display_data.operation)}
            />
        </div>
    );
}
```

### Sub-Action SSE Call

```typescript
// lib/sub-action.ts

export async function* streamSubAction(
    workflowRunId: string,
    request: SubActionRequest
): AsyncGenerator<SubActionEvent> {
    const response = await fetch(
        `/api/workflow/${workflowRunId}/sub-action/stream`,
        {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request)
        }
    );

    const reader = response.body!.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
            if (line.startsWith('event:')) {
                // Parse SSE event
                const eventType = line.slice(6).trim();
                // Next line should be data
                continue;
            }
            if (line.startsWith('data:')) {
                const data = JSON.parse(line.slice(5));
                yield { type: currentEventType, data };
            }
        }
    }
}
```

### Using the Stream in Component

```typescript
async function handleGenerate(params: object) {
    setIsGenerating(true);
    setProgress(null);

    try {
        const stream = streamSubAction(workflowRunId, {
            interaction_id: request.interaction_id,
            operation: display_data.operation,
            provider: display_data.provider,
            params: params,
            source_data: display_data.data  // The prompt being processed
        });

        for await (const event of stream) {
            switch (event.type) {
                case 'started':
                    // Could track action_id if needed
                    break;

                case 'progress':
                    setProgress(event.data);
                    break;

                case 'complete':
                    // Add to accumulated generations
                    setGenerations(prev => [...prev, {
                        urls: event.data.urls,
                        metadata_id: event.data.metadata_id,
                        content_ids: event.data.content_ids,
                        params: params,
                        timestamp: Date.now()
                    }]);
                    break;

                case 'error':
                    // Handle error (toast, etc.)
                    console.error('Generation failed:', event.data);
                    break;
            }
        }
    } finally {
        setIsGenerating(false);
        setProgress(null);
    }
}
```

### Refresh Resilience

Load existing generations when component mounts:

```typescript
async function loadExistingGenerations(interactionId: string) {
    const response = await fetch(
        `/api/workflow/${workflowRunId}/sub-action/state?interaction_id=${interactionId}`
    );
    const existing = await response.json();

    if (existing.generations?.length > 0) {
        setGenerations(existing.generations);
    }
}
```

**Server endpoint:**
```python
@router.get("/workflow/{workflow_run_id}/sub-action/state")
async def get_sub_action_state(
    workflow_run_id: str,
    interaction_id: str,
    db: Database = Depends(get_db)
):
    """Get all generations for an interaction (refresh resilience)."""
    generations = db.content_repo.get_generations_for_interaction(
        workflow_run_id=workflow_run_id,
        interaction_id=interaction_id
    )
    return {"generations": generations}
```

---

## Leveraging Existing Form/Schema Infrastructure

### ParamForm Component

<!--I dont think this is the correct way to address this, this is simply adding fixed
layout for all media clients, which in reality not how its going to work. layout
for MJ is not going to work for leonardo, and vise-versa. what it the possiblity of 
simply provide layout info in schema. I think we use some kinf of framework for layouts 
right? what if we allow schema to provide class names for each type of component?
this will make it very deterministic at module level, or this will make things hard
for us in long term?-->

Reuse existing form rendering with minor adjustments:

```typescript
// components/workflow/interactions/media-generation/ParamForm.tsx

interface Props {
    schema: JSONSchema;
    values: object;
    onChange: (values: object) => void;
    disabled?: boolean;
}

export function ParamForm({ schema, values, onChange, disabled }: Props) {
    // Leverage existing form field rendering
    // Current FormInput renders tables - we need a simpler vertical layout

    return (
        <div className="param-form">
            {Object.entries(schema.properties || {}).map(([key, fieldSchema]) => (
                <FormField
                    key={key}
                    name={key}
                    schema={fieldSchema}
                    value={values[key]}
                    onChange={(v) => onChange({ ...values, [key]: v })}
                    disabled={disabled}
                />
            ))}
        </div>
    );
}
```

### Schema for Generation Params

Example param schema for txt2img:

```json
{
    "type": "object",
    "properties": {
        "aspect_ratio": {
            "type": "string",
            "enum": ["1:1", "16:9", "9:16", "4:3", "3:4"],
            "title": "Aspect Ratio",
            "default": "16:9"
        },
        "speed": {
            "type": "string",
            "enum": ["relaxed", "fast", "turbo"],
            "title": "Speed",
            "default": "fast"
        },
        "stylization": {
            "type": "integer",
            "minimum": 0,
            "maximum": 1000,
            "title": "Stylization",
            "default": 100
        },
        "version": {
            "type": "string",
            "enum": ["7", "6.1", "6", "niji6"],
            "title": "Model Version",
            "default": "7"
        }
    }
}
```

This schema drives the form rendering - no hardcoded fields.

---

## Data Flow Summary

```
┌─────────────────────────────────────────────────────────────────┐
│ Workflow Module Config                                          │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ module_id: "media.generation"                               │ │
│ │ inputs:                                                     │ │
│ │   operation: "txt2img"                                      │ │
│ │   provider: "midapi"                                        │ │
│ │   data: {{ state.prompts }}                                 │ │
│ │   data_schema: {{ step.prompt_schema }}                     │ │
│ │   param_schema: {{ step.param_schema }}                     │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Server: MediaGenerationModule.get_interaction_request()         │
│                                                                 │
│ Returns InteractionRequest:                                     │
│   interaction_type: MEDIA_GENERATION                            │
│   display_data:                                                 │
│     operation: "txt2img"                                        │
│     provider: "midapi"                                          │
│     data: [resolved prompts]                                    │
│     data_schema: [resolved schema]                              │
│     param_schema: [resolved schema]                             │
│     param_defaults: {...}                                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ WebUI: MediaGenerationInteraction                               │
│                                                                 │
│ ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│ │ SchemaRenderer  │  │ ParamForm       │  │ GenerateButton  │  │
│ │ (shows prompts) │  │ (param inputs)  │  │                 │  │
│ └─────────────────┘  └─────────────────┘  └────────┬────────┘  │
│                                                     │           │
│                                         [User clicks]           │
│                                                     │           │
│                                                     ▼           │
│                              POST /sub-action/stream            │
│                              { operation, provider, params }    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Server: Sub-Action Handler                                      │
│                                                                 │
│ 1. Get media client (MidAPI/Leonardo)                           │
│ 2. Execute operation (txt2img)                                  │
│ 3. Stream progress events                                       │
│ 4. Store in content_generation_metadata + generated_content     │
│ 5. Return complete event with urls + IDs                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ WebUI: Update Component State                                   │
│                                                                 │
│ - Add generation to local state                                 │
│ - MediaGrid shows accumulated images                            │
│ - User can select images                                        │
│ - User can generate more                                        │
│ - User clicks Continue → sends selected_content_ids             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Server: Module.execute_with_response()                          │
│                                                                 │
│ Receives: { selected_content_ids: ["gc_xxx", "gc_yyy"] }        │
│ Returns:  { selected_images: ["gc_xxx", "gc_yyy"] }             │
│           (available in state for next module)                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Database Storage

Using tables from media_generation_providers doc:

```
content_generation_metadata
├── content_generation_metadata_id: "cgm_{uuid7}"
├── workflow_run_id: str
├── interaction_id: str          ← Associates with interaction
├── provider: "midapi" | "leonardo"
├── operation: "txt2img" | "img2img" | ...
├── request_params: jsonb        ← Full params sent to provider
├── source_data: jsonb           ← The prompt/source that was processed
├── response_data: jsonb         ← Full raw response from provider
├── created_at, completed_at, status, error_message, credits_used

generated_content
├── generated_content_id: "gc_{uuid7}"
├── workflow_run_id: str
├── content_generation_metadata_id: str (FK)
├── index: int
├── content_type: "image" | "video"
├── provider_url: str
├── local_path: str (nullable)
├── ...
```

**Key point:** `source_data` stores the exact prompt/input that was sent, so we have full traceability.

---

## Questions for Review

1. **Form rendering:** Current FormInput renders tables. For params, we need a simpler vertical layout. Should this be:
   - A new component (`ParamForm`)
   - A layout variant for existing FormInput
   - Something else?
   <!--added comment in that section-->

2. **Multiple prompts:** If `data` contains multiple prompts, should user generate for all at once, or select which prompt to generate for?
<!--this is the big issue, user can have any number of prompts shown, each prompts has ability to generate 
images regarles of what others did-->

3. **Provider selection:** Is provider fixed in module config, or should user be able to switch providers in the UI?
<!--in reality, provider info is there on prompts themselves, as prompts are grouped by provider, so we know
what is the provider for each prompt.-->
