# Media Generation Workflow Integration Architecture - R7

## Summary

Design for sub-action system with **editable prompts and parameters**, using schema-driven layout configuration. This revision addresses that prompts need to be editable (not just displayed), and layout must be configurable in schema.

---

## Key Insight: Prompts Are Editable

The media generation interaction needs:

1. **Editable prompt** - User can modify the prompt text before generating
2. **Editable generation params** - Aspect ratio, speed, model version, etc.
3. **Custom layout** - Fields arranged in specific structure (not just vertical stack)
4. **Sub-action trigger** - Generate button that calls server without advancing

All of this must be driven by `input_schema` with layout configuration.

---

## Current State Analysis

| Component | Current State | What's Needed |
|-----------|--------------|---------------|
| FormInput | Table/card layouts only | Flexible grid/section layouts |
| input_schema | Simple property list | Layout hints per field |
| Field arrangement | Sequential/vertical | Custom grid, grouping, sections |
| Sub-actions | Not supported | Integrated with form |

---

## Design: Schema-Driven Editable Form with Layout

### New UX Properties for input_schema

Extend `input_schema` to support layout configuration:

```typescript
interface InputPropertySchema {
    type: string;
    title?: string;
    description?: string;
    enum?: string[];
    default?: any;

    // NEW: Layout configuration
    _ux?: {
        // Grid positioning
        grid_column?: number;        // Which column (1-based)
        grid_row?: number;           // Which row (1-based)
        column_span?: number;        // Span multiple columns
        row_span?: number;           // Span multiple rows

        // Grouping
        group?: string;              // Group ID for sectioning
        group_label?: string;        // Label for group (on first field in group)

        // Field rendering
        input_type?: string;         // "text" | "textarea" | "select" | "slider" | "number"
        width?: string;              // "full" | "half" | "third" | "auto"

        // Conditional
        visible_when?: string;       // Expression for conditional visibility
    };
}
```

### Form Layout Configuration

Top-level layout configuration in schema:

```typescript
interface InputSchema {
    type: "object";
    properties: Record<string, InputPropertySchema>;

    _ux?: {
        // Layout mode
        layout?: "grid" | "sections" | "vertical" | "horizontal";

        // Grid configuration
        grid_columns?: number;       // Default: 2
        grid_gap?: string;           // "sm" | "md" | "lg"

        // Section configuration
        section_style?: "card" | "collapsible" | "flat";
    };
}
```

---

## Example: Media Generation Schema

### Full InteractionRequest

```json
{
    "interaction_type": "form_with_sub_actions",
    "display_data": {
        "provider": "midjourney",
        "prompt_id": "prompt_a",
        "current_values": {
            "subject": "contemplative person in partial profile...",
            "environment": "snug indoor room, exposed brick walls...",
            "objects": "small side table with warm lamp...",
            "motion": "lamp glow gently pulsing...",
            "atmosphere": "warm, dim, introspective...",
            "particles": "dust particles glowing..."
        },
        "generations": []
    },
    "input_schema": {
        "type": "object",
        "_ux": {
            "layout": "sections"
        },
        "properties": {
            "subject": {
                "type": "string",
                "title": "Subject",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "group_label": "Prompt Components",
                    "width": "full"
                }
            },
            "environment": {
                "type": "string",
                "title": "Environment",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "width": "full"
                }
            },
            "objects": {
                "type": "string",
                "title": "Objects",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "width": "full"
                }
            },
            "motion": {
                "type": "string",
                "title": "Motion",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "width": "full"
                }
            },
            "atmosphere": {
                "type": "string",
                "title": "Atmosphere",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "width": "full"
                }
            },
            "particles": {
                "type": "string",
                "title": "Particles",
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "width": "full"
                }
            },
            "aspect_ratio": {
                "type": "string",
                "title": "Aspect Ratio",
                "enum": ["1:1", "16:9", "9:16", "4:3", "3:4"],
                "default": "16:9",
                "_ux": {
                    "input_type": "select",
                    "group": "params",
                    "group_label": "Generation Parameters",
                    "width": "third"
                }
            },
            "speed": {
                "type": "string",
                "title": "Speed",
                "enum": ["relaxed", "fast", "turbo"],
                "default": "fast",
                "_ux": {
                    "input_type": "select",
                    "group": "params",
                    "width": "third"
                }
            },
            "version": {
                "type": "string",
                "title": "Model Version",
                "enum": ["7", "6.1", "6", "niji6"],
                "default": "7",
                "_ux": {
                    "input_type": "select",
                    "group": "params",
                    "width": "third"
                }
            },
            "stylization": {
                "type": "integer",
                "title": "Stylization",
                "minimum": 0,
                "maximum": 1000,
                "default": 100,
                "_ux": {
                    "input_type": "slider",
                    "group": "params",
                    "width": "full"
                }
            }
        }
    },
    "sub_actions": {
        "generate": {
            "label": "Generate Images",
            "action_type": "media.midjourney.txt2img",
            "loading_label": "Generating...",
            "result_target": "generations"
        }
    },
    "result_display_schema": {
        "type": "array",
        "_ux": {
            "render_as": "grid",
            "selectable": true,
            "selection_mode": "single"
        },
        "items": {
            "type": "object",
            "properties": {
                "url": { "type": "string", "_ux": { "render_as": "image" } },
                "content_id": { "type": "string", "_ux": { "display": "hidden" } }
            }
        }
    }
}
```

### Rendered Layout

```
┌─────────────────────────────────────────────────────────────────┐
│ Provider: MidJourney                          Prompt: prompt_a  │
├─────────────────────────────────────────────────────────────────┤
│ PROMPT COMPONENTS                                               │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Subject                                                     │ │
│ │ ┌─────────────────────────────────────────────────────────┐ │ │
│ │ │ contemplative person in partial profile...              │ │ │
│ │ │                                                         │ │ │
│ │ └─────────────────────────────────────────────────────────┘ │ │
│ └─────────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Environment                                                 │ │
│ │ ┌─────────────────────────────────────────────────────────┐ │ │
│ │ │ snug indoor room, exposed brick walls...                │ │ │
│ │ └─────────────────────────────────────────────────────────┘ │ │
│ └─────────────────────────────────────────────────────────────┘ │
│ ... more prompt fields ...                                      │
├─────────────────────────────────────────────────────────────────┤
│ GENERATION PARAMETERS                                           │
│ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐     │
│ │ Aspect Ratio    │ │ Speed           │ │ Model Version   │     │
│ │ [16:9 ▼]       │ │ [fast ▼]       │ │ [7 ▼]          │     │
│ └─────────────────┘ └─────────────────┘ └─────────────────┘     │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Stylization                                                 │ │
│ │ [────────●──────────────────────────────────────] 100       │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│                              [ Generate Images ]                │
├─────────────────────────────────────────────────────────────────┤
│ GENERATED IMAGES                                                │
│ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐                │
│ │         │ │    ✓    │ │         │ │         │                │
│ │  img 1  │ │  img 2  │ │  img 3  │ │  img 4  │                │
│ │         │ │         │ │         │ │         │                │
│ └─────────┘ └─────────┘ └─────────┘ └─────────┘                │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementation Approach

### Option A: Extend Existing FormInput

Add layout support to existing FormInput component:

```typescript
// webui/src/components/workflow/interactions/form-input.tsx

function FormInput() {
    const { request } = useInteraction();
    const inputSchema = extractInputSchema(request);
    const layoutConfig = inputSchema._ux || {};

    // Choose layout renderer based on config
    switch (layoutConfig.layout) {
        case 'sections':
            return <SectionedFormLayout schema={inputSchema} />;
        case 'grid':
            return <GridFormLayout schema={inputSchema} />;
        default:
            return <TableFormLayout schema={inputSchema} />;  // Existing
    }
}
```

**Pros:**
- Extends existing component
- Backward compatible

**Cons:**
- FormInput becomes complex
- Mixing display-only and editable concerns

### Option B: New FormRenderer in Schema-Interaction

Create a `FormRenderer` that integrates with the schema-interaction system:

```typescript
// webui/src/components/workflow/interactions/schema-interaction/renderers/FormRenderer.tsx

// When schema._ux.input_schema exists, render as form field instead of display
function FormRenderer({ schema, path, value, onChange }) {
    const inputSchema = schema._ux?.input_schema;
    if (!inputSchema) {
        // Delegate to normal display rendering
        return <TerminalRenderer schema={schema} value={value} />;
    }

    // Render as editable form field
    return <FormField schema={inputSchema} value={value} onChange={onChange} />;
}
```

**Pros:**
- Integrates with existing schema renderer
- Unified system for display and edit

**Cons:**
- More architectural change
- Need to handle form state in SchemaRenderer

### Option C: New Interaction Type with Layout Support

Create `form_with_sub_actions` interaction type that has proper layout support:

```typescript
// webui/src/components/workflow/interactions/form-with-sub-actions/FormWithSubActions.tsx

function FormWithSubActions() {
    const { request } = useInteraction();
    const [values, setValues] = useState(request.display_data.current_values);
    const [generations, setGenerations] = useState(request.display_data.generations);

    const inputSchema = request.input_schema;
    const subActions = request.sub_actions;

    return (
        <div className="form-with-sub-actions">
            {/* Form rendered by layout */}
            <SchemaFormRenderer
                schema={inputSchema}
                values={values}
                onChange={setValues}
            />

            {/* Sub-action buttons */}
            <SubActionButtons
                config={subActions}
                formValues={values}
                onResult={(target, result) => {
                    if (target === 'generations') {
                        setGenerations(prev => [...prev, ...result]);
                    }
                }}
            />

            {/* Results display */}
            {generations.length > 0 && (
                <SchemaRenderer
                    data={generations}
                    schema={request.result_display_schema}
                />
            )}
        </div>
    );
}
```

**Pros:**
- Clean separation
- Purpose-built for editable + sub-actions

**Cons:**
- New interaction type (but minimal)

---

## Recommended: Option C

Option C is recommended because:

1. **Single purpose** - Form editing + sub-actions + result display
2. **Uses existing infrastructure** - `SchemaRenderer` for results, form field components
3. **New capability isolated** - Layout support in new `SchemaFormRenderer`
4. **Not module-specific** - Works for any form + sub-action use case

---

## SchemaFormRenderer Design

New component that renders forms from `input_schema` with layout support:

```typescript
// webui/src/components/common/SchemaFormRenderer.tsx

interface Props {
    schema: InputSchema;
    values: Record<string, any>;
    onChange: (values: Record<string, any>) => void;
    disabled?: boolean;
}

export function SchemaFormRenderer({ schema, values, onChange, disabled }: Props) {
    const layoutConfig = schema._ux || {};
    const properties = schema.properties || {};

    // Group fields by group ID
    const groups = groupFieldsByGroup(properties);

    // Render based on layout mode
    switch (layoutConfig.layout) {
        case 'sections':
            return (
                <div className="schema-form schema-form--sections">
                    {Object.entries(groups).map(([groupId, fields]) => (
                        <FormSection
                            key={groupId}
                            label={getGroupLabel(fields)}
                            style={layoutConfig.section_style}
                        >
                            <FormFieldGroup
                                fields={fields}
                                values={values}
                                onChange={onChange}
                                disabled={disabled}
                            />
                        </FormSection>
                    ))}
                </div>
            );

        case 'grid':
            return (
                <div
                    className="schema-form schema-form--grid"
                    style={{
                        display: 'grid',
                        gridTemplateColumns: `repeat(${layoutConfig.grid_columns || 2}, 1fr)`,
                        gap: getGapSize(layoutConfig.grid_gap)
                    }}
                >
                    {Object.entries(properties).map(([key, fieldSchema]) => (
                        <FormFieldWrapper
                            key={key}
                            fieldSchema={fieldSchema}
                        >
                            <FormField
                                name={key}
                                schema={fieldSchema}
                                value={values[key]}
                                onChange={(v) => onChange({ ...values, [key]: v })}
                                disabled={disabled}
                            />
                        </FormFieldWrapper>
                    ))}
                </div>
            );

        default:
            // Vertical layout (default)
            return (
                <div className="schema-form schema-form--vertical">
                    {Object.entries(properties).map(([key, fieldSchema]) => (
                        <FormField
                            key={key}
                            name={key}
                            schema={fieldSchema}
                            value={values[key]}
                            onChange={(v) => onChange({ ...values, [key]: v })}
                            disabled={disabled}
                        />
                    ))}
                </div>
            );
    }
}

function FormFieldWrapper({ fieldSchema, children }) {
    const ux = fieldSchema._ux || {};

    const style: React.CSSProperties = {};
    if (ux.grid_column) style.gridColumn = ux.grid_column;
    if (ux.grid_row) style.gridRow = ux.grid_row;
    if (ux.column_span) style.gridColumn = `span ${ux.column_span}`;
    if (ux.row_span) style.gridRow = `span ${ux.row_span}`;

    const className = clsx(
        'schema-form__field',
        ux.width && `schema-form__field--${ux.width}`
    );

    return (
        <div className={className} style={style}>
            {children}
        </div>
    );
}
```

---

## Server-Side Module

```python
# server/modules/media/generation.py

class MediaGenerationModule(InteractiveModule):
    """
    Interactive module for media generation.
    Uses form_with_sub_actions interaction type.
    """

    def get_interaction_request(self, inputs: dict, context) -> InteractionRequest:
        provider = inputs["provider"]
        prompt_id = inputs["prompt_id"]
        prompt_data = inputs["prompt_data"]

        # Get provider-specific schemas
        input_schema = self.build_input_schema(provider, prompt_data)
        param_schema = get_param_schema(provider)

        return InteractionRequest(
            interaction_type=InteractionType.FORM_WITH_SUB_ACTIONS,
            display_data={
                "provider": provider,
                "prompt_id": prompt_id,
                "current_values": prompt_data,
                "generations": []
            },
            input_schema=input_schema,
            sub_actions={
                "generate": {
                    "label": "Generate Images",
                    "action_type": f"media.{provider}.txt2img",
                    "loading_label": "Generating...",
                    "result_target": "generations"
                }
            },
            result_display_schema=self.get_result_schema()
        )

    def build_input_schema(self, provider: str, prompt_data: dict) -> dict:
        """Build input schema with layout based on prompt structure."""
        properties = {}

        # Add prompt fields
        for key in prompt_data.keys():
            properties[key] = {
                "type": "string",
                "title": key.replace("_", " ").title(),
                "_ux": {
                    "input_type": "textarea",
                    "group": "prompt",
                    "group_label": "Prompt Components" if key == list(prompt_data.keys())[0] else None,
                    "width": "full"
                }
            }

        # Add param fields from provider schema
        param_schema = get_param_schema(provider)
        for key, field in param_schema["properties"].items():
            properties[key] = {
                **field,
                "_ux": {
                    **field.get("_ux", {}),
                    "group": "params",
                    "group_label": "Generation Parameters" if key == list(param_schema["properties"].keys())[0] else None
                }
            }

        return {
            "type": "object",
            "_ux": {"layout": "sections"},
            "properties": properties
        }

    def execute_with_response(self, inputs: dict, context, response: dict) -> dict:
        return {
            "selected_content_id": response.get("selected_content_id"),
            "final_prompt": response.get("values"),  # The edited prompt
            "generations": response.get("all_metadata_ids", [])
        }
```

---

## Multiple Prompts Handling

For multiple prompts (grouped by provider), the module shows one prompt at a time with navigation, or uses a tabbed/accordion interface:

### Option 1: One Prompt Per Interaction

Module iterates through prompts, showing one at a time:

```python
class MediaGenerationModule(InteractiveModule):
    def get_interaction_request(self, inputs, context):
        prompts = inputs["prompts"]  # { provider: { prompt_id: data } }

        # Get first unprocessed prompt
        for provider, prompt_dict in prompts.items():
            for prompt_id, prompt_data in prompt_dict.items():
                if not self.is_processed(context, provider, prompt_id):
                    return self.create_interaction(provider, prompt_id, prompt_data)

        # All done
        return None

    def execute_with_response(self, inputs, context, response):
        # Mark this prompt as processed
        self.mark_processed(context, response["provider"], response["prompt_id"])

        # Check if more prompts
        if self.has_more_prompts(inputs, context):
            # Continue to next prompt (same module)
            return {"_continue": True}

        # All done, return aggregated results
        return {"all_selections": self.get_all_selections(context)}
```

### Option 2: All Prompts in Tabs/Accordion

Single interaction shows all prompts with tab navigation:

```json
{
    "interaction_type": "form_with_sub_actions",
    "display_data": {
        "prompts": { ... },  // All prompts
        "active_tab": "midjourney:prompt_a",
        "generations": { ... }  // Grouped by provider:prompt_id
    },
    "navigation": {
        "type": "tabs",  // or "accordion"
        "items": [
            { "id": "midjourney:prompt_a", "label": "MJ - Prompt A" },
            { "id": "midjourney:prompt_b", "label": "MJ - Prompt B" },
            { "id": "leonardo:phoenix_1_0", "label": "Leo - Phoenix" }
        ]
    }
}
```

---

## Questions for Review

1. **Layout approach:** Is the `_ux` extension to `input_schema` acceptable, or should layout be a separate configuration?

2. **Multiple prompts:** Should we show one prompt at a time (simpler) or all prompts with tabs (more complex but complete view)?

3. **Form state:** When user edits a prompt and generates, should the edited prompt be persisted immediately or only on Continue?

4. **Existing FormInput:** Should we extend FormInput to support layouts, or keep `form_with_sub_actions` as a separate interaction type?
