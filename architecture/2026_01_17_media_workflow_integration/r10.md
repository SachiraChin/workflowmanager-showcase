# Media Generation Workflow Integration Architecture - R10

## Summary

Design for integrating media generation (images/videos) into workflows via a **sub-action system**. Users can iteratively generate content from prompts, adjust parameters, regenerate, and select results—all within a single interaction step.

**Key Design Decisions:**
- Sub-actions follow the same pattern as retryables (defined in module config, passed through context, put in display_data)
- `sub_actions` is an **array** (like `retryable.options`)
- Provider determined at **runtime** from data structure (not in module config)
- Schema-driven layouts using semantic layout hints
- Editable fields via `schema._ux.input_schema` (with flat properties inside, not nested `_ux`)
- Provider classes follow R3 pattern (classes with methods, not standalone functions)

**R10 Changes from R9:**
- Fixed WebUI component architecture to properly use InteractionHost wrapper pattern
- ActionSlot pattern for sub-action buttons (not direct rendering)
- FormInput pattern for editable fields with SchemaRenderer
- Addressed `display_format` for combined text editing
- Proper folder structure following existing patterns

---

## Data Flow Pattern

Sub-actions follow the **exact same pattern as retryables**:

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Workflow JSON (module config)                                │
│                                                                 │
│    "sub_actions": [                                             │
│      { "id": "generate", "action_type": "txt2img", ... }        │
│    ]                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Executor puts on context                                     │
│                                                                 │
│    context.sub_actions = module_config.get('sub_actions')       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Module extracts from context, puts in display_data           │
│                                                                 │
│    sub_actions = getattr(context, 'sub_actions', None)          │
│    display_data = {                                             │
│        "data": prompts,                                         │
│        "schema": display_schema,                                │
│        "sub_actions": sub_actions,  # <-- Like retryable        │
│    }                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI reads request.display_data.sub_actions                 │
│                                                                 │
│    const subActions = request.display_data?.sub_actions;        │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prompts Data Structure

Prompts from previous workflow step, grouped by provider:

```json
{
  "prompts": {
    "midjourney": {
      "prompt_a": {
        "subject": "contemplative person in partial profile...",
        "environment": "snug indoor room, exposed brick walls...",
        "objects": "small side table with warm lamp...",
        "motion": "lamp glow gently pulsing...",
        "atmosphere": "warm, dim, introspective...",
        "particles": "dust particles glowing..."
      },
      "prompt_b": {
        "subject": "quiet journaling person in armchair...",
        "environment": "intimate, safe room mood..."
      }
    },
    "leonardo": {
      "phoenix_1_0": "Primary subject: a contemplative person nestled in a cushioned armchair...",
      "anime_xl": "Primary subject: a contemplative person nestled in a cozy armchair..."
    }
  }
}
```

**Structure:** `prompts[provider][prompt_id] = prompt_content`

**Key insight:** Provider is determined from data keys at runtime, not from module config.

---

## Workflow Module Configuration

### Step JSON

```json
{
  "module_id": "user.select",
  "inputs": {
    "data": "{{ state.generated_prompts }}",
    "schema": {
      "$ref": "schemas/media_generation_display_schema.json",
      "type": "json"
    },
    "prompt": "Generate and Select Images",
    "mode": "select",
    "multi_select": false
  },
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "action_type": "txt2img",
      "loading_label": "Generating...",
      "result_key": "generations"
    }
  ],
  "outputs_to_state": {
    "selected_indices": "selected_content",
    "selected_data": "selected_content_data"
  },
  "name": "generate_and_select"
}
```

**Notes:**
- `module_id: "user.select"` — Existing module extended with sub-action support
- `sub_actions` is an **array** (like `retryable.options`)
- `action_type: "txt2img"` — Generic operation, NOT provider-specific
- Provider determined at runtime from data structure (`prompts.midjourney`, `prompts.leonardo`)

### Sub-Action Config Schema

```typescript
interface SubActionConfig {
  id: string;              // Unique identifier: "generate"
  label: string;           // Button text: "Generate Images"
  action_type: string;     // Operation: "txt2img", "img2img", "img2vid"
  loading_label?: string;  // "Generating..."
  result_key: string;      // Where results accumulate in display_data
}
```

---

## Display Schema with Editable Fields

The display schema uses `_ux.input_schema` for editable prompt fields and `display_format` for combined text display.

**Important:**
- Inside `input_schema`, properties use **flat fields** like `input_type`, `enum_labels` — NOT nested `_ux`
- `display_format` is a Jinja2 template that combines multiple fields into a single rendered string
- When `display_format` is present, users edit the **rendered combined text**, not individual fields

```json
{
  "type": "object",
  "_ux": {
    "display": "passthrough"
  },
  "properties": {
    "prompts": {
      "type": "object",
      "_ux": {
        "display": "passthrough"
      },
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "render_as": "section",
            "display_label": "Midjourney",
            "selectable": true
          },
          "properties": {
            "prompt_a": {
              "type": "object",
              "_ux": {
                "display": "visible",
                "render_as": "content-panel",
                "display_label": "Prompt A (Weighted)",
                "display_format": "{{ state.selected_core_aesthetic.mj.art_style_prefix }} {{ subject }}::3 {{ environment }}. {{ particles }}::2 {{ objects }}::1.5 {{ motion }}::1.5 {{ atmosphere }}::1 {{ state.selected_core_aesthetic.mj.params }}",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "aspect_ratio": {
                      "type": "string",
                      "title": "Aspect Ratio",
                      "enum": ["1:1", "16:9", "9:16", "4:3"],
                      "default": "16:9",
                      "input_type": "select",
                      "width": "third"
                    },
                    "speed": {
                      "type": "string",
                      "title": "Speed",
                      "enum": ["relaxed", "fast", "turbo"],
                      "default": "fast",
                      "input_type": "select",
                      "width": "third"
                    },
                    "stylization": {
                      "type": "integer",
                      "title": "Stylization",
                      "minimum": 0,
                      "maximum": 1000,
                      "default": 100,
                      "input_type": "slider",
                      "width": "full"
                    }
                  }
                }
              },
              "properties": {
                "subject": { "type": "string", "_ux.display_label": "Subject" },
                "environment": { "type": "string", "_ux.display_label": "Environment" },
                "objects": { "type": "string", "_ux.display_label": "Objects" },
                "motion": { "type": "string", "_ux.display_label": "Motion" },
                "atmosphere": { "type": "string", "_ux.display_label": "Atmosphere" },
                "particles": { "type": "string", "_ux.display_label": "Particles" }
              }
            }
          }
        }
      }
    }
  }
}
```

### Layout Hints (Flat Properties, Not Nested `_ux`)

Inside `input_schema`, use flat properties directly on each field:

| Property | Values | Purpose |
|----------|--------|---------|
| `layout` | `"vertical"`, `"horizontal"`, `"sections"`, `"grid"` | Form layout mode (on root) |
| `width` | `"full"`, `"half"`, `"third"`, `"quarter"`, `"auto"` | Field width |
| `group` | `string` | Group ID for sections |
| `group_label` | `string` | Label for first field in group |
| `input_type` | `"text"`, `"textarea"`, `"select"`, `"slider"`, `"counter"` | Input control type |
| `enum_labels` | `Record<string, string>` | Display labels for enum values |

---

## Server Implementation

### Executor Change (Parallel to Retryable)

```python
# server/workflow/executor.py

# In execute_step_modules, where retryable is set:
context.retryable = module_config.get('retryable')
context.sub_actions = module_config.get('sub_actions')  # ADD THIS
```

### Module Implementation

The existing `user.select` module is extended:

```python
# server/modules/user/select.py (extended)

def get_interaction_request(
    self,
    inputs: Dict[str, Any],
    context
) -> Optional[InteractionRequest]:
    data = inputs['data']
    schema = inputs['schema']
    prompt = self.get_input_value(inputs, 'prompt')
    multi_select = self.get_input_value(inputs, 'multi_select')
    mode = self.get_input_value(inputs, 'mode')

    # Get configs from context (set by executor from module config)
    retryable = getattr(context, 'retryable', None)
    sub_actions = getattr(context, 'sub_actions', None)

    return InteractionRequest(
        interaction_type=InteractionType.SELECT_FROM_STRUCTURED,
        interaction_id=f"select_{uuid6.uuid7().hex}",
        title=prompt,
        display_data={
            "data": data,
            "schema": schema,
            "multi_select": multi_select,
            "mode": mode,
            "retryable": retryable,
            "sub_actions": sub_actions,      # Array, like retryable.options
            "generations": {}                 # Accumulates sub-action results
        },
        context={
            "module_id": self.module_id
        }
    )
```

### Sub-Action Registry

Maps provider names to provider classes:

```python
# server/workflow/sub_action/registry.py

from typing import Dict, Type
from .providers.base import MediaProviderBase

# Registry: provider_name -> provider_class
_PROVIDER_REGISTRY: Dict[str, Type[MediaProviderBase]] = {}


def register_provider(name: str, provider_class: Type[MediaProviderBase]):
    """Register a media provider."""
    _PROVIDER_REGISTRY[name] = provider_class


def get_provider(name: str) -> Type[MediaProviderBase]:
    """Get provider class by name."""
    if name not in _PROVIDER_REGISTRY:
        raise ValueError(f"Unknown provider: {name}")
    return _PROVIDER_REGISTRY[name]
```

### Provider Base Class (From R3)

```python
# server/workflow/sub_action/providers/base.py

from abc import ABC, abstractmethod
from typing import List, Tuple, Any, Optional, Callable


class MediaProviderBase(ABC):
    """Base class for media generation providers."""

    @abstractmethod
    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from text. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from image. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate video from image. Returns (urls, raw_response)."""
        pass
```

### Provider Implementation (From R3)

```python
# server/workflow/sub_action/providers/midjourney.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class MidJourneyProvider(MediaProviderBase):
    """MidJourney provider via MidAPI."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images via MidAPI."""
        from server.modules.api.providers.midapi import MidAPIClient

        client = MidAPIClient()
        return client.imagine(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.midapi import MidAPIClient

        client = MidAPIClient()
        return client.vary(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        raise NotImplementedError("MidJourney does not support img2vid")


# Register on module load
register_provider("midjourney", MidJourneyProvider)
```

```python
# server/workflow/sub_action/providers/leonardo.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class LeonardoProvider(MediaProviderBase):
    """Leonardo AI provider."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.generate(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.generate_with_image(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.motion(params, progress_callback=progress_callback)


# Register on module load
register_provider("leonardo", LeonardoProvider)
```

### Sub-Action API Route

```python
# server/api/routes/workflow.py

from pydantic import BaseModel
from sse_starlette.sse import EventSourceResponse


class SubActionRequest(BaseModel):
    """Request to execute a sub-action."""
    interaction_id: str
    provider: str                 # "midjourney", "leonardo" (from data keys)
    action_type: str              # "txt2img", "img2img", "img2vid"
    prompt_id: str                # "prompt_a"
    params: Dict[str, Any]        # Generation parameters
    source_data: Any              # Full prompt data


@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db)
):
    """Execute a sub-action with SSE streaming."""
    return EventSourceResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        send_timeout=5
    )
```

### Sub-Action Executor (SSE Streaming)

```python
# server/workflow/sub_action/executor.py

import asyncio
import json
import uuid6
import concurrent.futures

from .registry import get_provider


def sse_event(event_type: str, data: dict) -> str:
    """Format SSE event."""
    return f"event: {event_type}\ndata: {json.dumps(data)}\n\n"


async def execute_sub_action_stream(
    workflow_run_id: str,
    request: SubActionRequest,
    db
):
    """
    Execute sub-action and stream progress via SSE.
    Stores results in database but does NOT advance workflow state.
    """
    action_id = f"sa_{uuid6.uuid7().hex[:8]}"
    yield sse_event("started", {"action_id": action_id})

    try:
        # 1. Get provider class from registry
        provider_class = get_provider(request.provider)
        provider = provider_class()

        # 2. Get the method for action_type
        method = getattr(provider, request.action_type)

        # 3. Setup progress tracking
        loop = asyncio.get_event_loop()
        progress_queue = asyncio.Queue()

        def progress_callback(elapsed_ms: int, message: str):
            loop.call_soon_threadsafe(
                progress_queue.put_nowait,
                {"elapsed_ms": elapsed_ms, "message": message}
            )

        # 4. Run generation in thread pool (providers are sync)
        executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
        future = loop.run_in_executor(
            executor,
            lambda: method(request.params, progress_callback=progress_callback)
        )

        # 5. Stream progress while waiting
        while not future.done():
            try:
                progress = await asyncio.wait_for(progress_queue.get(), timeout=0.5)
                yield sse_event("progress", progress)
            except asyncio.TimeoutError:
                pass

        # 6. Get result
        urls, raw_response = await future

        # 7. Store metadata in database
        metadata_id = db.content_repo.store_generation(
            workflow_run_id=workflow_run_id,
            interaction_id=request.interaction_id,
            provider=request.provider,
            prompt_id=request.prompt_id,
            operation=request.action_type,
            request_params=request.params,
            source_data=request.source_data,
            response_data=raw_response
        )

        # 8. Store individual content items
        content_ids = []
        content_type = "video" if request.action_type == "img2vid" else "image"

        for index, url in enumerate(urls):
            content_id = db.content_repo.store_content(
                metadata_id=metadata_id,
                workflow_run_id=workflow_run_id,
                index=index,
                provider_url=url,
                content_type=content_type
            )
            content_ids.append(content_id)

        # 9. Send completion event
        yield sse_event("complete", {
            "urls": urls,
            "metadata_id": metadata_id,
            "content_ids": content_ids
        })

    except Exception as e:
        yield sse_event("error", {"message": str(e)})
```

---

## WebUI Implementation

### Component Architecture

The WebUI uses a consistent pattern where **InteractionHost is the wrapper** and child components register via `updateProvider`:

```
InteractionHost (provides InteractionProvider context)
├── Title
├── InteractionContent (routes to child component)
│   └── StructuredSelect / FormInput / etc.
│       ├── Renders content
│       ├── Calls updateProvider() to register getResponse/getState
│       └── Uses ActionSlot for custom buttons
├── ActionSlotTarget (renders child-registered buttons)
└── Footer (Continue/Retry buttons from retryable config)
```

**Key patterns:**
1. Child components do NOT render action buttons directly
2. ActionSlot is used to contribute buttons to the InteractionHost footer
3. SchemaRenderer handles readonly display; FormField handles editable inputs

### New Interaction Type: MediaGeneration

Create a new interaction component following the FormInput pattern:

```typescript
// webui/src/components/workflow/interactions/media-generation/MediaGeneration.tsx

/**
 * MediaGeneration - Prompt editing + image generation + selection.
 *
 * Follows the FormInput pattern:
 * - Uses SchemaRenderer for readonly display (respects display_format)
 * - Uses own form fields for editable parameters (from input_schema)
 * - Uses updateProvider to register with InteractionHost
 * - Uses ActionSlot for sub-action buttons
 */

import { useState, useEffect, useRef, useCallback } from "react";
import { useInteraction, ActionSlot } from "@/lib/interaction-context";
import { SchemaRenderer } from "../schema-interaction";
import { getUx, renderTemplate } from "../schema-interaction/ux-utils";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";

interface SubActionConfig {
  id: string;
  label: string;
  action_type: string;
  loading_label?: string;
  result_key: string;
}

interface GenerationResult {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}

export function MediaGeneration() {
  const { request, disabled, updateProvider, mode } = useInteraction();
  const isReadonly = mode.type === "readonly";

  // Extract data from display_data (standard pattern)
  const displayData = request.display_data || {};
  const data = displayData.data as Record<string, any>;
  const schema = displayData.schema as Record<string, any>;
  const subActions = displayData.sub_actions as SubActionConfig[] | undefined;

  // Local state for editable prompts and generations
  const [editedPrompts, setEditedPrompts] = useState<Record<string, string>>({});
  const [generations, setGenerations] = useState<Record<string, GenerationResult[]>>(
    displayData.generations || {}
  );
  const [selectedContentId, setSelectedContentId] = useState<string | null>(null);
  const [loadingPrompts, setLoadingPrompts] = useState<Set<string>>(new Set());
  const [progress, setProgress] = useState<{ elapsed_ms: number; message: string } | null>(null);

  // Refs for getResponse closure
  const selectedRef = useRef(selectedContentId);
  selectedRef.current = selectedContentId;
  const generationsRef = useRef(generations);
  generationsRef.current = generations;

  // Register provider with InteractionHost
  useEffect(() => {
    updateProvider({
      getState: () => ({
        isValid: selectedRef.current !== null,
        selectedCount: selectedRef.current ? 1 : 0,
        selectedGroupIds: [],
      }),
      getResponse: () => ({
        selected_content_id: selectedRef.current,
        generations: generationsRef.current,
      }),
    });
  }, [updateProvider]);

  // Update provider when selection changes
  useEffect(() => {
    updateProvider({
      getState: () => ({
        isValid: selectedContentId !== null,
        selectedCount: selectedContentId ? 1 : 0,
        selectedGroupIds: [],
      }),
      getResponse: () => ({
        selected_content_id: selectedRef.current,
        generations: generationsRef.current,
      }),
    });
  }, [selectedContentId, updateProvider]);

  // Get prompt text for editing
  // If display_format exists, render and show that for editing
  // Otherwise fall back to individual field editing
  const getPromptText = useCallback((provider: string, promptId: string, promptData: any) => {
    const promptKey = `${provider}:${promptId}`;

    // Check if user has edited this prompt
    if (editedPrompts[promptKey] !== undefined) {
      return editedPrompts[promptKey];
    }

    // Get schema for this prompt to check for display_format
    const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
    const ux = getUx(promptSchema || {});

    if (ux.display_format) {
      // Render the combined format
      return renderTemplate(ux.display_format, promptData, {});
    }

    // Fallback: join field values
    if (typeof promptData === 'string') {
      return promptData;
    }
    return Object.values(promptData).join(' ');
  }, [editedPrompts, schema]);

  // Handle prompt text editing
  const handlePromptEdit = (provider: string, promptId: string, text: string) => {
    const promptKey = `${provider}:${promptId}`;
    setEditedPrompts(prev => ({ ...prev, [promptKey]: text }));
  };

  // Execute sub-action (generate images)
  const handleSubAction = async (
    actionConfig: SubActionConfig,
    provider: string,
    promptId: string,
    promptData: any
  ) => {
    const promptKey = `${provider}:${promptId}`;
    setLoadingPrompts(prev => new Set(prev).add(promptKey));
    setProgress(null);

    try {
      // Get edited prompt text or original
      const promptText = getPromptText(provider, promptId, promptData);

      // Get input_schema params from schema
      const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
      const ux = getUx(promptSchema || {});
      const inputSchema = ux.input_schema?.properties || {};

      // Build params with defaults from input_schema
      const params: Record<string, any> = { prompt: promptText };
      for (const [key, fieldSchema] of Object.entries(inputSchema as Record<string, any>)) {
        if (fieldSchema.default !== undefined) {
          params[key] = fieldSchema.default;
        }
      }

      const response = await fetch(
        `/api/workflow/${request.workflow_run_id}/sub-action`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interaction_id: request.interaction_id,
            provider,
            action_type: actionConfig.action_type,
            prompt_id: promptId,
            params,
            source_data: promptData
          })
        }
      );

      // Parse SSE stream
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (reader) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        // Parse SSE events
        const lines = buffer.split('\n');
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.startsWith('event: ')) {
            const eventType = line.slice(7);
            continue;
          }
          if (line.startsWith('data: ')) {
            const eventData = JSON.parse(line.slice(6));

            if (eventData.elapsed_ms !== undefined) {
              setProgress(eventData);
            }

            if (eventData.urls) {
              // Generation complete
              setGenerations(prev => ({
                ...prev,
                [promptKey]: [...(prev[promptKey] || []), eventData]
              }));
            }
          }
        }
      }
    } finally {
      setLoadingPrompts(prev => {
        const next = new Set(prev);
        next.delete(promptKey);
        return next;
      });
      setProgress(null);
    }
  };

  // Extract providers and their prompts from data
  const providers = Object.keys(data?.prompts || {});

  return (
    <div className="space-y-6">
      {providers.map(provider => {
        const providerPrompts = data.prompts[provider] as Record<string, any>;
        const promptIds = Object.keys(providerPrompts);

        return (
          <div key={provider} className="space-y-4">
            <h3 className="text-lg font-semibold capitalize">{provider}</h3>

            {promptIds.map(promptId => {
              const promptKey = `${provider}:${promptId}`;
              const promptData = providerPrompts[promptId];
              const promptText = getPromptText(provider, promptId, promptData);
              const isLoading = loadingPrompts.has(promptKey);
              const promptGenerations = generations[promptKey] || [];

              return (
                <div key={promptId} className="border rounded-lg p-4 space-y-4">
                  {/* Prompt Label */}
                  <div className="font-medium">{promptId.replace(/_/g, ' ')}</div>

                  {/* Editable Prompt Text (from display_format) */}
                  <Textarea
                    value={promptText}
                    onChange={(e) => handlePromptEdit(provider, promptId, e.target.value)}
                    disabled={disabled || isReadonly || isLoading}
                    className="min-h-[100px] font-mono text-sm"
                  />

                  {/* Generation Parameters (from input_schema) */}
                  {!isReadonly && (
                    <PromptParams
                      provider={provider}
                      promptId={promptId}
                      schema={schema}
                      disabled={disabled || isLoading}
                    />
                  )}

                  {/* Generated Images Grid */}
                  {promptGenerations.length > 0 && (
                    <MediaGrid
                      generations={promptGenerations}
                      selectedContentId={selectedContentId}
                      onSelect={setSelectedContentId}
                    />
                  )}

                  {/* Progress indicator */}
                  {isLoading && progress && (
                    <div className="text-sm text-muted-foreground">
                      {progress.message} ({Math.round(progress.elapsed_ms / 1000)}s)
                    </div>
                  )}

                  {/* Sub-action buttons via ActionSlot */}
                  {!isReadonly && subActions?.map(action => (
                    <ActionSlot key={`${promptKey}-${action.id}`} id={`${promptKey}-${action.id}`}>
                      <Button
                        variant="outline"
                        onClick={() => handleSubAction(action, provider, promptId, promptData)}
                        disabled={disabled || isLoading}
                      >
                        {isLoading ? action.loading_label || 'Processing...' : action.label}
                      </Button>
                    </ActionSlot>
                  ))}
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
}

// Separate component for generation parameters (from input_schema)
function PromptParams({ provider, promptId, schema, disabled }: {
  provider: string;
  promptId: string;
  schema: any;
  disabled: boolean;
}) {
  const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
  const ux = getUx(promptSchema || {});
  const inputSchema = ux.input_schema;

  if (!inputSchema?.properties) return null;

  // Render flat form fields from input_schema
  // Uses flat properties: input_type, width, etc. (not nested _ux)
  return (
    <div className="grid grid-cols-3 gap-4">
      {Object.entries(inputSchema.properties as Record<string, any>).map(([key, fieldSchema]) => (
        <ParamField
          key={key}
          name={key}
          schema={fieldSchema}
          disabled={disabled}
        />
      ))}
    </div>
  );
}

function ParamField({ name, schema, disabled }: {
  name: string;
  schema: any;
  disabled: boolean;
}) {
  // Schema has flat properties: input_type, width, enum, etc.
  const inputType = schema.input_type || 'text';
  const title = schema.title || name;

  // Render based on input_type (flat property)
  if (schema.enum) {
    return (
      <div className="space-y-1">
        <label className="text-sm font-medium">{title}</label>
        <select disabled={disabled} defaultValue={schema.default}>
          {schema.enum.map((opt: string) => (
            <option key={opt} value={opt}>
              {schema.enum_labels?.[opt] || opt}
            </option>
          ))}
        </select>
      </div>
    );
  }

  if (inputType === 'slider') {
    return (
      <div className="space-y-1">
        <label className="text-sm font-medium">{title}</label>
        <input
          type="range"
          min={schema.minimum}
          max={schema.maximum}
          defaultValue={schema.default}
          disabled={disabled}
        />
      </div>
    );
  }

  return null;
}

// Media grid for generated images
function MediaGrid({ generations, selectedContentId, onSelect }: {
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelect: (id: string) => void;
}) {
  const allContent = generations.flatMap(gen =>
    gen.content_ids.map((id, idx) => ({
      contentId: id,
      url: gen.urls[idx],
    }))
  );

  return (
    <div className="grid grid-cols-4 gap-2">
      {allContent.map(item => (
        <div
          key={item.contentId}
          className={cn(
            'relative cursor-pointer rounded-md overflow-hidden border-2',
            selectedContentId === item.contentId
              ? 'border-primary'
              : 'border-transparent hover:border-muted'
          )}
          onClick={() => onSelect(item.contentId)}
        >
          <img
            src={item.url}
            alt=""
            className="w-full h-auto aspect-square object-cover"
          />
          {selectedContentId === item.contentId && (
            <div className="absolute top-1 right-1 bg-primary text-primary-foreground rounded-full p-1">
              <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Index Export

```typescript
// webui/src/components/workflow/interactions/media-generation/index.ts

export { MediaGeneration } from "./MediaGeneration";
```

### InteractionHost Update

Add the new interaction type to the content router:

```typescript
// webui/src/components/workflow/interactions/InteractionHost.tsx

import { MediaGeneration } from "./media-generation";

function InteractionContent({ type }: { type: string }) {
  switch (type) {
    case "text_input":
      return <TextInputEnhanced />;
    case "file_input":
      return <FileInputDropzone />;
    case "file_download":
      return <FileDownload />;
    case "select_from_structured":
      return <StructuredSelect />;
    case "review_grouped":
      return <ReviewGrouped />;
    case "form_input":
      return <FormInput />;
    case "media_generation":  // ADD THIS
      return <MediaGeneration />;
    default:
      return (
        <div className="p-4 text-center text-muted-foreground">
          Unsupported interaction type: {type}
        </div>
      );
  }
}
```

### TypeScript Types

```typescript
// webui/src/lib/types.ts (additions)

export interface SubActionConfig {
  id: string;
  label: string;
  action_type: string;
  loading_label?: string;
  result_key: string;
}

export interface GenerationResult {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}
```

---

## Database Schema

```sql
-- Metadata for each generation request
CREATE TABLE content_generation_metadata (
    content_generation_metadata_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    interaction_id TEXT NOT NULL,
    provider TEXT NOT NULL,
    prompt_id TEXT NOT NULL,
    operation TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    status TEXT DEFAULT 'pending',
    request_params JSONB,
    source_data JSONB,
    response_data JSONB,
    error_message TEXT,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id)
);

-- Individual generated content items
CREATE TABLE generated_content (
    generated_content_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    content_generation_metadata_id TEXT NOT NULL,
    index INTEGER NOT NULL,
    content_type TEXT NOT NULL,
    provider_url TEXT NOT NULL,
    local_path TEXT,
    downloaded_at TIMESTAMP,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id),
    FOREIGN KEY (content_generation_metadata_id)
        REFERENCES content_generation_metadata(content_generation_metadata_id)
);

-- Indexes
CREATE INDEX idx_cgm_workflow_run ON content_generation_metadata(workflow_run_id);
CREATE INDEX idx_cgm_interaction ON content_generation_metadata(interaction_id);
CREATE INDEX idx_gc_workflow_run ON generated_content(workflow_run_id);
CREATE INDEX idx_gc_metadata ON generated_content(content_generation_metadata_id);
```

---

## Key WebUI Architecture Points

### 1. InteractionHost is Always the Wrapper

Child components do NOT:
- Render Continue/Retry buttons
- Handle submission directly
- Wrap themselves in context providers

Child components DO:
- Call `updateProvider({ getState, getResponse })` to register
- Use `ActionSlot` for custom action buttons
- Use `useInteraction()` to access request data and disabled state

### 2. ActionSlot Pattern for Sub-Action Buttons

Instead of rendering buttons directly, use ActionSlot:

```typescript
// CORRECT - buttons appear in InteractionHost footer
<ActionSlot id="generate-btn">
  <Button onClick={handleGenerate}>Generate</Button>
</ActionSlot>

// INCORRECT - don't render buttons directly
<div className="flex gap-2">
  <Button onClick={handleGenerate}>Generate</Button>  // DON'T DO THIS
</div>
```

### 3. display_format for Combined Text Editing

When `display_format` exists in schema:
- Render the Jinja2 template to get combined text
- Show combined text in editable textarea
- User edits the combined text, NOT individual fields
- Send edited text as the prompt for generation

This matches existing patterns in `midjourney_display_schema.json`.

### 4. input_schema for Generation Parameters

Parameters like `aspect_ratio`, `speed`, `stylization` come from `_ux.input_schema`:
- Properties use flat fields: `input_type`, `width`, `enum`, `default`
- NOT nested `_ux` inside each property
- Matches existing `aesthetic_form_schema.json` pattern

---

## File Structure

```
server/
├── workflow/
│   ├── executor.py              # Add context.sub_actions extraction
│   └── sub_action/
│       ├── __init__.py
│       ├── registry.py          # register_provider, get_provider
│       ├── executor.py          # execute_sub_action_stream
│       └── providers/
│           ├── __init__.py      # Import all to trigger registration
│           ├── base.py          # MediaProviderBase (abstract)
│           ├── midjourney.py    # MidJourneyProvider class
│           └── leonardo.py      # LeonardoProvider class
│
├── api/
│   └── routes/
│       └── workflow.py          # Add POST /{id}/sub-action endpoint
│
└── db/
    └── content_repository.py    # ContentRepository

webui/src/
├── components/
│   └── workflow/
│       └── interactions/
│           ├── media-generation/        # NEW folder
│           │   ├── index.ts
│           │   └── MediaGeneration.tsx
│           └── InteractionHost.tsx      # Add media_generation case
│
└── lib/
    └── types.ts                 # SubActionConfig, GenerationResult types
```

---

## Summary of Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Sub-action config | Array (like `retryable.options`) | Consistent with existing patterns |
| Provider determination | Runtime from data keys | Data contains prompts for multiple providers |
| `action_type` | Generic operation (`txt2img`) | Provider not known at config time |
| `input_schema` properties | Flat (not nested `_ux`) | Matches existing `aesthetic_form_schema.json` pattern |
| Provider implementation | Classes with methods | Follows R3 design |
| Registry | Maps provider name → class | Simple lookup, class handles operations |
| Where sub_actions lives | `display_data.sub_actions` | Parallel to `display_data.retryable` |
| Storage | Database tables | Enables resume, history |
| Component architecture | New `media_generation` type | Clean separation, follows existing patterns |
| Button rendering | ActionSlot pattern | Buttons appear in InteractionHost footer |
| Prompt editing | Render `display_format`, edit combined text | Users edit final prompt, not individual fields |
