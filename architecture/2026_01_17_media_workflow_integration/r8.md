# Media Generation Workflow Integration Architecture - R8

## Summary

Design for integrating media generation (images/videos) into workflows via a **sub-action system**. Users can iteratively generate content from prompts, adjust parameters, regenerate, and select results—all within a single interaction step.

**Key Design Decisions:**
- Sub-actions follow the same pattern as retryables (defined in module config, passed through context, put in display_data)
- Schema-driven layouts using semantic `_ux` hints
- Editable fields via `schema._ux.input_schema`
- Single image selection per interaction
- All generations stored in database for history/resume

---

## Data Flow Pattern

Sub-actions follow the **exact same pattern as retryables**:

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Workflow JSON (module config)                                │
│                                                                 │
│    "sub_actions": {                                             │
│      "generate": { "action_type": "media.midjourney.txt2img" }  │
│    }                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Executor puts on context                                     │
│                                                                 │
│    context.sub_actions = module_config.get('sub_actions')       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Module extracts from context, puts in display_data           │
│                                                                 │
│    sub_actions = getattr(context, 'sub_actions', None)          │
│    display_data = {                                             │
│        "data": prompts,                                         │
│        "schema": display_schema,                                │
│        "sub_actions": sub_actions,  # <-- Like retryable        │
│    }                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI reads request.display_data.sub_actions                 │
│                                                                 │
│    const subActions = request.display_data?.sub_actions;        │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prompts Data Structure

Prompts from previous workflow step, grouped by provider:

```json
{
  "prompts": {
    "midjourney": {
      "prompt_a": {
        "subject": "contemplative person in partial profile...",
        "environment": "snug indoor room, exposed brick walls...",
        "objects": "small side table with warm lamp...",
        "motion": "lamp glow gently pulsing...",
        "atmosphere": "warm, dim, introspective...",
        "particles": "dust particles glowing..."
      },
      "prompt_b": {
        "subject": "quiet journaling person in armchair...",
        "environment": "intimate, safe room mood..."
      }
    },
    "leonardo": {
      "phoenix_1_0": "Primary subject: a contemplative person nestled in a cushioned armchair...",
      "anime_xl": "Primary subject: a contemplative person nestled in a cozy armchair..."
    }
  }
}
```

**Structure:** `prompts[provider][prompt_id] = prompt_content`

---

## Workflow Module Configuration

### Step JSON

```json
{
  <!--just to confirm, is this the correct module_id?-->
  "module_id": "user.select",
  "inputs": {
    "data": "{{ state.generated_prompts }}",
    "schema": {
      "$ref": "schemas/media_generation_display_schema.json",
      "type": "json"
    },
    "prompt": "Generate and Select Images",
    "mode": "select",
    "multi_select": false
  },
  "sub_actions": {
    <!--i think sub actions should be an array-->
    "generate": {
      "label": "Generate Images",
      <!--i dont think we know the provider (midhjourny in following line) at module level. this module contains 
      data from any provider user selected in start of step. Only thing this can have is, action_type=txt2img
      which we know for sure.-->
      "action_type": "media.midjourney.txt2img",
      "loading_label": "Generating...",
      "result_key": "generations"
    }
  },
  "outputs_to_state": {
    "selected_indices": "selected_content",
    "selected_data": "selected_content_data"
  },
  "name": "generate_and_select"
}
```

### Sub-Action Config Schema

```typescript
interface SubActionConfig {
  label: string;           // Button text: "Generate Images"
  action_type: string;     // Registry key: "media.midjourney.txt2img"
  loading_label?: string;  // "Generating..."
  result_key: string;      // Where results accumulate in display_data
}
```

---

## Display Schema with Editable Fields

The display schema uses `_ux.input_schema` for editable prompt fields:

<!--input_schema not meant to have _ux nodes inside it, as its schema we created for our purposes. but in the same time
i see why they feels belong there. do this research, confirm when we are reading input_schema, whether we look for data
inside _ux or in flat node. also i dont feel like use use of _ux here is wrong anyways, look into how they work in
the first place. -->

```json
{
  "type": "object",
  "_ux": {
    "display": "passthrough"
  },
  "properties": {
    "prompts": {
      "type": "object",
      "_ux": {
        "display": "passthrough"
      },
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "render_as": "section",
            "display_label": "Midjourney",
            "selectable": true
          },
          "properties": {
            "prompt_a": {
              "type": "object",
              "_ux": {
                "display": "visible",
                "render_as": "card",
                "display_label": "Prompt A (Weighted)",
                "input_schema": {
                  "type": "object",
                  "_ux": {
                    "layout": "sections"
                  },
                  "properties": {
                    "subject": {
                      "type": "string",
                      "title": "Subject",
                      "_ux": {
                        "input_type": "textarea",
                        "group": "prompt",
                        "group_label": "Prompt Components",
                        "width": "full"
                      }
                    },
                    "environment": {
                      "type": "string",
                      "title": "Environment",
                      "_ux": {
                        "input_type": "textarea",
                        "group": "prompt",
                        "width": "full"
                      }
                    },
                    "aspect_ratio": {
                      "type": "string",
                      "title": "Aspect Ratio",
                      "enum": ["1:1", "16:9", "9:16", "4:3"],
                      "default": "16:9",
                      "_ux": {
                        "input_type": "select",
                        "group": "params",
                        "group_label": "Generation Parameters",
                        "width": "third"
                      }
                    },
                    "speed": {
                      "type": "string",
                      "title": "Speed",
                      "enum": ["relaxed", "fast", "turbo"],
                      "default": "fast",
                      "_ux": {
                        "input_type": "select",
                        "group": "params",
                        "width": "third"
                      }
                    },
                    "stylization": {
                      "type": "integer",
                      "title": "Stylization",
                      "minimum": 0,
                      "maximum": 1000,
                      "default": 100,
                      "_ux": {
                        "input_type": "slider",
                        "group": "params",
                        "width": "full"
                      }
                    }
                  }
                }
              },
              "properties": {
                "subject": { "type": "string", "_ux.display_label": "Subject" },
                "environment": { "type": "string", "_ux.display_label": "Environment" },
                "objects": { "type": "string", "_ux.display_label": "Objects" },
                "motion": { "type": "string", "_ux.display_label": "Motion" },
                "atmosphere": { "type": "string", "_ux.display_label": "Atmosphere" },
                "particles": { "type": "string", "_ux.display_label": "Particles" }
              }
            }
          }
        }
      }
    }
  }
}
```

### `_ux` Layout Hints (Semantic, Not CSS)

| Hint | Values | Purpose |
|------|--------|---------|
| `layout` | `"vertical"`, `"horizontal"`, `"sections"`, `"grid"` | Form layout mode |
| `width` | `"full"`, `"half"`, `"third"`, `"quarter"`, `"auto"` | Field width (maps to grid) |
| `group` | `string` | Group ID for sections |
| `group_label` | `string` | Label for first field in group |
| `input_type` | `"text"`, `"textarea"`, `"select"`, `"slider"`, `"number"` | Input control type |

Component maps these to actual classes internally—schema authors don't need CSS knowledge.

---

## Server Implementation

### Executor Change (Parallel to Retryable)

```python
# server/workflow/executor.py

# In execute_step_modules, where retryable is set:
context.retryable = module_config.get('retryable')
context.sub_actions = module_config.get('sub_actions')  # ADD THIS
```

### Module Implementation

The existing `user.select` module can be extended, or a new module created:

```python
# server/modules/user/select.py (extended)

def get_interaction_request(
    self,
    inputs: Dict[str, Any],
    context
) -> Optional[InteractionRequest]:
    data = inputs['data']
    schema = inputs['schema']
    prompt = self.get_input_value(inputs, 'prompt')
    multi_select = self.get_input_value(inputs, 'multi_select')
    mode = self.get_input_value(inputs, 'mode')

    # Get configs from context (set by executor from module config)
    retryable = getattr(context, 'retryable', None)
    sub_actions = getattr(context, 'sub_actions', None)

    return InteractionRequest(
        interaction_type=InteractionType.SELECT_FROM_STRUCTURED,
        interaction_id=f"select_{uuid6.uuid7().hex}",
        title=prompt,
        display_data={
            "data": data,
            "schema": schema,
            "multi_select": multi_select,
            "mode": mode,
            "retryable": retryable,
            "sub_actions": sub_actions,      # <-- Like retryable
            "generations": {}                 # Accumulates sub-action results
        },
        context={
            "module_id": self.module_id
        }
    )
```

### Sub-Action Registry

```python
# server/workflow/sub_action/registry.py

from typing import Dict, Tuple, Type, Callable

# Registry: action_type -> handler function
_SUB_ACTION_REGISTRY: Dict[str, Callable] = {}


def register_sub_action(action_type: str, handler: Callable):
    """Register a sub-action handler."""
    _SUB_ACTION_REGISTRY[action_type] = handler


def get_sub_action_handler(action_type: str) -> Callable:
    """Get the handler for an action type."""
    if action_type not in _SUB_ACTION_REGISTRY:
        raise ValueError(f"Unknown action type: {action_type}")
    return _SUB_ACTION_REGISTRY[action_type]
```

### Provider Registration

```python
# server/workflow/sub_action/providers/midjourney.py

from ..registry import register_sub_action


<!--why does this prefix midjourney? isnt midjorney meant to be class implemented from base provider class?
did you read r5 properly, or is this how r5 describe things?-->
def midjourney_txt2img(params: dict, progress_callback=None) -> Tuple[List[str], dict]:
    """Generate images via MidAPI. Returns (urls, raw_response)."""
    from server.modules.api.providers.midapi import MidAPIClient

    client = MidAPIClient()
    return client.txt2img(params, progress_callback=progress_callback)


# Register on module load
register_sub_action("media.midjourney.txt2img", midjourney_txt2img)
register_sub_action("media.midjourney.img2img", midjourney_img2img)
```

### Sub-Action API Route

```python
# server/api/routes/workflow.py

from sse_starlette.sse import EventSourceResponse


class SubActionRequest(BaseModel):
    """Request to execute a sub-action."""
    interaction_id: str
    action_type: str              # "media.midjourney.txt2img"
    provider: str                 # "midjourney"
    prompt_id: str                # "prompt_a"
    params: Dict[str, Any]        # Generation parameters
    source_data: Any              # Full prompt data


@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db)
):
    """Execute a sub-action with SSE streaming."""
    return EventSourceResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        send_timeout=5
    )
```

### Sub-Action Executor (SSE Streaming)

```python
# server/workflow/sub_action/executor.py

import asyncio
import json
import time
import concurrent.futures

from .registry import get_sub_action_handler


def sse_event(event_type: str, data: dict) -> str:
    """Format SSE event."""
    return f"event: {event_type}\ndata: {json.dumps(data)}\n\n"


async def execute_sub_action_stream(
    workflow_run_id: str,
    request: SubActionRequest,
    db
):
    """
    Execute sub-action and stream progress via SSE.
    Stores results in database but does NOT advance workflow state.
    """
    action_id = f"sa_{uuid6.uuid7().hex[:8]}"
    yield sse_event("started", {"action_id": action_id})

    try:
        # 1. Lookup handler from registry
        handler = get_sub_action_handler(request.action_type)

        # 2. Setup progress tracking
        loop = asyncio.get_event_loop()
        progress_queue = asyncio.Queue()

        def progress_callback(elapsed_ms: int, message: str):
            loop.call_soon_threadsafe(
                progress_queue.put_nowait,
                {"elapsed_ms": elapsed_ms, "message": message}
            )

        # 3. Run generation in thread pool (providers are sync)
        executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
        future = loop.run_in_executor(
            executor,
            lambda: handler(request.params, progress_callback=progress_callback)
        )

        # 4. Stream progress while waiting
        while not future.done():
            try:
                progress = await asyncio.wait_for(progress_queue.get(), timeout=0.5)
                yield sse_event("progress", progress)
            except asyncio.TimeoutError:
                pass

        # 5. Get result
        urls, raw_response = await future

        # 6. Store metadata in database
        metadata_id = db.content_repo.store_generation(
            workflow_run_id=workflow_run_id,
            interaction_id=request.interaction_id,
            provider=request.provider,
            prompt_id=request.prompt_id,
            operation="txt2img",
            request_params=request.params,
            source_data=request.source_data,
            response_data=raw_response
        )

        # 7. Store individual content items
        content_ids = []
        for index, url in enumerate(urls):
            content_id = db.content_repo.store_content(
                metadata_id=metadata_id,
                workflow_run_id=workflow_run_id,
                index=index,
                provider_url=url,
                content_type="image"
            )
            content_ids.append(content_id)

        # 8. Send completion event
        yield sse_event("complete", {
            "urls": urls,
            "metadata_id": metadata_id,
            "content_ids": content_ids
        })

    except Exception as e:
        yield sse_event("error", {"message": str(e)})
```

---

## WebUI Implementation

### StructuredSelect Extension

The existing `StructuredSelect` component handles `sub_actions` from `display_data`:

```typescript
// webui/src/components/workflow/interactions/structured-select.tsx

export function StructuredSelect() {
  const { request, disabled, updateProvider, mode } = useInteraction();

  const displayData = request.display_data || {};
  const data = displayData.data;
  const schema = displayData.schema;
  const subActions = displayData.sub_actions as Record<string, SubActionConfig> | undefined;

  // Track generations per prompt
  const [generations, setGenerations] = useState<Record<string, GenerationResult[]>>(
    displayData.generations || {}
  );

  // Loading state per prompt
  const [loadingPrompts, setLoadingPrompts] = useState<Set<string>>(new Set());

  // Handle sub-action execution
  const handleSubAction = async (
    actionKey: string,
    provider: string,
    promptId: string,
    params: Record<string, any>
  ) => {
    if (!subActions) return;

    const config = subActions[actionKey];
    const promptKey = `${provider}:${promptId}`;

    setLoadingPrompts(prev => new Set(prev).add(promptKey));

    try {
      const response = await fetch(
        `${API_URL}/workflow/${workflowRunId}/sub-action`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interaction_id: request.interaction_id,
            action_type: config.action_type,
            provider,
            prompt_id: promptId,
            params,
            source_data: getPromptData(data, provider, promptId)
          })
        }
      );

      // Parse SSE stream
      const reader = response.body?.getReader();
      // ... handle SSE events similar to useWorkflowStream

    } finally {
      setLoadingPrompts(prev => {
        const next = new Set(prev);
        next.delete(promptKey);
        return next;
      });
    }
  };

  // Render with sub-action buttons if configured
  return (
    <div>
      <SchemaRenderer
        data={data}
        schema={schema}
        // Pass sub-action handlers to schema renderer context
        subActionContext={{
          subActions,
          generations,
          loadingPrompts,
          onSubAction: handleSubAction
        }}
      />
    </div>
  );
}
```

### SubActionButton Component

```typescript
// webui/src/components/common/SubActionButton.tsx

interface SubActionButtonProps {
  config: SubActionConfig;
  onClick: () => void;
  loading: boolean;
  progress?: { elapsed_ms: number; message: string };
}

export function SubActionButton({ config, onClick, loading, progress }: SubActionButtonProps) {
  return (
    <div className="flex flex-col gap-2">
      <Button onClick={onClick} disabled={loading}>
        {loading ? config.loading_label || 'Processing...' : config.label}
      </Button>

      {loading && progress && (
        <div className="text-sm text-muted-foreground">
          {progress.message} ({Math.round(progress.elapsed_ms / 1000)}s)
        </div>
      )}
    </div>
  );
}
```

### SchemaFormRenderer Component

Renders editable forms from `schema._ux.input_schema`:

```typescript
// webui/src/components/common/SchemaFormRenderer.tsx

interface Props {
  schema: InputSchema;
  values: Record<string, any>;
  onChange: (values: Record<string, any>) => void;
  disabled?: boolean;
}

export function SchemaFormRenderer({ schema, values, onChange, disabled }: Props) {
  const ux = getUx(schema);
  const layout = ux.layout || 'vertical';
  const properties = schema.properties || {};

  // Group fields by group ID
  const groups = groupFieldsByGroup(properties);

  if (layout === 'sections') {
    return (
      <div className="space-y-6">
        {Object.entries(groups).map(([groupId, fields]) => (
          <FormSection key={groupId} label={getGroupLabel(fields)}>
            <FormFieldGroup
              fields={fields}
              values={values}
              onChange={onChange}
              disabled={disabled}
            />
          </FormSection>
        ))}
      </div>
    );
  }

  // Default: vertical layout
  return (
    <div className="space-y-4">
      {Object.entries(properties).map(([key, fieldSchema]) => (
        <FormField
          key={key}
          name={key}
          schema={fieldSchema}
          value={values[key]}
          onChange={(v) => onChange({ ...values, [key]: v })}
          disabled={disabled}
        />
      ))}
    </div>
  );
}

function FormFieldWrapper({ fieldSchema, children }) {
  const ux = getUx(fieldSchema);

  // Map width hint to Tailwind classes (internal mapping)
  const widthClass = {
    full: 'col-span-full',
    half: 'md:col-span-1',
    third: 'md:col-span-1',
    quarter: 'md:col-span-1',
    auto: ''
  }[ux.width || 'auto'];

  return <div className={widthClass}>{children}</div>;
}
```

### MediaGrid Component

```typescript
// webui/src/components/common/MediaGrid.tsx

interface MediaGridProps {
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelect: (contentId: string) => void;
}

export function MediaGrid({ generations, selectedContentId, onSelect }: MediaGridProps) {
  const allContent = generations.flatMap(gen =>
    gen.content_ids.map((id, idx) => ({
      contentId: id,
      url: gen.urls[idx],
      metadataId: gen.metadata_id
    }))
  );

  if (allContent.length === 0) return null;

  return (
    <div className="grid grid-cols-4 gap-2">
      {allContent.map(item => (
        <div
          key={item.contentId}
          className={cn(
            'relative cursor-pointer rounded-md overflow-hidden border-2',
            selectedContentId === item.contentId
              ? 'border-primary'
              : 'border-transparent'
          )}
          onClick={() => onSelect(item.contentId)}
        >
          <img
            src={item.url}
            alt=""
            className="w-full h-auto aspect-square object-cover"
          />
          {selectedContentId === item.contentId && (
            <div className="absolute top-1 right-1 bg-primary text-primary-foreground rounded-full p-1">
              <CheckIcon className="w-3 h-3" />
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

## Database Schema

```sql
-- Metadata for each generation request
CREATE TABLE content_generation_metadata (
    content_generation_metadata_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    interaction_id TEXT NOT NULL,
    provider TEXT NOT NULL,
    prompt_id TEXT NOT NULL,
    operation TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    status TEXT DEFAULT 'pending',
    request_params JSONB,
    source_data JSONB,
    response_data JSONB,
    error_message TEXT,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id)
);

-- Individual generated content items
CREATE TABLE generated_content (
    generated_content_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    content_generation_metadata_id TEXT NOT NULL,
    index INTEGER NOT NULL,
    content_type TEXT NOT NULL,
    provider_url TEXT NOT NULL,
    local_path TEXT,
    downloaded_at TIMESTAMP,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id),
    FOREIGN KEY (content_generation_metadata_id)
        REFERENCES content_generation_metadata(content_generation_metadata_id)
);

-- Indexes
CREATE INDEX idx_cgm_workflow_run ON content_generation_metadata(workflow_run_id);
CREATE INDEX idx_cgm_interaction ON content_generation_metadata(interaction_id);
CREATE INDEX idx_gc_workflow_run ON generated_content(workflow_run_id);
CREATE INDEX idx_gc_metadata ON generated_content(content_generation_metadata_id);
```

### Repository

```python
# server/db/content_repository.py

class ContentRepository:
    def __init__(self, db):
        self.db = db

    def store_generation(
        self,
        workflow_run_id: str,
        interaction_id: str,
        provider: str,
        prompt_id: str,
        operation: str,
        request_params: dict,
        source_data: any,
        response_data: dict
    ) -> str:
        """Store generation metadata. Returns metadata_id."""
        metadata_id = f"cgm_{uuid6.uuid7().hex}"
        # ... insert into content_generation_metadata
        return metadata_id

    def store_content(
        self,
        metadata_id: str,
        workflow_run_id: str,
        index: int,
        provider_url: str,
        content_type: str
    ) -> str:
        """Store individual content item. Returns content_id."""
        content_id = f"gc_{uuid6.uuid7().hex}"
        # ... insert into generated_content
        return content_id

    def get_generations_for_interaction(self, interaction_id: str) -> list:
        """Get all generations for an interaction (for resuming)."""
        # ... query both tables joined
        pass
```

---

## Complete Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Previous Module Output (state.generated_prompts)             │
│                                                                 │
│ { "prompts": {                                                  │
│     "midjourney": { "prompt_a": {...} },                        │
│     "leonardo": { "phoenix_1_0": "..." }                        │
│ }}                                                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Server: Module.get_interaction_request()                     │
│                                                                 │
│ InteractionRequest(                                             │
│   interaction_type=SELECT_FROM_STRUCTURED,                      │
│   display_data={                                                │
│     "data": prompts,                                            │
│     "schema": display_schema,  # has _ux.input_schema           │
│     "sub_actions": {...},      # from context                   │
│     "generations": {}          # accumulates results            │
│   }                                                             │
│ )                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. WebUI: StructuredSelect renders                              │
│                                                                 │
│ - SchemaRenderer shows prompts (editable via input_schema)      │
│ - SubActionButton for each provider/prompt                      │
│ - MediaGrid shows generated images                              │
└─────────────────────────────────────────────────────────────────┘
                              │
              [User edits prompt, clicks "Generate Images"]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI: POST /workflow/{id}/sub-action                        │
│                                                                 │
│ {                                                               │
│   "interaction_id": "select_xxx",                               │
│   "action_type": "media.midjourney.txt2img",                    │
│   "provider": "midjourney",                                     │
│   "prompt_id": "prompt_a",                                      │
│   "params": { "aspect_ratio": "16:9", ... },                    │
│   "source_data": { "subject": "...", ... }                      │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. Server: execute_sub_action_stream()                          │
│                                                                 │
│ a) Registry lookup → handler function                           │
│ b) handler(params) → calls provider API                         │
│ c) SSE: progress events during polling                          │
│ d) Store in content_generation_metadata + generated_content     │
│ e) SSE: complete { urls, metadata_id, content_ids }             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. WebUI: Update generations state, show images in grid         │
│                                                                 │
│ User can:                                                       │
│   - Adjust params and click "Generate" again                    │
│   - Click an image to select it                                 │
│   - Click "Continue" when satisfied                             │
└─────────────────────────────────────────────────────────────────┘
                              │
                    [User clicks "Continue"]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 7. WebUI: Normal interaction response                           │
│                                                                 │
│ {                                                               │
│   "selected_indices": ["midjourney:prompt_a:gc_xxx"],           │
│   "selected_options": [...]                                     │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 8. Server: Module.execute_with_response()                       │
│                                                                 │
│ Returns to workflow state:                                      │
│ {                                                               │
│   "selected_indices": [...],                                    │
│   "selected_data": { content_id, url, ... }                     │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
server/
├── workflow/
│   ├── executor.py              # Add context.sub_actions extraction
│   └── sub_action/
│       ├── __init__.py
│       ├── registry.py          # register_sub_action, get_sub_action_handler
│       ├── executor.py          # execute_sub_action_stream
│       └── providers/
│           ├── __init__.py      # Import all to trigger registration
│           ├── midjourney.py    # midjourney_txt2img, etc.
│           └── leonardo.py
│
├── api/
│   └── routes/
│       └── workflow.py          # Add POST /{id}/sub-action endpoint
│
└── db/
    └── content_repository.py    # ContentRepository

webui/src/
├── components/
│   ├── common/
│   │   ├── SchemaFormRenderer.tsx
│   │   ├── SubActionButton.tsx
│   │   └── MediaGrid.tsx
│   │
│   └── workflow/
│       └── interactions/
│           └── structured-select.tsx  # Extended with sub-action support
│
└── lib/
    └── types.ts                 # SubActionConfig type
```

---

## Summary of Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Sub-action pattern | Same as retryable | Proven pattern, minimal contract changes |
| Where sub_actions lives | `display_data.sub_actions` | Parallel to `display_data.retryable` |
| Editable fields | `schema._ux.input_schema` | Existing pattern for form-style inputs |
| Layout system | Semantic `_ux` hints | Avoids Tailwind purging, TypeScript validation |
| Sub-action endpoint | POST with SSE response | Matches existing streaming patterns |
| Storage | Database tables | Enables resume, history |
| Selection | Via existing selected_indices | Uses existing module output pattern |
