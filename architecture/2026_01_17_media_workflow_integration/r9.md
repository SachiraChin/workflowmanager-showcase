# Media Generation Workflow Integration Architecture - R9

## Summary

Design for integrating media generation (images/videos) into workflows via a **sub-action system**. Users can iteratively generate content from prompts, adjust parameters, regenerate, and select results—all within a single interaction step.

**Key Design Decisions:**
- Sub-actions follow the same pattern as retryables (defined in module config, passed through context, put in display_data)
- `sub_actions` is an **array** (like `retryable.options`)
- Provider determined at **runtime** from data structure (not in module config)
- Schema-driven layouts using semantic layout hints
- Editable fields via `schema._ux.input_schema` (with flat properties inside, not nested `_ux`)
- Provider classes follow R3 pattern (classes with methods, not standalone functions)

---

## Data Flow Pattern

Sub-actions follow the **exact same pattern as retryables**:

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Workflow JSON (module config)                                │
│                                                                 │
│    "sub_actions": [                                             │
│      { "id": "generate", "action_type": "txt2img", ... }        │
│    ]                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Executor puts on context                                     │
│                                                                 │
│    context.sub_actions = module_config.get('sub_actions')       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Module extracts from context, puts in display_data           │
│                                                                 │
│    sub_actions = getattr(context, 'sub_actions', None)          │
│    display_data = {                                             │
│        "data": prompts,                                         │
│        "schema": display_schema,                                │
│        "sub_actions": sub_actions,  # <-- Like retryable        │
│    }                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI reads request.display_data.sub_actions                 │
│                                                                 │
│    const subActions = request.display_data?.sub_actions;        │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prompts Data Structure

Prompts from previous workflow step, grouped by provider:

```json
{
  "prompts": {
    "midjourney": {
      "prompt_a": {
        "subject": "contemplative person in partial profile...",
        "environment": "snug indoor room, exposed brick walls...",
        "objects": "small side table with warm lamp...",
        "motion": "lamp glow gently pulsing...",
        "atmosphere": "warm, dim, introspective...",
        "particles": "dust particles glowing..."
      },
      "prompt_b": {
        "subject": "quiet journaling person in armchair...",
        "environment": "intimate, safe room mood..."
      }
    },
    "leonardo": {
      "phoenix_1_0": "Primary subject: a contemplative person nestled in a cushioned armchair...",
      "anime_xl": "Primary subject: a contemplative person nestled in a cozy armchair..."
    }
  }
}
```

**Structure:** `prompts[provider][prompt_id] = prompt_content`

**Key insight:** Provider is determined from data keys at runtime, not from module config.

---

## Workflow Module Configuration

### Step JSON

```json
{
  "module_id": "user.select",
  "inputs": {
    "data": "{{ state.generated_prompts }}",
    "schema": {
      "$ref": "schemas/media_generation_display_schema.json",
      "type": "json"
    },
    "prompt": "Generate and Select Images",
    "mode": "select",
    "multi_select": false
  },
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "action_type": "txt2img",
      "loading_label": "Generating...",
      "result_key": "generations"
    }
  ],
  "outputs_to_state": {
    "selected_indices": "selected_content",
    "selected_data": "selected_content_data"
  },
  "name": "generate_and_select"
}
```

**Notes:**
- `module_id: "user.select"` — Existing module extended with sub-action support
- `sub_actions` is an **array** (like `retryable.options`)
- `action_type: "txt2img"` — Generic operation, NOT provider-specific
- Provider determined at runtime from data structure (`prompts.midjourney`, `prompts.leonardo`)

### Sub-Action Config Schema

```typescript
interface SubActionConfig {
  id: string;              // Unique identifier: "generate"
  label: string;           // Button text: "Generate Images"
  action_type: string;     // Operation: "txt2img", "img2img", "img2vid"
  loading_label?: string;  // "Generating..."
  result_key: string;      // Where results accumulate in display_data
}
```

---

## Display Schema with Editable Fields

The display schema uses `_ux.input_schema` for editable prompt fields.

**Important:** Inside `input_schema`, properties use **flat fields** like `input_type`, `enum_labels` — NOT nested `_ux`.

```json
{
  "type": "object",
  "_ux": {
    "display": "passthrough"
  },
  "properties": {
    "prompts": {
      "type": "object",
      "_ux": {
        "display": "passthrough"
      },
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "render_as": "section",
            "display_label": "Midjourney",
            "selectable": true
          },
          "properties": {
            "prompt_a": {
              "type": "object",
              "_ux": {
                "display": "visible",
                "render_as": "card",
                "display_label": "Prompt A (Weighted)",
                "input_schema": {
                  "type": "object",
                  "layout": "sections",
                  "properties": {
                    "subject": {
                      "type": "string",
                      "title": "Subject",
                      "input_type": "textarea",
                      "group": "prompt",
                      "group_label": "Prompt Components",
                      "width": "full"
                    },
                    "environment": {
                      "type": "string",
                      "title": "Environment",
                      "input_type": "textarea",
                      "group": "prompt",
                      "width": "full"
                    },
                    "aspect_ratio": {
                      "type": "string",
                      "title": "Aspect Ratio",
                      "enum": ["1:1", "16:9", "9:16", "4:3"],
                      "default": "16:9",
                      "input_type": "select",
                      "group": "params",
                      "group_label": "Generation Parameters",
                      "width": "third"
                    },
                    "speed": {
                      "type": "string",
                      "title": "Speed",
                      "enum": ["relaxed", "fast", "turbo"],
                      "default": "fast",
                      "input_type": "select",
                      "group": "params",
                      "width": "third"
                    },
                    "stylization": {
                      "type": "integer",
                      "title": "Stylization",
                      "minimum": 0,
                      "maximum": 1000,
                      "default": 100,
                      "input_type": "slider",
                      "group": "params",
                      "width": "full"
                    }
                  }
                }
              },
              "properties": {
                "subject": { "type": "string", "_ux.display_label": "Subject" },
                "environment": { "type": "string", "_ux.display_label": "Environment" },
                "objects": { "type": "string", "_ux.display_label": "Objects" },
                "motion": { "type": "string", "_ux.display_label": "Motion" },
                "atmosphere": { "type": "string", "_ux.display_label": "Atmosphere" },
                "particles": { "type": "string", "_ux.display_label": "Particles" }
              }
            }
          }
        }
      }
    }
  }
}
```

### Layout Hints (Flat Properties, Not Nested `_ux`)

Inside `input_schema`, use flat properties directly on each field:

| Property | Values | Purpose |
|----------|--------|---------|
| `layout` | `"vertical"`, `"horizontal"`, `"sections"`, `"grid"` | Form layout mode (on root) |
| `width` | `"full"`, `"half"`, `"third"`, `"quarter"`, `"auto"` | Field width |
| `group` | `string` | Group ID for sections |
| `group_label` | `string` | Label for first field in group |
| `input_type` | `"text"`, `"textarea"`, `"select"`, `"slider"`, `"counter"` | Input control type |
| `enum_labels` | `Record<string, string>` | Display labels for enum values |

**Example from existing schema** (`aesthetic_form_schema.json`):
```json
"count": {
  "type": "integer",
  "title": "Count",
  "minimum": 0,
  "maximum": 10,
  "default": 0,
  "input_type": "counter"
}
```

---

## Server Implementation

### Executor Change (Parallel to Retryable)

```python
# server/workflow/executor.py

# In execute_step_modules, where retryable is set:
context.retryable = module_config.get('retryable')
context.sub_actions = module_config.get('sub_actions')  # ADD THIS
```

### Module Implementation

The existing `user.select` module is extended:

```python
# server/modules/user/select.py (extended)

def get_interaction_request(
    self,
    inputs: Dict[str, Any],
    context
) -> Optional[InteractionRequest]:
    data = inputs['data']
    schema = inputs['schema']
    prompt = self.get_input_value(inputs, 'prompt')
    multi_select = self.get_input_value(inputs, 'multi_select')
    mode = self.get_input_value(inputs, 'mode')

    # Get configs from context (set by executor from module config)
    retryable = getattr(context, 'retryable', None)
    sub_actions = getattr(context, 'sub_actions', None)

    return InteractionRequest(
        interaction_type=InteractionType.SELECT_FROM_STRUCTURED,
        interaction_id=f"select_{uuid6.uuid7().hex}",
        title=prompt,
        display_data={
            "data": data,
            "schema": schema,
            "multi_select": multi_select,
            "mode": mode,
            "retryable": retryable,
            "sub_actions": sub_actions,      # Array, like retryable.options
            "generations": {}                 # Accumulates sub-action results
        },
        context={
            "module_id": self.module_id
        }
    )
```

### Sub-Action Registry

Maps provider names to provider classes:

```python
# server/workflow/sub_action/registry.py

from typing import Dict, Type
from .providers.base import MediaProviderBase

# Registry: provider_name -> provider_class
_PROVIDER_REGISTRY: Dict[str, Type[MediaProviderBase]] = {}


def register_provider(name: str, provider_class: Type[MediaProviderBase]):
    """Register a media provider."""
    _PROVIDER_REGISTRY[name] = provider_class


def get_provider(name: str) -> Type[MediaProviderBase]:
    """Get provider class by name."""
    if name not in _PROVIDER_REGISTRY:
        raise ValueError(f"Unknown provider: {name}")
    return _PROVIDER_REGISTRY[name]
```

### Provider Base Class (From R3)

```python
# server/workflow/sub_action/providers/base.py

from abc import ABC, abstractmethod
from typing import List, Tuple, Any, Optional, Callable


class MediaProviderBase(ABC):
    """Base class for media generation providers."""

    @abstractmethod
    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from text. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from image. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate video from image. Returns (urls, raw_response)."""
        pass
```

### Provider Implementation (From R3)

```python
# server/workflow/sub_action/providers/midjourney.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class MidJourneyProvider(MediaProviderBase):
    """MidJourney provider via MidAPI."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images via MidAPI."""
        from server.modules.api.providers.midapi import MidAPIClient

        client = MidAPIClient()
        return client.imagine(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.midapi import MidAPIClient

        client = MidAPIClient()
        return client.vary(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        raise NotImplementedError("MidJourney does not support img2vid")


# Register on module load
register_provider("midjourney", MidJourneyProvider)
```

```python
# server/workflow/sub_action/providers/leonardo.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class LeonardoProvider(MediaProviderBase):
    """Leonardo AI provider."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.generate(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.generate_with_image(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        from server.modules.api.providers.leonardo import LeonardoClient

        client = LeonardoClient()
        return client.motion(params, progress_callback=progress_callback)


# Register on module load
register_provider("leonardo", LeonardoProvider)
```

### Sub-Action API Route

```python
# server/api/routes/workflow.py

from pydantic import BaseModel
from sse_starlette.sse import EventSourceResponse


class SubActionRequest(BaseModel):
    """Request to execute a sub-action."""
    interaction_id: str
    provider: str                 # "midjourney", "leonardo" (from data keys)
    action_type: str              # "txt2img", "img2img", "img2vid"
    prompt_id: str                # "prompt_a"
    params: Dict[str, Any]        # Generation parameters
    source_data: Any              # Full prompt data


@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db)
):
    """Execute a sub-action with SSE streaming."""
    return EventSourceResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        send_timeout=5
    )
```

### Sub-Action Executor (SSE Streaming)

```python
# server/workflow/sub_action/executor.py

import asyncio
import json
import uuid6
import concurrent.futures

from .registry import get_provider


def sse_event(event_type: str, data: dict) -> str:
    """Format SSE event."""
    return f"event: {event_type}\ndata: {json.dumps(data)}\n\n"


async def execute_sub_action_stream(
    workflow_run_id: str,
    request: SubActionRequest,
    db
):
    """
    Execute sub-action and stream progress via SSE.
    Stores results in database but does NOT advance workflow state.
    """
    action_id = f"sa_{uuid6.uuid7().hex[:8]}"
    yield sse_event("started", {"action_id": action_id})

    try:
        # 1. Get provider class from registry
        provider_class = get_provider(request.provider)
        provider = provider_class()

        # 2. Get the method for action_type
        method = getattr(provider, request.action_type)

        # 3. Setup progress tracking
        loop = asyncio.get_event_loop()
        progress_queue = asyncio.Queue()

        def progress_callback(elapsed_ms: int, message: str):
            loop.call_soon_threadsafe(
                progress_queue.put_nowait,
                {"elapsed_ms": elapsed_ms, "message": message}
            )

        # 4. Run generation in thread pool (providers are sync)
        executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
        future = loop.run_in_executor(
            executor,
            lambda: method(request.params, progress_callback=progress_callback)
        )

        # 5. Stream progress while waiting
        while not future.done():
            try:
                progress = await asyncio.wait_for(progress_queue.get(), timeout=0.5)
                yield sse_event("progress", progress)
            except asyncio.TimeoutError:
                pass

        # 6. Get result
        urls, raw_response = await future

        # 7. Store metadata in database
        metadata_id = db.content_repo.store_generation(
            workflow_run_id=workflow_run_id,
            interaction_id=request.interaction_id,
            provider=request.provider,
            prompt_id=request.prompt_id,
            operation=request.action_type,
            request_params=request.params,
            source_data=request.source_data,
            response_data=raw_response
        )

        # 8. Store individual content items
        content_ids = []
        content_type = "video" if request.action_type == "img2vid" else "image"

        for index, url in enumerate(urls):
            content_id = db.content_repo.store_content(
                metadata_id=metadata_id,
                workflow_run_id=workflow_run_id,
                index=index,
                provider_url=url,
                content_type=content_type
            )
            content_ids.append(content_id)

        # 9. Send completion event
        yield sse_event("complete", {
            "urls": urls,
            "metadata_id": metadata_id,
            "content_ids": content_ids
        })

    except Exception as e:
        yield sse_event("error", {"message": str(e)})
```

---

## WebUI Implementation

### StructuredSelect Extension

The existing `StructuredSelect` component handles `sub_actions` from `display_data`:

```typescript
// webui/src/components/workflow/interactions/structured-select.tsx

export function StructuredSelect() {
  const { request, disabled, updateProvider, mode } = useInteraction();

  const displayData = request.display_data || {};
  const data = displayData.data;
  const schema = displayData.schema;
  const subActions = displayData.sub_actions as SubActionConfig[] | undefined;

  // Track generations per prompt: { "midjourney:prompt_a": [...results] }
  const [generations, setGenerations] = useState<Record<string, GenerationResult[]>>(
    displayData.generations || {}
  );

  // Loading state per prompt
  const [loadingPrompts, setLoadingPrompts] = useState<Set<string>>(new Set());

  // Handle sub-action execution
  const handleSubAction = async (
    actionConfig: SubActionConfig,
    provider: string,
    promptId: string,
    params: Record<string, any>,
    sourceData: any
  ) => {
    const promptKey = `${provider}:${promptId}`;

    setLoadingPrompts(prev => new Set(prev).add(promptKey));

    try {
      const response = await fetch(
        `${API_URL}/workflow/${workflowRunId}/sub-action`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interaction_id: request.interaction_id,
            provider,                        // From data keys
            action_type: actionConfig.action_type,  // "txt2img"
            prompt_id: promptId,
            params,
            source_data: sourceData
          })
        }
      );

      // Parse SSE stream (similar to useWorkflowStream)
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (reader) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        // Parse SSE events from buffer...
        // On "complete" event, update generations state
      }

    } finally {
      setLoadingPrompts(prev => {
        const next = new Set(prev);
        next.delete(promptKey);
        return next;
      });
    }
  };

  // Render with sub-action buttons if configured
  return (
    <div>
      <SchemaRenderer
        data={data}
        schema={schema}
        subActionContext={{
          subActions,
          generations,
          loadingPrompts,
          onSubAction: handleSubAction
        }}
      />
    </div>
  );
}
```

### SubActionButton Component

```typescript
// webui/src/components/common/SubActionButton.tsx

interface SubActionButtonProps {
  config: SubActionConfig;
  onClick: () => void;
  loading: boolean;
  progress?: { elapsed_ms: number; message: string };
}

export function SubActionButton({ config, onClick, loading, progress }: SubActionButtonProps) {
  return (
    <div className="flex flex-col gap-2">
      <Button onClick={onClick} disabled={loading}>
        {loading ? config.loading_label || 'Processing...' : config.label}
      </Button>

      {loading && progress && (
        <div className="text-sm text-muted-foreground">
          {progress.message} ({Math.round(progress.elapsed_ms / 1000)}s)
        </div>
      )}
    </div>
  );
}
```

### SchemaFormRenderer Component

Renders editable forms from `schema._ux.input_schema`:

```typescript
// webui/src/components/common/SchemaFormRenderer.tsx

interface Props {
  schema: InputSchema;
  values: Record<string, any>;
  onChange: (values: Record<string, any>) => void;
  disabled?: boolean;
}

export function SchemaFormRenderer({ schema, values, onChange, disabled }: Props) {
  // Layout is flat property on schema root
  const layout = schema.layout || 'vertical';
  const properties = schema.properties || {};

  // Group fields by group property
  const groups = groupFieldsByGroup(properties);

  if (layout === 'sections') {
    return (
      <div className="space-y-6">
        {Object.entries(groups).map(([groupId, fields]) => (
          <FormSection key={groupId} label={getGroupLabel(fields)}>
            <FormFieldGroup
              fields={fields}
              values={values}
              onChange={onChange}
              disabled={disabled}
            />
          </FormSection>
        ))}
      </div>
    );
  }

  // Default: vertical layout
  return (
    <div className="space-y-4">
      {Object.entries(properties).map(([key, fieldSchema]) => (
        <FormField
          key={key}
          name={key}
          schema={fieldSchema}
          value={values[key]}
          onChange={(v) => onChange({ ...values, [key]: v })}
          disabled={disabled}
        />
      ))}
    </div>
  );
}

function FormFieldWrapper({ fieldSchema, children }) {
  // Width is flat property on field schema
  const width = fieldSchema.width || 'auto';

  const widthClass = {
    full: 'col-span-full',
    half: 'md:col-span-1',
    third: 'md:col-span-1',
    quarter: 'md:col-span-1',
    auto: ''
  }[width];

  return <div className={widthClass}>{children}</div>;
}
```

### MediaGrid Component

```typescript
// webui/src/components/common/MediaGrid.tsx

interface MediaGridProps {
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelect: (contentId: string) => void;
}

export function MediaGrid({ generations, selectedContentId, onSelect }: MediaGridProps) {
  const allContent = generations.flatMap(gen =>
    gen.content_ids.map((id, idx) => ({
      contentId: id,
      url: gen.urls[idx],
      metadataId: gen.metadata_id
    }))
  );

  if (allContent.length === 0) return null;

  return (
    <div className="grid grid-cols-4 gap-2">
      {allContent.map(item => (
        <div
          key={item.contentId}
          className={cn(
            'relative cursor-pointer rounded-md overflow-hidden border-2',
            selectedContentId === item.contentId
              ? 'border-primary'
              : 'border-transparent'
          )}
          onClick={() => onSelect(item.contentId)}
        >
          <img
            src={item.url}
            alt=""
            className="w-full h-auto aspect-square object-cover"
          />
          {selectedContentId === item.contentId && (
            <div className="absolute top-1 right-1 bg-primary text-primary-foreground rounded-full p-1">
              <CheckIcon className="w-3 h-3" />
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

## Database Schema

```sql
-- Metadata for each generation request
CREATE TABLE content_generation_metadata (
    content_generation_metadata_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    interaction_id TEXT NOT NULL,
    provider TEXT NOT NULL,
    prompt_id TEXT NOT NULL,
    operation TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    status TEXT DEFAULT 'pending',
    request_params JSONB,
    source_data JSONB,
    response_data JSONB,
    error_message TEXT,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id)
);

-- Individual generated content items
CREATE TABLE generated_content (
    generated_content_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    content_generation_metadata_id TEXT NOT NULL,
    index INTEGER NOT NULL,
    content_type TEXT NOT NULL,
    provider_url TEXT NOT NULL,
    local_path TEXT,
    downloaded_at TIMESTAMP,

    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id),
    FOREIGN KEY (content_generation_metadata_id)
        REFERENCES content_generation_metadata(content_generation_metadata_id)
);

-- Indexes
CREATE INDEX idx_cgm_workflow_run ON content_generation_metadata(workflow_run_id);
CREATE INDEX idx_cgm_interaction ON content_generation_metadata(interaction_id);
CREATE INDEX idx_gc_workflow_run ON generated_content(workflow_run_id);
CREATE INDEX idx_gc_metadata ON generated_content(content_generation_metadata_id);
```

### Repository

```python
# server/db/content_repository.py

import uuid6


class ContentRepository:
    def __init__(self, db):
        self.db = db

    def store_generation(
        self,
        workflow_run_id: str,
        interaction_id: str,
        provider: str,
        prompt_id: str,
        operation: str,
        request_params: dict,
        source_data: any,
        response_data: dict
    ) -> str:
        """Store generation metadata. Returns metadata_id."""
        metadata_id = f"cgm_{uuid6.uuid7().hex}"
        # ... insert into content_generation_metadata
        return metadata_id

    def store_content(
        self,
        metadata_id: str,
        workflow_run_id: str,
        index: int,
        provider_url: str,
        content_type: str
    ) -> str:
        """Store individual content item. Returns content_id."""
        content_id = f"gc_{uuid6.uuid7().hex}"
        # ... insert into generated_content
        return content_id

    def get_generations_for_interaction(self, interaction_id: str) -> list:
        """Get all generations for an interaction (for resuming)."""
        # ... query both tables joined
        pass
```

---

## Complete Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Previous Module Output (state.generated_prompts)             │
│                                                                 │
│ { "prompts": {                                                  │
│     "midjourney": { "prompt_a": {...} },                        │
│     "leonardo": { "phoenix_1_0": "..." }                        │
│ }}                                                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Server: Module.get_interaction_request()                     │
│                                                                 │
│ InteractionRequest(                                             │
│   interaction_type=SELECT_FROM_STRUCTURED,                      │
│   display_data={                                                │
│     "data": prompts,                                            │
│     "schema": display_schema,  # has _ux.input_schema           │
│     "sub_actions": [...],      # array, from context            │
│     "generations": {}          # accumulates results            │
│   }                                                             │
│ )                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. WebUI: StructuredSelect renders                              │
│                                                                 │
│ - SchemaRenderer shows prompts (editable via input_schema)      │
│ - SubActionButton for each provider/prompt                      │
│ - MediaGrid shows generated images                              │
└─────────────────────────────────────────────────────────────────┘
                              │
              [User edits prompt, clicks "Generate Images"]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI: POST /workflow/{id}/sub-action                        │
│                                                                 │
│ {                                                               │
│   "interaction_id": "select_xxx",                               │
│   "provider": "midjourney",     # from data keys                │
│   "action_type": "txt2img",     # from sub_actions config       │
│   "prompt_id": "prompt_a",                                      │
│   "params": { "aspect_ratio": "16:9", ... },                    │
│   "source_data": { "subject": "...", ... }                      │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. Server: execute_sub_action_stream()                          │
│                                                                 │
│ a) Registry lookup: get_provider("midjourney") → MidJourneyProvider
│ b) provider.txt2img(params) → calls MidAPI                      │
│ c) SSE: progress events during polling                          │
│ d) Store in content_generation_metadata + generated_content     │
│ e) SSE: complete { urls, metadata_id, content_ids }             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. WebUI: Update generations state, show images in grid         │
│                                                                 │
│ User can:                                                       │
│   - Adjust params and click "Generate" again                    │
│   - Click an image to select it                                 │
│   - Click "Continue" when satisfied                             │
└─────────────────────────────────────────────────────────────────┘
                              │
                    [User clicks "Continue"]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 7. WebUI: Normal interaction response                           │
│                                                                 │
│ {                                                               │
│   "selected_indices": ["midjourney:prompt_a:gc_xxx"],           │
│   "selected_options": [...]                                     │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 8. Server: Module.execute_with_response()                       │
│                                                                 │
│ Returns to workflow state:                                      │
│ {                                                               │
│   "selected_indices": [...],                                    │
│   "selected_data": { content_id, url, ... }                     │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
server/
├── workflow/
│   ├── executor.py              # Add context.sub_actions extraction
│   └── sub_action/
│       ├── __init__.py
│       ├── registry.py          # register_provider, get_provider
│       ├── executor.py          # execute_sub_action_stream
│       └── providers/
│           ├── __init__.py      # Import all to trigger registration
│           ├── base.py          # MediaProviderBase (abstract)
│           ├── midjourney.py    # MidJourneyProvider class
│           └── leonardo.py      # LeonardoProvider class
│
├── api/
│   └── routes/
│       └── workflow.py          # Add POST /{id}/sub-action endpoint
│
└── db/
    └── content_repository.py    # ContentRepository

webui/src/
├── components/
│   ├── common/
│   │   ├── SchemaFormRenderer.tsx
│   │   ├── SubActionButton.tsx
│   │   └── MediaGrid.tsx
│   │
│   └── workflow/
│       └── interactions/
│           └── structured-select.tsx  # Extended with sub-action support
│
└── lib/
    └── types.ts                 # SubActionConfig type
```

---

## Summary of Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Sub-action config | Array (like `retryable.options`) | Consistent with existing patterns |
| Provider determination | Runtime from data keys | Data contains prompts for multiple providers |
| `action_type` | Generic operation (`txt2img`) | Provider not known at config time |
| `input_schema` properties | Flat (not nested `_ux`) | Matches existing `aesthetic_form_schema.json` pattern |
| Provider implementation | Classes with methods | Follows R3 design |
| Registry | Maps provider name → class | Simple lookup, class handles operations |
| Where sub_actions lives | `display_data.sub_actions` | Parallel to `display_data.retryable` |
| Storage | Database tables | Enables resume, history |
