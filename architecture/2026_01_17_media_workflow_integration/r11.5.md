# Media Generation WebUI Implementation - R11.5

## Summary

WebUI implementation plan for the `media_generation` interaction type. This document covers the Design-Forward Phase 1 approach that builds input renderer infrastructure alongside the MediaGeneration component, minimizing throwaway work for Phase 2.

**Decision**: Design-Forward Phase 1 over MVP Phase 1

**Rationale**: Phase 2 (full input renderer unification) will happen immediately after Phase 1. Building input renderer foundation in Phase 1 reduces total work and eliminates ~30-35% throwaway code.

---

## Phase Overview

| Phase | Scope | Estimated Turns | Session |
|-------|-------|-----------------|---------|
| Phase 1 | MediaGeneration + Input Renderer Foundation | 25-35 | Current |
| Phase 2 | Full Input Renderer Integration + Unification | 15-25 | Next |

### What Phase 1 Delivers
1. Working `MediaGeneration` component with full functionality
2. `InputContext` for value/onChange binding (foundation)
3. Three input renderers: `TextareaInputRenderer`, `SelectInputRenderer`, `SliderInputRenderer`
4. Types and routing updates

### What Phase 2 Delivers
1. Integration of input renderers into `TerminalRenderer` routing
2. Additional input renderers as needed
3. Refactor other components (FormInput) to use unified system
4. Full readonly/active mode support through schema system

---

## Design Decisions

### 1. InputContext Architecture

Input renderers need access to:
- Current values (controlled component pattern)
- onChange callbacks
- Disabled state
- Readonly mode

**Decision**: Create `InputContext` separate from `SelectionContext`

```typescript
interface InputContextValue {
  values: Record<string, unknown>;        // Keyed by path string
  getValue: (path: string[]) => unknown;
  setValue: (path: string[], value: unknown) => void;
  disabled: boolean;
  readonly: boolean;
}
```

**Rationale**:
- SelectionContext handles selection (click to select items)
- InputContext handles input (type/change values)
- Different concerns, different contexts
- Can be composed when needed

### 2. Input Renderer Naming Convention

**Decision**: Name input renderers with `Input` suffix: `TextareaInputRenderer`, `SelectInputRenderer`

**Rationale**:
- Distinguishes from display renderers (`TextRenderer`)
- Clear intent in imports
- Follows existing pattern (`ErrorRenderer`, `ImageRenderer`)

### 3. Input Type Detection

**Decision**: Use `input_type` field in UX config to determine input rendering

```typescript
// In UxConfig
input_type?: "textarea" | "select" | "slider" | "checkbox" | "text";
```

**Rationale**:
- Already defined in architecture doc r11
- Explicit over implicit (don't guess from schema type)
- Matches server-side schema pattern

### 4. Path-Based Value Storage

**Decision**: Store input values keyed by path string (e.g., "prompts.midjourney.prompt_a")

**Rationale**:
- Consistent with SelectionContext path pattern
- Supports nested schema structures
- Easy lookup and update

### 5. MediaGeneration Component Structure

```
media-generation/
├── index.ts                    # Exports
├── MediaGeneration.tsx         # Main component (orchestration)
├── MediaGenerationContent.tsx  # Content rendering (prompts by provider)
├── PromptPanel.tsx             # Single prompt panel (text + params + generations)
├── MediaGrid.tsx               # Generated content grid with selection
└── types.ts                    # Local types
```

**Rationale**:
- Clear separation of concerns
- PromptPanel is the unit of interaction (prompt + its params + its generations)
- MediaGrid is reusable for any image selection

---

## Technical Specification

### New Files - Input Infrastructure

#### 1. InputContext (`schema-interaction/InputContext.tsx`)

```typescript
interface ValidationError {
  path: string[];
  message: string;
}

interface InputContextValue {
  // Value access
  values: Record<string, unknown>;
  getValue: (path: string[]) => unknown;
  setValue: (path: string[], value: unknown) => void;

  // State
  disabled: boolean;
  readonly: boolean;

  // Validation
  errors: ValidationError[];
  isValid: boolean;
  getError: (path: string[]) => string | undefined;
  validate: () => boolean;  // Run validation, return isValid

  // Schema access (for defaults, validation rules)
  getFieldSchema: (path: string[]) => UxConfig | undefined;
}

interface InputProviderProps {
  children: ReactNode;
  initialValues?: Record<string, unknown>;
  disabled?: boolean;
  readonly?: boolean;
  schema?: SchemaProperty;
  onChange?: (values: Record<string, unknown>) => void;
  onValidationChange?: (isValid: boolean, errors: ValidationError[]) => void;
}
```

#### 2. TextareaInputRenderer (`schema-interaction/renderers/TextareaInputRenderer.tsx`)

```typescript
interface TextareaInputRendererProps {
  path: string[];
  label?: string;
  placeholder?: string;
  className?: string;
  minRows?: number;
}

// Behavior:
// - readonly mode: renders value as text (like TextRenderer)
// - active mode: renders textarea with value from InputContext
// - calls setValue on change
```

#### 3. SelectInputRenderer (`schema-interaction/renderers/SelectInputRenderer.tsx`)

```typescript
interface SelectInputRendererProps {
  path: string[];
  label?: string;
  options: Array<{ value: string; label: string }>;
  className?: string;
}

// Behavior:
// - readonly mode: renders selected value as text
// - active mode: renders select dropdown
// - supports enum from schema
```

#### 4. SliderInputRenderer (`schema-interaction/renderers/SliderInputRenderer.tsx`)

```typescript
interface SliderInputRendererProps {
  path: string[];
  label?: string;
  min: number;
  max: number;
  step?: number;
  className?: string;
}

// Behavior:
// - readonly mode: renders value as number
// - active mode: renders slider with current value display
```

### New Files - MediaGeneration

#### 1. Types (`media-generation/types.ts`)

```typescript
export interface SubActionConfig {
  id: string;
  label: string;
  action_type: string;
  loading_label?: string;
  result_key: string;
}

export interface GenerationResult {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}

export interface PromptData {
  [key: string]: unknown;  // Structured prompt fields
}

export interface PromptsData {
  prompts: Record<string, Record<string, PromptData>>;  // prompts[provider][prompt_id]
}

// SSE Event types (matching server)
export interface SSEStartedEvent {
  action_id: string;
}

export interface SSEProgressEvent {
  elapsed_ms: number;
  message: string;
}

export interface SSECompleteEvent {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}

export interface SSEErrorEvent {
  message: string;
  retry_after?: number;
}
```

#### 2. MediaGeneration.tsx (Main Component)

Responsibilities:
- Extract display_data (data, schema, sub_actions)
- Manage generations state (accumulated results by prompt key)
- Manage selected content ID
- Register with InteractionHost via updateProvider
- Provide InputContext for editable prompts/params
- Handle readonly mode (show historical data)

```typescript
export function MediaGeneration() {
  const { request, disabled, updateProvider, mode } = useInteraction();
  const isReadonly = mode.type === "readonly";

  // Extract from display_data
  const displayData = request.display_data || {};
  const data = displayData.data as PromptsData;
  const schema = displayData.schema;
  const subActions = displayData.sub_actions as SubActionConfig[];

  // State
  const [promptValues, setPromptValues] = useState<Record<string, unknown>>({});
  const [generations, setGenerations] = useState<Record<string, GenerationResult[]>>({});
  const [selectedContentId, setSelectedContentId] = useState<string | null>(null);
  const [loadingPrompts, setLoadingPrompts] = useState<Set<string>>(new Set());

  // Initialize from readonly response
  useEffect(() => {
    if (isReadonly && mode.response) {
      setGenerations(mode.response.generations || {});
      setSelectedContentId(mode.response.selected_content_id || null);
    }
  }, [isReadonly, mode]);

  // Register provider
  // ...

  // Sub-action execution
  // ...

  return (
    <InputProvider
      initialValues={promptValues}
      onChange={setPromptValues}
      disabled={disabled}
      readonly={isReadonly}
      schema={schema}
    >
      <MediaGenerationContent
        data={data}
        schema={schema}
        subActions={subActions}
        generations={generations}
        selectedContentId={selectedContentId}
        onSelectContent={setSelectedContentId}
        loadingPrompts={loadingPrompts}
        onExecuteSubAction={handleSubAction}
      />
    </InputProvider>
  );
}
```

#### 3. MediaGenerationContent.tsx

Renders the provider sections and prompt panels:

```typescript
interface MediaGenerationContentProps {
  data: PromptsData;
  schema: SchemaProperty;
  subActions: SubActionConfig[];
  generations: Record<string, GenerationResult[]>;
  selectedContentId: string | null;
  onSelectContent: (id: string) => void;
  loadingPrompts: Set<string>;
  onExecuteSubAction: (provider: string, promptId: string, action: SubActionConfig) => void;
}

// Renders:
// - Provider sections (midjourney, leonardo)
// - PromptPanel for each prompt within provider
```

#### 4. PromptPanel.tsx

Single prompt unit with editable text, parameters, and generations:

```typescript
interface PromptPanelProps {
  provider: string;
  promptId: string;
  promptData: PromptData;
  promptSchema: SchemaProperty;
  subActions: SubActionConfig[];
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelectContent: (id: string) => void;
  isLoading: boolean;
  onExecuteSubAction: (action: SubActionConfig) => void;
}

// Renders:
// 1. Prompt text (TextareaInputRenderer or SchemaRenderer with display_format)
// 2. Parameters from input_schema (SelectInputRenderer, SliderInputRenderer)
// 3. Generated content (MediaGrid)
// 4. Action buttons (Generate)
// 5. Progress indicator when loading
```

#### 5. MediaGrid.tsx

Grid of generated images with selection:

```typescript
interface MediaGridProps {
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelect: (contentId: string) => void;
  lazyLoad?: boolean;  // For readonly mode
}

// Renders:
// - Grid of images from all generations
// - Selection indicator on selected image
// - Lazy loading for readonly/history mode
```

### Updates to Existing Files

#### 1. `webui/src/lib/types.ts`

Add to InteractionType:
```typescript
export type InteractionType =
  | "text_input"
  | "select_from_structured"
  | "review_grouped"
  | "file_input"
  | "file_download"
  | "form_input"
  | "resume_choice"
  | "retry_options"
  | "media_generation";  // ADD
```

#### 2. `webui/src/components/workflow/interactions/InteractionHost.tsx`

Add import and case:
```typescript
import { MediaGeneration } from "./media-generation";

// In InteractionContent switch:
case "media_generation":
  return <MediaGeneration />;
```

#### 3. `webui/src/components/workflow/interactions/schema-interaction/types.ts`

Add to UxConfig:
```typescript
export interface UxConfig {
  // ... existing fields
  input_type?: "textarea" | "select" | "slider" | "checkbox" | "text";
}
```

#### 4. `webui/src/components/workflow/interactions/schema-interaction/renderers/index.ts`

Export new input renderers:
```typescript
export { TextareaInputRenderer } from "./TextareaInputRenderer";
export { SelectInputRenderer } from "./SelectInputRenderer";
export { SliderInputRenderer } from "./SliderInputRenderer";
```

#### 5. `webui/src/components/workflow/interactions/schema-interaction/index.ts`

Export InputContext:
```typescript
export { InputProvider, useInput, useInputOptional } from "./InputContext";
```

---

## Phase 1 Detailed POA

### Task 1: Types and Routing (2-3 turns)

- [ ] **1.1** Update `webui/src/lib/types.ts`:
  - Add `"media_generation"` to `InteractionType`

- [ ] **1.2** Update `webui/src/components/workflow/interactions/InteractionHost.tsx`:
  - Import `MediaGeneration` from `"./media-generation"`
  - Add case `"media_generation"` in `InteractionContent` switch

- [ ] **1.3** Update `webui/src/components/workflow/interactions/schema-interaction/types.ts`:
  - Add `input_type` to `UxConfig` interface

### Task 2: InputContext (5-6 turns)

- [ ] **2.1** Create `webui/src/components/workflow/interactions/schema-interaction/InputContext.tsx`:
  - `ValidationError` interface
  - `InputContextValue` interface (with validation fields)
  - `InputProviderProps` interface (with onValidationChange)
  - `InputProvider` component with:
    - State management for values
    - Validation logic (required, min/max from schema)
    - Error tracking per path
    - `validate()` function that checks all fields
  - `useInput()` hook (throws if not in context)
  - `useInputOptional()` hook (returns null if not in context)
  - Path-to-key conversion utilities

- [ ] **2.2** Implement validation rules:
  - Required fields (check for empty/null/undefined)
  - Number min/max (from schema.minimum/maximum)
  - Call onValidationChange when validation state changes

- [ ] **2.3** Update `webui/src/components/workflow/interactions/schema-interaction/index.ts`:
  - Export `InputProvider`, `useInput`, `useInputOptional`, `ValidationError`

- [ ] **2.4** Test InputContext standalone (verify validation behavior)

### Task 3: Input Renderers (6-8 turns)

- [ ] **3.1** Create `TextareaInputRenderer.tsx`:
  - Use `useInputOptional()` to get context
  - Readonly mode: render value as text (reuse TextRenderer pattern)
  - Active mode: render Textarea from UI library
  - Handle onChange via context setValue

- [ ] **3.2** Create `SelectInputRenderer.tsx`:
  - Use `useInputOptional()` to get context
  - Readonly mode: render selected label as text
  - Active mode: render Select from UI library
  - Support `enum` and `enum_labels` from schema

- [ ] **3.3** Create `SliderInputRenderer.tsx`:
  - Use `useInputOptional()` to get context
  - Readonly mode: render value as number
  - Active mode: render Slider from UI library with value display
  - Support `minimum`, `maximum` from schema

- [ ] **3.4** Update `schema-interaction/renderers/index.ts`:
  - Export all three input renderers

### Task 4: MediaGeneration Types (1-2 turns)

- [ ] **4.1** Create `webui/src/components/workflow/interactions/media-generation/types.ts`:
  - `SubActionConfig` interface
  - `GenerationResult` interface
  - `PromptData` type
  - `PromptsData` type
  - SSE event types

### Task 5: MediaGeneration Component (6-8 turns)

- [ ] **5.1** Create `media-generation/MediaGeneration.tsx`:
  - Extract display_data
  - State management (promptValues, generations, selectedContentId, loadingPrompts)
  - Provider registration with updateProvider
  - Readonly mode initialization from response
  - Wrap children in InputProvider

- [ ] **5.2** Create `media-generation/MediaGenerationContent.tsx`:
  - Iterate over providers
  - Render provider sections
  - Render PromptPanel for each prompt

- [ ] **5.3** Create `media-generation/PromptPanel.tsx`:
  - Render prompt text area (using TextareaInputRenderer)
  - Render parameters from input_schema
  - Render MediaGrid for generations
  - Render action buttons
  - Show progress when loading

- [ ] **5.4** Create `media-generation/MediaGrid.tsx`:
  - Flatten generations into content items
  - Render image grid
  - Handle selection with visual indicator
  - Support lazy loading prop

- [ ] **5.5** Create `media-generation/index.ts`:
  - Export MediaGeneration

### Task 6: SSE Integration (3-4 turns)

- [ ] **6.1** Implement `executeSubAction` in MediaGeneration:
  - POST to `/api/workflow/{workflow_run_id}/sub-action`
  - Parse SSE stream (started, progress, complete, error events)
  - Update loading state
  - Accumulate generations on complete
  - Handle errors gracefully

- [ ] **6.2** Add progress display to PromptPanel:
  - Show elapsed time and message during generation
  - Disable inputs/buttons while loading

### Task 7: Testing and Fixes (3-4 turns)

- [ ] **7.1** Verify types match server API (SubActionRequest fields)
- [ ] **7.2** Test active mode flow (edit prompt → generate → select)
- [ ] **7.3** Test readonly mode (display historical generations)
- [ ] **7.4** Fix any issues found

---

## Phase 2 Scope (Future Session)

### Goal
Integrate input renderers into TerminalRenderer routing for full schema-driven input rendering.

### Tasks (High-Level)

1. **Update TerminalRenderer** to check for `input_type` and route to input renderers when InputContext is available

2. **Add mode awareness** - TerminalRenderer checks `useInputOptional()`:
   - If null → display mode (current behavior)
   - If context exists + readonly → display mode
   - If context exists + active + has input_type → input mode

3. **Additional input renderers** as needed:
   - `TextInputRenderer` (single-line)
   - `CheckboxInputRenderer`
   - `NumberInputRenderer`

4. **Refactor FormInput** to use InputContext + SchemaRenderer instead of custom FormField component

5. **Documentation** - Update schema-interaction README with input renderer usage

### Expected Benefit
- Unified rendering pipeline for display and input
- Any schema with `input_type` automatically gets appropriate input control
- Readonly mode works through same code path
- Reduced duplication across interaction components

---

## File Structure After Phase 1

```
webui/src/
├── lib/
│   └── types.ts                           # Updated: add media_generation
│
└── components/workflow/interactions/
    ├── InteractionHost.tsx                # Updated: add routing
    │
    ├── media-generation/                  # NEW FOLDER
    │   ├── index.ts
    │   ├── types.ts
    │   ├── MediaGeneration.tsx
    │   ├── MediaGenerationContent.tsx
    │   ├── PromptPanel.tsx
    │   └── MediaGrid.tsx
    │
    └── schema-interaction/
        ├── index.ts                       # Updated: export InputContext
        ├── types.ts                       # Updated: add input_type
        ├── InputContext.tsx               # NEW
        │
        └── renderers/
            ├── index.ts                   # Updated: export input renderers
            ├── TextareaInputRenderer.tsx  # NEW
            ├── SelectInputRenderer.tsx    # NEW
            └── SliderInputRenderer.tsx    # NEW
```

---

## Design Clarifications (Resolved)

1. **Validation in InputContext**: Yes, include validation in Phase 1. InputContext should support:
   - Required field validation
   - Min/max for numbers
   - Report validation state to parent

2. **Prompt text editing**: Users edit the `display_format` output (collapsed prompt string). Flow:
   - Render template to get initial text
   - User edits the collapsed text directly
   - Edited text is sent with sub-action (not parsed back to structured fields)

3. **MediaGrid selection**: Single-select, but **global across all prompts**. User can select any image from any prompt/provider combination. The selected_content_id is stored at MediaGeneration level, not per-prompt.
