# Media Generation Workflow Integration Architecture - R6

## Summary

Design for sub-action system enabling iterative media generation within workflow interactions. This revision leverages the **existing schema-driven rendering infrastructure** rather than creating module-specific components.

**Key principle:** The webui already has `SchemaInteractionHost` + `SchemaRenderer` that handles any data shape through schema configuration. We don't create new interaction components - we extend the existing system to support sub-actions.

---

## What Exists vs What's New

| Aspect | Existing Infrastructure | New Addition |
|--------|------------------------|--------------|
| Display prompts | `SchemaRenderer` with UX config | None needed |
| Param forms | `input_schema` in UX config (FormInput pattern) | None needed |
| Image display | `ImageRenderer` via `render_as: "image"` | None needed |
| Selection | `useSelectable` hook + `SelectableWrapper` | None needed |
| Layouts | Layout registry (`card`, `grid`, etc.) | Maybe `media-grid` layout |
| **Sub-action triggers** | Not supported | **New: generic sub-action system** |
| **Dynamic content update** | Not supported | **New: sub-action result handling** |

---

## Architecture Approach

### Don't Create

- ~~MediaGenerationInteraction~~
- ~~ProviderSection~~
- ~~PromptParamForm~~
- ~~MediaGrid~~

### Do Create

1. **Generic sub-action capability** in the interaction system
2. **Sub-action button renderer** that can be placed via schema
3. **Sub-action result handling** that updates display_data dynamically

---

## Schema-Driven Media Generation

The entire UI is driven by schema. Here's how it maps:

### InteractionRequest Structure

<!--we are going correct direction, but its not 100% correct, in this use case, we need all supported fields and prompt itself needs to be editable, which means, we need to use input_schema to render input field for all above, while having support for layout data to structure the input fields the way we want it to render. this is why i wanted to discuss layout props for fields so we can create custom layout in schema.-->

```json
{
    "interaction_type": "schema_with_sub_actions",
    "display_data": {
        "prompts": {
            "midjourney": {
                "prompt_a": { "subject": "...", "environment": "..." },
                "prompt_b": { "subject": "...", "environment": "..." }
            },
            "leonardo": {
                "phoenix_1_0": "Primary subject: ...",
                "anime_xl": "Primary subject: ..."
            }
        },
        "generations": {}
    },
    "display_schema": {
        "type": "object",
        "properties": {
            "prompts": {
                "type": "object",
                "_ux": {
                    "display_label": "Prompts by Provider",
                    "render_as": "section-list"
                },
                "additionalProperties": {
                    "type": "object",
                    "_ux": {
                        "display_label": "{{ key }}",
                        "render_as": "card-stack"
                    },
                    "additionalProperties": {
                        "type": ["string", "object"],
                        "_ux": {
                            "render_as": "card",
                            "sub_action": {
                                "id": "generate",
                                "label": "Generate Images",
                                "action_type": "media.{{ $provider }}.txt2img",
                                "param_schema": "{{ $param_schemas[$provider] }}",
                                "param_defaults": "{{ $param_defaults[$provider] }}",
                                "result_target": "generations.{{ $provider }}.{{ $key }}"
                            }
                        }
                    }
                }
            },
            "generations": {
                "type": "object",
                "_ux": {
                    "display": "passthrough"
                },
                "additionalProperties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "_ux": {
                            "render_as": "grid",
                            "selectable": true,
                            "selection_mode": "single"
                        },
                        "items": {
                            "type": "object",
                            "properties": {
                                "url": { "type": "string", "_ux": { "render_as": "image" } },
                                "content_id": { "type": "string", "_ux": { "display": "hidden" } }
                            }
                        }
                    }
                }
            }
        }
    }
}
```

### How Schema Maps to UI

```
display_data.prompts (render_as: "section-list")
├── midjourney (render_as: "card-stack", label from key)
│   ├── prompt_a (render_as: "card")
│   │   ├── [Schema-rendered prompt content]
│   │   ├── [Param form from sub_action.param_schema]
│   │   └── [Generate button from sub_action]
│   └── prompt_b (render_as: "card")
│       └── ...
├── leonardo (render_as: "card-stack")
│   └── ...

display_data.generations (display: "passthrough" - renders children directly)
├── midjourney
│   ├── prompt_a (render_as: "grid", selectable: true)
│   │   └── [Images rendered via ImageRenderer]
│   └── prompt_b
│       └── ...
└── leonardo
    └── ...
```

---

## New UX Config: `sub_action`

Extend the existing `UxConfig` interface to support sub-actions:

```typescript
// webui/src/components/workflow/interactions/schema-interaction/types.ts

interface SubActionConfig {
    id: string;                      // "generate"
    label: string;                   // "Generate Images"
    action_type: string;             // "media.{{ $provider }}.txt2img" (template)
    param_schema?: JSONSchema;       // Schema for parameter form
    param_defaults?: object;         // Default parameter values
    result_target: string;           // Where to put results: "generations.{{ $provider }}.{{ $key }}"
    loading_label?: string;          // "Generating..."
}

interface UxConfig {
    // ... existing properties ...
    sub_action?: SubActionConfig;    // NEW: sub-action configuration
}
```

---

## Sub-Action Rendering

### SubActionRenderer Component

A **generic** renderer that handles any sub-action button + param form:

```typescript
// webui/src/components/workflow/interactions/schema-interaction/renderers/SubActionRenderer.tsx

interface Props {
    config: SubActionConfig;
    context: RenderContext;        // Contains $provider, $key, etc.
    disabled?: boolean;
}

export function SubActionRenderer({ config, context, disabled }: Props) {
    const { workflowRunId, interactionId, onSubActionResult } = useSubActionContext();

    const [params, setParams] = useState(config.param_defaults || {});
    const [isLoading, setIsLoading] = useState(false);
    const [progress, setProgress] = useState<ProgressInfo | null>(null);

    // Resolve templates in action_type and result_target
    const actionType = resolveTemplate(config.action_type, context);
    const resultTarget = resolveTemplate(config.result_target, context);

    const handleClick = async () => {
        setIsLoading(true);
        try {
            const stream = streamSubAction(workflowRunId, {
                interaction_id: interactionId,
                action_type: actionType,
                provider: context.$provider,
                prompt_id: context.$key,
                operation: extractOperation(actionType),
                params,
                source_data: context.$data
            });

            for await (const event of stream) {
                if (event.type === 'progress') {
                    setProgress(event.data);
                } else if (event.type === 'complete') {
                    // Notify parent to update display_data at result_target
                    onSubActionResult(resultTarget, event.data);
                } else if (event.type === 'error') {
                    // Show error toast
                }
            }
        } finally {
            setIsLoading(false);
            setProgress(null);
        }
    };

    return (
        <div className="sub-action">
            {/* Param form - uses existing schema form rendering */}
            {config.param_schema && (
                <SchemaForm
                    schema={config.param_schema}
                    values={params}
                    onChange={setParams}
                    disabled={isLoading || disabled}
                />
            )}

            {/* Generate button */}
            <Button
                onClick={handleClick}
                disabled={isLoading || disabled}
                className="sub-action__button"
            >
                {isLoading ? (config.loading_label || 'Loading...') : config.label}
            </Button>

            {/* Progress indicator */}
            {isLoading && progress && (
                <ProgressBar elapsed={progress.elapsed_ms} message={progress.message} />
            )}
        </div>
    );
}
```

### Integration with SchemaRenderer

When `SchemaRenderer` encounters a node with `_ux.sub_action`, it renders the sub-action UI:

```typescript
// In SchemaRenderer.tsx or ObjectSchemaRenderer.tsx

function renderNode(data, schema, path, context) {
    const ux = schema._ux || {};

    // Existing rendering logic...
    const content = renderContent(data, schema, path, context);

    // If sub_action is configured, add sub-action UI
    if (ux.sub_action) {
        return (
            <>
                {content}
                <SubActionRenderer
                    config={ux.sub_action}
                    context={{
                        ...context,
                        $data: data,
                        $key: path[path.length - 1],
                        $provider: path[path.length - 2]  // Assumes provider is parent key
                    }}
                />
            </>
        );
    }

    return content;
}
```

---

## Sub-Action Context and State Management

### SubActionContext

Provides sub-action capabilities to the schema renderer:

```typescript
// webui/src/components/workflow/interactions/schema-interaction/SubActionContext.tsx

interface SubActionContextValue {
    workflowRunId: string;
    interactionId: string;
    onSubActionResult: (targetPath: string, result: SubActionResult) => void;
}

const SubActionContext = createContext<SubActionContextValue | null>(null);

export function useSubActionContext() {
    const ctx = useContext(SubActionContext);
    if (!ctx) throw new Error('useSubActionContext must be used within SubActionProvider');
    return ctx;
}
```

### SchemaInteractionHost with Sub-Actions

Extend existing `SchemaInteractionHost` to handle sub-action results:

```typescript
// Modified SchemaInteractionHost.tsx

export function SchemaInteractionHost({ request, mode, variant, disabled, onStateChange }) {
    const [displayData, setDisplayData] = useState(request.display_data);

    // Handle sub-action results by updating display_data
    const handleSubActionResult = useCallback((targetPath: string, result: SubActionResult) => {
        setDisplayData(prev => {
            const updated = { ...prev };
            // Set value at targetPath (e.g., "generations.midjourney.prompt_a")
            setNestedValue(updated, targetPath, currentValue => {
                // Append to array if exists, or create new array
                const existing = currentValue || [];
                return [...existing, ...result.urls.map((url, i) => ({
                    url,
                    content_id: result.content_ids[i],
                    metadata_id: result.metadata_id
                }))];
            });
            return updated;
        });
    }, []);

    return (
        <SubActionContext.Provider value={{
            workflowRunId: request.workflow_run_id,
            interactionId: request.interaction_id,
            onSubActionResult: handleSubActionResult
        }}>
            <SchemaRenderer
                data={displayData}
                schema={request.display_schema}
                // ... existing props
            />
        </SubActionContext.Provider>
    );
}
```

---

## New Interaction Type: `schema_with_sub_actions`

Add a single new interaction type that uses the existing `SchemaInteractionHost` with sub-action support:

```typescript
// webui/src/components/workflow/interactions/InteractionHost.tsx

// In the switch statement:
case "schema_with_sub_actions":
    return <SchemaWithSubActions request={request} mode={mode} />;
```

```typescript
// webui/src/components/workflow/interactions/schema-with-sub-actions/SchemaWithSubActions.tsx

export function SchemaWithSubActions() {
    const { request, disabled, updateProvider, mode } = useInteraction();
    const [state, setState] = useState<SchemaInteractionState | null>(null);

    // Use existing SchemaInteractionHost with sub-action support enabled
    return (
        <SchemaInteractionHost
            request={request}
            mode={mode || "select"}
            variant={request.display_data?.variant || "cards"}
            disabled={disabled}
            onStateChange={setState}
            enableSubActions={true}  // NEW: enables sub-action rendering
        />
    );
}
```

This is **one small component** that just configures `SchemaInteractionHost`. All rendering is still schema-driven.

---

## Server Side

### Sub-Action Endpoint

Same as before:

```python
@router.post("/workflow/{workflow_run_id}/sub-action/stream")
async def stream_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db: Database = Depends(get_db)
):
    return StreamingResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        media_type="text/event-stream"
    )
```

### Registry Pattern

Same as r5 - simple registry with providers registering their methods:

```python
# Registration
register_sub_action("media.midjourney.txt2img", MidJourneyProvider, "txt2img")

# Execution
provider_class, method_name = get_sub_action_handler(action_type)
provider = provider_class(db)
result = getattr(provider, method_name)(params)
```

---

## Module Configuration

```json
{
    "module_id": "media.generation",
    "inputs": {
        "title": "Generate Images for Prompts",
        "data": "{{ state.prompts }}",
        "display_schema": "{{ step.media_generation_schema }}",
        "param_schemas": {
            "midjourney": "{{ step.midjourney_param_schema }}",
            "leonardo": "{{ step.leonardo_param_schema }}"
        },
        "param_defaults": {
            "midjourney": { "aspect_ratio": "16:9", "speed": "fast" },
            "leonardo": { "width": 1024, "height": 576 }
        }
    }
}
```

The `display_schema` is a full schema document that defines:
- How to render prompts (layouts, labels)
- What sub-actions are available per prompt
- How to render generated images
- Selection behavior

---

## Data Flow Summary

```
┌─────────────────────────────────────────────────────────────────┐
│ Module Config                                                    │
│   display_schema: includes sub_action config per prompt          │
│   param_schemas: per-provider param schemas                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Server: MediaGenerationModule.get_interaction_request()          │
│                                                                 │
│ Returns InteractionRequest:                                     │
│   interaction_type: "schema_with_sub_actions"                   │
│   display_data: { prompts: {...}, generations: {} }             │
│   display_schema: { ... with sub_action configs ... }           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ WebUI: InteractionHost                                          │
│   → routes to SchemaWithSubActions                              │
│   → which uses SchemaInteractionHost + SubActionContext         │
│   → SchemaRenderer renders everything from schema               │
│   → SubActionRenderer handles generate buttons                  │
└─────────────────────────────────────────────────────────────────┘
                              │
              [User clicks Generate on midjourney:prompt_a]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ SubActionRenderer calls streamSubAction()                        │
│                                                                 │
│ POST /workflow/{id}/sub-action/stream                           │
│ {                                                               │
│   action_type: "media.midjourney.txt2img",                      │
│   prompt_id: "prompt_a",                                        │
│   params: {...},                                                │
│   source_data: { subject: "...", environment: "..." }           │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Server: execute_sub_action_stream                               │
│                                                                 │
│ → Registry lookup → MidJourneyProvider.txt2img()                │
│ → Store in content_generation_metadata                          │
│ → Store in generated_content                                    │
│ → SSE: complete { urls, content_ids }                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ WebUI: onSubActionResult()                                      │
│                                                                 │
│ Updates displayData at "generations.midjourney.prompt_a"        │
│ SchemaRenderer re-renders with new images                       │
│ ImageRenderer displays images in grid layout                    │
│ useSelectable enables single selection                          │
└─────────────────────────────────────────────────────────────────┘
                              │
              [User selects an image and clicks Continue]
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Response: { selected_content_id: "gc_xxx" }                     │
│ → Module.execute_with_response()                                │
│ → Returns { selected_image: "gc_xxx" } to state                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Summary of Changes

### WebUI (Minimal)

1. **New UX config property:** `sub_action` in schema types
2. **New generic component:** `SubActionRenderer` (renders any sub-action)
3. **New context:** `SubActionContext` for sub-action state management
4. **Extend SchemaInteractionHost:** Handle sub-action results
5. **New interaction type:** `schema_with_sub_actions` (thin wrapper)

### Server

1. **New endpoint:** `POST /workflow/{id}/sub-action/stream`
2. **Registry pattern:** For sub-action handlers
3. **Provider classes:** MidJourneyProvider, LeonardoProvider, etc.
4. **New module:** MediaGenerationModule (uses existing InteractiveModule pattern)

---

## Questions for Review

1. **Schema template syntax:** Is `{{ $provider }}` acceptable for referencing context variables in schema, or should we use a different syntax?

2. **Existing SchemaForm:** Does a generic `SchemaForm` component already exist that can render forms from JSON Schema, or do we need to add one?

3. **Grid layout:** Does a `grid` layout exist in the layout registry for rendering images, or should we add one?
