# Media Generation Workflow Integration Architecture - R11

## Summary

Design for integrating media generation (images/videos) into workflows via a **sub-action system**. Users can iteratively generate content from prompts, adjust parameters, regenerate, and select results—all within a single interaction step.

**Key Design Decisions:**
- **New module `media.generate`** with new `InteractionType.MEDIA_GENERATION`
- Sub-actions follow the same pattern as retryables (defined in module config, passed through context, put in display_data)
- `sub_actions` is an **array** (like `retryable.options`)
- Provider determined at **runtime** from data structure (not in module config)
- Schema-driven layouts using semantic layout hints
- Editable fields via `schema._ux.input_schema` (with flat properties inside, not nested `_ux`)
- Provider classes follow R3 pattern (classes with methods, not standalone functions)

**R11 Changes from R10:**
- New module `media.generate` instead of extending `user.select`
- New `InteractionType.MEDIA_GENERATION` in contracts
- Correct routing: module → interaction_type → WebUI component

---

## Why New Module?

`user.select` doesn't fit this use case:

| Aspect | user.select | media.generate |
|--------|-------------|----------------|
| Data shape | Flat array to select from | Prompts grouped by provider |
| Interaction | Select from existing data | Edit → Generate → Select from results |
| Output | Selected indices from input | Selected content_id from generations |
| Purpose | Choose from options | Create then choose |

The data structure, interaction pattern, and output are all different. A new module is the clean solution.

---

## Data Flow Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Workflow JSON (module config)                                │
│                                                                 │
│    "module_id": "media.generate",                               │
│    "sub_actions": [                                             │
│      { "id": "generate", "action_type": "txt2img", ... }        │
│    ]                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Executor puts sub_actions on context                         │
│                                                                 │
│    context.sub_actions = module_config.get('sub_actions')       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Module returns InteractionRequest                            │
│                                                                 │
│    InteractionRequest(                                          │
│        interaction_type=InteractionType.MEDIA_GENERATION,       │
│        display_data={                                           │
│            "data": prompts,                                     │
│            "schema": display_schema,                            │
│            "sub_actions": sub_actions,                          │
│        }                                                        │
│    )                                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. WebUI InteractionHost routes by interaction_type             │
│                                                                 │
│    case "media_generation":                                     │
│        return <MediaGeneration />;                              │
└─────────────────────────────────────────────────────────────────┘
```

---

## Contracts Update

### InteractionType Enum

```python
# contracts/interactions.py

class InteractionType(str, Enum):
    TEXT_INPUT = "text_input"
    FILE_INPUT = "file_input"
    FILE_DOWNLOAD = "file_download"
    SELECT_FROM_STRUCTURED = "select_from_structured"
    REVIEW_GROUPED = "review_grouped"
    FORM_INPUT = "form_input"
    MEDIA_GENERATION = "media_generation"  # NEW
```

---

## Prompts Data Structure

Prompts from previous workflow step, grouped by provider:

```json
{
  "prompts": {
    "midjourney": {
      "prompt_a": {
        "subject": "contemplative person in partial profile...",
        "environment": "snug indoor room, exposed brick walls...",
        "objects": "small side table with warm lamp...",
        "motion": "lamp glow gently pulsing...",
        "atmosphere": "warm, dim, introspective...",
        "particles": "dust particles glowing..."
      },
      "prompt_b": {
        "subject": "quiet journaling person in armchair...",
        "environment": "intimate, safe room mood..."
      }
    },
    "leonardo": {
      "phoenix_1_0": "Primary subject: a contemplative person...",
      "anime_xl": "Primary subject: a contemplative person..."
    }
  }
}
```

**Structure:** `prompts[provider][prompt_id] = prompt_content`

---

## Workflow Module Configuration

```json
{
  "module_id": "media.generate",
  "inputs": {
    "prompts": "{{ state.generated_prompts }}",
    "schema": {
      "$ref": "schemas/media_generation_display_schema.json",
      "type": "json"
    },
    "title": "Generate and Select Images"
  },
  "sub_actions": [
    {
      "id": "generate",
      "label": "Generate Images",
      "action_type": "txt2img",
      "loading_label": "Generating...",
      "result_key": "generations"
    }
  ],
  "outputs_to_state": {
    "selected_content_id": "selected_image_id",
    "selected_content": "selected_image_data"
  },
  "name": "generate_and_select_images"
}
```

### Sub-Action Config Schema

```typescript
interface SubActionConfig {
  id: string;              // Unique identifier: "generate"
  label: string;           // Button text: "Generate Images"
  action_type: string;     // Operation: "txt2img", "img2img", "img2vid"
  loading_label?: string;  // "Generating..."
  result_key: string;      // Where results accumulate in display_data
}
```

---

## Display Schema

Uses `display_format` for combined prompt text and `input_schema` for generation parameters.

```json
{
  "type": "object",
  "_ux": { "display": "passthrough" },
  "properties": {
    "prompts": {
      "type": "object",
      "_ux": { "display": "passthrough" },
      "properties": {
        "midjourney": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "render_as": "section",
            "display_label": "Midjourney"
          },
          "properties": {
            "prompt_a": {
              "type": "object",
              "_ux": {
                "display": "visible",
                "render_as": "content-panel",
                "display_label": "Prompt A",
                "display_format": "{{ state.selected_core_aesthetic.mj.art_style_prefix }} {{ subject }}::3 {{ environment }}. {{ particles }}::2 {{ objects }}::1.5 {{ motion }}::1.5 {{ atmosphere }}::1 {{ state.selected_core_aesthetic.mj.params }}",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "aspect_ratio": {
                      "type": "string",
                      "title": "Aspect Ratio",
                      "enum": ["1:1", "16:9", "9:16", "4:3"],
                      "default": "16:9",
                      "input_type": "select",
                      "width": "third"
                    },
                    "speed": {
                      "type": "string",
                      "title": "Speed",
                      "enum": ["relaxed", "fast", "turbo"],
                      "default": "fast",
                      "input_type": "select",
                      "width": "third"
                    },
                    "stylization": {
                      "type": "integer",
                      "title": "Stylization",
                      "minimum": 0,
                      "maximum": 1000,
                      "default": 100,
                      "input_type": "slider",
                      "width": "full"
                    }
                  }
                }
              },
              "properties": {
                "subject": { "type": "string" },
                "environment": { "type": "string" },
                "objects": { "type": "string" },
                "motion": { "type": "string" },
                "atmosphere": { "type": "string" },
                "particles": { "type": "string" }
              }
            }
          }
        }
      }
    }
  }
}
```

---

## Server Implementation

### New Module: media.generate

```python
# server/modules/media/generate.py

from typing import Dict, Any, Optional
import uuid6

from contracts.interactions import InteractionType, InteractionRequest
from engine.module_interface import InteractiveModule


class MediaGenerateModule(InteractiveModule):
    """
    Interactive module for media generation workflows.

    Presents prompts grouped by provider, allows editing,
    triggers generation via sub-actions, and collects selection.
    """

    module_id = "media.generate"

    @classmethod
    def get_input_schema(cls) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "prompts": {
                    "type": "object",
                    "description": "Prompts grouped by provider"
                },
                "schema": {
                    "type": "object",
                    "description": "Display schema with _ux hints"
                },
                "title": {
                    "type": "string",
                    "description": "Interaction title"
                }
            },
            "required": ["prompts", "schema"]
        }

    @classmethod
    def get_output_schema(cls) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "selected_content_id": {
                    "type": "string",
                    "description": "ID of selected generated content"
                },
                "selected_content": {
                    "type": "object",
                    "description": "Full data of selected content"
                },
                "generations": {
                    "type": "object",
                    "description": "All generations by prompt key"
                }
            }
        }

    def get_interaction_request(
        self,
        inputs: Dict[str, Any],
        context
    ) -> Optional[InteractionRequest]:
        prompts = inputs.get('prompts', {})
        schema = inputs.get('schema', {})
        title = inputs.get('title', 'Generate Media')

        # Get sub_actions from context (set by executor from module config)
        sub_actions = getattr(context, 'sub_actions', None)

        return InteractionRequest(
            interaction_type=InteractionType.MEDIA_GENERATION,
            interaction_id=f"media_{uuid6.uuid7().hex}",
            title=title,
            display_data={
                "data": {"prompts": prompts},
                "schema": schema,
                "sub_actions": sub_actions,
                "generations": {}
            },
            context={
                "module_id": self.module_id
            }
        )

    def execute_with_response(
        self,
        inputs: Dict[str, Any],
        response: Dict[str, Any],
        context
    ) -> Dict[str, Any]:
        """Process user's selection after generation."""
        selected_content_id = response.get('selected_content_id')
        generations = response.get('generations', {})

        # Find selected content data from generations
        selected_content = None
        if selected_content_id:
            for prompt_key, gen_list in generations.items():
                for gen in gen_list:
                    if selected_content_id in gen.get('content_ids', []):
                        idx = gen['content_ids'].index(selected_content_id)
                        selected_content = {
                            'content_id': selected_content_id,
                            'url': gen['urls'][idx],
                            'metadata_id': gen['metadata_id'],
                            'prompt_key': prompt_key
                        }
                        break
                if selected_content:
                    break

        return {
            'selected_content_id': selected_content_id,
            'selected_content': selected_content,
            'generations': generations
        }
```

### Module Registration

```python
# server/modules/media/__init__.py

from .generate import MediaGenerateModule

__all__ = ['MediaGenerateModule']
```

```python
# server/engine/module_registry.py (add to registration)

from modules.media import MediaGenerateModule

# In registry initialization:
registry.register(MediaGenerateModule)
```

### Executor Change

```python
# server/workflow/executor.py

# In execute_step_modules, where retryable is set:
context.retryable = module_config.get('retryable')
context.sub_actions = module_config.get('sub_actions')  # ADD THIS
```

---

## Provider Implementation

### Registry

```python
# server/workflow/sub_action/registry.py

from typing import Dict, Type
from .providers.base import MediaProviderBase

_PROVIDER_REGISTRY: Dict[str, Type[MediaProviderBase]] = {}


def register_provider(name: str, provider_class: Type[MediaProviderBase]):
    _PROVIDER_REGISTRY[name] = provider_class


def get_provider(name: str) -> Type[MediaProviderBase]:
    if name not in _PROVIDER_REGISTRY:
        raise ValueError(f"Unknown provider: {name}")
    return _PROVIDER_REGISTRY[name]
```

### Base Class

```python
# server/workflow/sub_action/providers/base.py

from abc import ABC, abstractmethod
from typing import List, Tuple, Optional, Callable


class MediaProviderBase(ABC):
    """Base class for media generation providers."""

    @abstractmethod
    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from text. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate images from image. Returns (urls, raw_response)."""
        pass

    @abstractmethod
    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        """Generate video from image. Returns (urls, raw_response)."""
        pass
```

### MidJourney Provider

```python
# server/workflow/sub_action/providers/midjourney.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class MidJourneyProvider(MediaProviderBase):
    """MidJourney provider via MidAPI."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        ...midapi access logic
        return imagine(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        ...midapi access logic
        return vary(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        raise NotImplementedError("MidJourney does not support img2vid")


register_provider("midjourney", MidJourneyProvider)
```

### Leonardo Provider

```python
# server/workflow/sub_action/providers/leonardo.py

from typing import List, Tuple, Optional, Callable
from .base import MediaProviderBase
from ..registry import register_provider


class LeonardoProvider(MediaProviderBase):
    """Leonardo AI provider."""

    def txt2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        ...leonardo api access logic
        return generate(params, progress_callback=progress_callback)

    def img2img(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        ...leonardo api access logic
        return generate_with_image(params, progress_callback=progress_callback)

    def img2vid(
        self,
        params: dict,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> Tuple[List[str], dict]:
        ...leonardo api access logic
        return motion(params, progress_callback=progress_callback)


register_provider("leonardo", LeonardoProvider)
```

---

## Sub-Action API

### Route

```python
# server/api/routes/workflow.py

from pydantic import BaseModel
from sse_starlette.sse import EventSourceResponse


class SubActionRequest(BaseModel):
    interaction_id: str
    provider: str           # "midjourney", "leonardo"
    action_type: str        # "txt2img", "img2img", "img2vid"
    prompt_id: str          # "prompt_a"
    params: Dict[str, Any]  # Generation parameters
    source_data: Any        # Full prompt data


@router.post("/{workflow_run_id}/sub-action")
async def execute_sub_action(
    workflow_run_id: str,
    request: SubActionRequest,
    db = Depends(get_db)
):
    return EventSourceResponse(
        execute_sub_action_stream(workflow_run_id, request, db),
        send_timeout=5
    )
```

### Executor

```python
# server/workflow/sub_action/executor.py

import asyncio
import json
import uuid6
import concurrent.futures

from .registry import get_provider


def sse_event(event_type: str, data: dict) -> str:
    return f"event: {event_type}\ndata: {json.dumps(data)}\n\n"


async def execute_sub_action_stream(
    workflow_run_id: str,
    request: SubActionRequest,
    db
):
    action_id = f"sa_{uuid6.uuid7().hex[:8]}"
    yield sse_event("started", {"action_id": action_id})

    try:
        provider_class = get_provider(request.provider)
        provider = provider_class()
        method = getattr(provider, request.action_type)

        loop = asyncio.get_event_loop()
        progress_queue = asyncio.Queue()

        def progress_callback(elapsed_ms: int, message: str):
            loop.call_soon_threadsafe(
                progress_queue.put_nowait,
                {"elapsed_ms": elapsed_ms, "message": message}
            )

        executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
        future = loop.run_in_executor(
            executor,
            lambda: method(request.params, progress_callback=progress_callback)
        )

        while not future.done():
            try:
                progress = await asyncio.wait_for(progress_queue.get(), timeout=0.5)
                yield sse_event("progress", progress)
            except asyncio.TimeoutError:
                pass

        urls, raw_response = await future

        metadata_id = db.content_repo.store_generation(
            workflow_run_id=workflow_run_id,
            interaction_id=request.interaction_id,
            provider=request.provider,
            prompt_id=request.prompt_id,
            operation=request.action_type,
            request_params=request.params,
            source_data=request.source_data,
            response_data=raw_response
        )

        content_ids = []
        content_type = "video" if request.action_type == "img2vid" else "image"

        for index, url in enumerate(urls):
            content_id = db.content_repo.store_content(
                metadata_id=metadata_id,
                workflow_run_id=workflow_run_id,
                index=index,
                provider_url=url,
                content_type=content_type
            )
            content_ids.append(content_id)

        yield sse_event("complete", {
            "urls": urls,
            "metadata_id": metadata_id,
            "content_ids": content_ids
        })

    except Exception as e:
        yield sse_event("error", {"message": str(e)})
```

---

## WebUI Implementation

### TypeScript Types

```typescript
// webui/src/lib/types.ts

// Add to InteractionType
export type InteractionType =
  | "text_input"
  | "file_input"
  | "file_download"
  | "select_from_structured"
  | "review_grouped"
  | "form_input"
  | "media_generation";  // NEW

export interface SubActionConfig {
  id: string;
  label: string;
  action_type: string;
  loading_label?: string;
  result_key: string;
}

export interface GenerationResult {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}
```

### InteractionHost Update

```typescript
// webui/src/components/workflow/interactions/InteractionHost.tsx

import { MediaGeneration } from "./media-generation";

function InteractionContent({ type }: { type: string }) {
  switch (type) {
    case "text_input":
      return <TextInputEnhanced />;
    case "file_input":
      return <FileInputDropzone />;
    case "file_download":
      return <FileDownload />;
    case "select_from_structured":
      return <StructuredSelect />;
    case "review_grouped":
      return <ReviewGrouped />;
    case "form_input":
      return <FormInput />;
    case "media_generation":
      return <MediaGeneration />;
    default:
      return (
        <div className="p-4 text-center text-muted-foreground">
          Unsupported interaction type: {type}
        </div>
      );
  }
}
```

### MediaGeneration Component

```typescript
// webui/src/components/workflow/interactions/media-generation/MediaGeneration.tsx

import { useState, useEffect, useRef, useCallback } from "react";
import { useInteraction, ActionSlot } from "@/lib/interaction-context";
import { getUx } from "../schema-interaction/ux-utils";
import { renderTemplate } from "@/lib/template-service";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import type { SubActionConfig, GenerationResult } from "@/lib/types";

export function MediaGeneration() {
  const { request, disabled, updateProvider, mode } = useInteraction();
  const isReadonly = mode.type === "readonly";

  const displayData = request.display_data || {};
  const data = displayData.data as { prompts: Record<string, Record<string, any>> };
  const schema = displayData.schema as Record<string, any>;
  const subActions = displayData.sub_actions as SubActionConfig[] | undefined;

  // State
  const [editedPrompts, setEditedPrompts] = useState<Record<string, string>>({});
  const [generations, setGenerations] = useState<Record<string, GenerationResult[]>>(
    displayData.generations || {}
  );
  const [selectedContentId, setSelectedContentId] = useState<string | null>(null);
  const [loadingPrompts, setLoadingPrompts] = useState<Set<string>>(new Set());
  const [progress, setProgress] = useState<{ elapsed_ms: number; message: string } | null>(null);

  // Refs for closure
  const selectedRef = useRef(selectedContentId);
  selectedRef.current = selectedContentId;
  const generationsRef = useRef(generations);
  generationsRef.current = generations;

  // Register with InteractionHost
  useEffect(() => {
    updateProvider({
      getState: () => ({
        isValid: selectedRef.current !== null,
        selectedCount: selectedRef.current ? 1 : 0,
        selectedGroupIds: [],
      }),
      getResponse: () => ({
        selected_content_id: selectedRef.current,
        generations: generationsRef.current,
      }),
    });
  }, [updateProvider, selectedContentId]);

  // Get prompt text (render display_format if present)
  const getPromptText = useCallback((provider: string, promptId: string, promptData: any) => {
    const promptKey = `${provider}:${promptId}`;
    if (editedPrompts[promptKey] !== undefined) {
      return editedPrompts[promptKey];
    }

    const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
    const ux = getUx(promptSchema || {});

    if (ux.display_format) {
      return renderTemplate(ux.display_format, promptData, {});
    }

    if (typeof promptData === 'string') return promptData;
    return Object.values(promptData).join(' ');
  }, [editedPrompts, schema]);

  // Handle prompt editing
  const handlePromptEdit = (provider: string, promptId: string, text: string) => {
    setEditedPrompts(prev => ({ ...prev, [`${provider}:${promptId}`]: text }));
  };

  // Execute sub-action
  const handleSubAction = async (
    actionConfig: SubActionConfig,
    provider: string,
    promptId: string,
    promptData: any
  ) => {
    const promptKey = `${provider}:${promptId}`;
    setLoadingPrompts(prev => new Set(prev).add(promptKey));
    setProgress(null);

    try {
      const promptText = getPromptText(provider, promptId, promptData);

      // Get defaults from input_schema
      const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
      const ux = getUx(promptSchema || {});
      const inputProps = ux.input_schema?.properties || {};

      const params: Record<string, any> = { prompt: promptText };
      for (const [key, fieldSchema] of Object.entries(inputProps as Record<string, any>)) {
        if (fieldSchema.default !== undefined) {
          params[key] = fieldSchema.default;
        }
      }

      const response = await fetch(
        `/api/workflow/${request.workflow_run_id}/sub-action`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            interaction_id: request.interaction_id,
            provider,
            action_type: actionConfig.action_type,
            prompt_id: promptId,
            params,
            source_data: promptData
          })
        }
      );

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (reader) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const eventData = JSON.parse(line.slice(6));
            if (eventData.elapsed_ms !== undefined) {
              setProgress(eventData);
            }
            if (eventData.urls) {
              setGenerations(prev => ({
                ...prev,
                [promptKey]: [...(prev[promptKey] || []), eventData]
              }));
            }
          }
        }
      }
    } finally {
      setLoadingPrompts(prev => {
        const next = new Set(prev);
        next.delete(promptKey);
        return next;
      });
      setProgress(null);
    }
  };

  const providers = Object.keys(data?.prompts || {});

  return (
    <div className="space-y-6">
      {providers.map(provider => {
        const providerPrompts = data.prompts[provider];
        const promptIds = Object.keys(providerPrompts);

        return (
          <div key={provider} className="space-y-4">
            <h3 className="text-lg font-semibold capitalize">{provider}</h3>

            {promptIds.map(promptId => {
              const promptKey = `${provider}:${promptId}`;
              const promptData = providerPrompts[promptId];
              const promptText = getPromptText(provider, promptId, promptData);
              const isLoading = loadingPrompts.has(promptKey);
              const promptGenerations = generations[promptKey] || [];

              return (
                <div key={promptId} className="border rounded-lg p-4 space-y-4">
                  <div className="font-medium">{promptId.replace(/_/g, ' ')}</div>

                  <Textarea
                    value={promptText}
                    onChange={(e) => handlePromptEdit(provider, promptId, e.target.value)}
                    disabled={disabled || isReadonly || isLoading}
                    className="min-h-[100px] font-mono text-sm"
                  />

                  {!isReadonly && (
                    <PromptParams
                      provider={provider}
                      promptId={promptId}
                      schema={schema}
                      disabled={disabled || isLoading}
                    />
                  )}

                  {promptGenerations.length > 0 && (
                    <MediaGrid
                      generations={promptGenerations}
                      selectedContentId={selectedContentId}
                      onSelect={setSelectedContentId}
                    />
                  )}

                  {isLoading && progress && (
                    <div className="text-sm text-muted-foreground">
                      {progress.message} ({Math.round(progress.elapsed_ms / 1000)}s)
                    </div>
                  )}

                  {!isReadonly && subActions?.map(action => (
                    <ActionSlot key={`${promptKey}-${action.id}`} id={`${promptKey}-${action.id}`}>
                      <Button
                        variant="outline"
                        onClick={() => handleSubAction(action, provider, promptId, promptData)}
                        disabled={disabled || isLoading}
                      >
                        {isLoading ? action.loading_label || 'Processing...' : action.label}
                      </Button>
                    </ActionSlot>
                  ))}
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
}

function PromptParams({ provider, promptId, schema, disabled }: {
  provider: string;
  promptId: string;
  schema: any;
  disabled: boolean;
}) {
  const promptSchema = schema?.properties?.prompts?.properties?.[provider]?.properties?.[promptId];
  const ux = getUx(promptSchema || {});
  const inputSchema = ux.input_schema;

  if (!inputSchema?.properties) return null;

  return (
    <div className="grid grid-cols-3 gap-4">
      {Object.entries(inputSchema.properties as Record<string, any>).map(([key, fieldSchema]) => (
        <ParamField key={key} name={key} schema={fieldSchema} disabled={disabled} />
      ))}
    </div>
  );
}

function ParamField({ name, schema, disabled }: { name: string; schema: any; disabled: boolean }) {
  const title = schema.title || name;

  if (schema.enum) {
    return (
      <div className="space-y-1">
        <label className="text-sm font-medium">{title}</label>
        <select className="w-full border rounded px-2 py-1" disabled={disabled} defaultValue={schema.default}>
          {schema.enum.map((opt: string) => (
            <option key={opt} value={opt}>{schema.enum_labels?.[opt] || opt}</option>
          ))}
        </select>
      </div>
    );
  }

  if (schema.input_type === 'slider') {
    return (
      <div className="space-y-1">
        <label className="text-sm font-medium">{title}</label>
        <input
          type="range"
          className="w-full"
          min={schema.minimum}
          max={schema.maximum}
          defaultValue={schema.default}
          disabled={disabled}
        />
      </div>
    );
  }

  return null;
}

function MediaGrid({ generations, selectedContentId, onSelect }: {
  generations: GenerationResult[];
  selectedContentId: string | null;
  onSelect: (id: string) => void;
}) {
  const allContent = generations.flatMap(gen =>
    gen.content_ids.map((id, idx) => ({ contentId: id, url: gen.urls[idx] }))
  );

  return (
    <div className="grid grid-cols-4 gap-2">
      {allContent.map(item => (
        <div
          key={item.contentId}
          className={cn(
            'relative cursor-pointer rounded-md overflow-hidden border-2',
            selectedContentId === item.contentId ? 'border-primary' : 'border-transparent hover:border-muted'
          )}
          onClick={() => onSelect(item.contentId)}
        >
          <img src={item.url} alt="" className="w-full h-auto aspect-square object-cover" />
          {selectedContentId === item.contentId && (
            <div className="absolute top-1 right-1 bg-primary text-primary-foreground rounded-full p-1">
              <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Index Export

```typescript
// webui/src/components/workflow/interactions/media-generation/index.ts

export { MediaGeneration } from "./MediaGeneration";
```

---

## Database Schema

```sql
CREATE TABLE content_generation_metadata (
    content_generation_metadata_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    interaction_id TEXT NOT NULL,
    provider TEXT NOT NULL,
    provider_task_id TEXT,
    prompt_id TEXT NOT NULL,
    operation TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    status TEXT DEFAULT 'pending',
    request_params JSONB,
    source_data JSONB,
    response_data JSONB,
    error_message TEXT,
    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id)
);

CREATE TABLE generated_content (
    generated_content_id TEXT PRIMARY KEY,
    workflow_run_id TEXT NOT NULL,
    content_generation_metadata_id TEXT NOT NULL,
    index INTEGER NOT NULL,
    provider_content_id TEXT, 
    content_type TEXT NOT NULL,
    provider_url TEXT NOT NULL,
    local_path TEXT,
    downloaded_at TIMESTAMP,
    FOREIGN KEY (workflow_run_id) REFERENCES workflow_runs(workflow_run_id),
    FOREIGN KEY (content_generation_metadata_id)
        REFERENCES content_generation_metadata(content_generation_metadata_id)
);

CREATE INDEX idx_cgm_workflow_run ON content_generation_metadata(workflow_run_id);
CREATE INDEX idx_cgm_interaction ON content_generation_metadata(interaction_id);
CREATE INDEX idx_gc_workflow_run ON generated_content(workflow_run_id);
CREATE INDEX idx_gc_metadata ON generated_content(content_generation_metadata_id);
```

---

## File Structure

```
server/
├── modules/
│   └── media/
│       ├── __init__.py
│       ├── registry.py
│       ├── midjourney.py
│       ├── leonardo.py
│       └── generate.py          # MediaGenerateModule
│
├── workflow/
│   ├── executor.py              # Add context.sub_actions
│   └── sub_action/
│       ├── __init__.py
│       ├── executor.py
│
├── api/routes/
│   └── workflow.py              # Add sub-action endpoint
│
└── db/
    └── content_repository.py

contracts/
└── interactions.py              # Add MEDIA_GENERATION

webui/src/
├── components/workflow/interactions/
│   ├── media-generation/
│   │   ├── index.ts
│   │   └── MediaGeneration.tsx
│   └── InteractionHost.tsx      # Add routing
│
└── lib/
    └── types.ts                 # Add types
```

---

## Summary

| Component | What |
|-----------|------|
| Module | New `media.generate` module |
| InteractionType | New `MEDIA_GENERATION` |
| Routing | `media_generation` → `MediaGeneration` component |
| Data | Prompts by provider, not flat array |
| Interaction | Edit prompt → Generate → Select |
| Output | Selected content_id from generations |

---

## Implementation Plan of Action (POA)

Focus: Providers, Database, and SSE Streaming

### Phase 1: Database Schema + Migration + Repository
- [x] **1.1** Create migration `m_10.py` with:
  - `content_generation_metadata` collection with indexes
  - `generated_content` collection with indexes
- [x] **1.2** Create `server/db/content_repository.py` with:
  - `ContentRepository` class inheriting from `BaseRepository`
  - `store_generation()` method - stores generation metadata
  - `update_generation_status()` method - updates status/error
  - `store_content()` method - stores individual content items
  - `get_generation()` method - retrieves generation by ID
  - `get_generations_for_interaction()` method - gets all generations for an interaction
- [x] **1.3** Register `ContentRepository` in `server/db/__init__.py`

### Phase 2: Provider Base Class + Registry
- [x] **2.1** Create `server/modules/media/__init__.py` (package init)
- [x] **2.2** Create `server/modules/media/base.py` with:
  - `MediaProviderBase` abstract class
  - Abstract methods: `txt2img()`, `img2img()`, `img2vid()`
  - Common return type: `Tuple[List[str], dict]` (urls, raw_response)
  - Progress callback type definition
- [x] **2.3** Create `server/modules/media/registry.py` with:
  - `_PROVIDER_REGISTRY` dict
  - `register_provider()` function
  - `get_provider()` function
  - `@register` decorator

### Phase 3: MidAPI Provider Implementation
- [x] **3.1** Create `server/modules/media/midapi/__init__.py`
- [x] **3.2** Create `server/modules/media/midapi/provider.py` with:
  - `MidAPIProvider` class implementing `MediaProviderBase`
  - `txt2img()` - POST /api/v1/mj/generate with taskType=mj_txt2img, poll for result
  - `vary()` - POST /api/v1/mj/generateVary with taskId+imageIndex (MidAPI-specific)
  - `img2img()` - raises NotImplementedError (use vary() instead)
  - `img2vid()` - POST /api/v1/mj/generate with taskType=mj_video
  - Polling logic with progress callback
  - Error handling for API errors (401, 402, 429, etc.)
- [ ] **3.3** Test MidAPI provider standalone (deferred to integration testing)

### Phase 4: Leonardo Provider Implementation
- [x] **4.1** Create `server/modules/media/leonardo/__init__.py`
- [x] **4.2** Create `server/modules/media/leonardo/provider.py` with:
  - `LeonardoProvider` class implementing `MediaProviderBase`
  - `txt2img()` - POST /generations, poll GET /generations/{id}
  - `img2img()` - POST /generations with init_generation_image_id
  - `img2vid()` - POST /generations-image-to-video, poll for result
  - Model selection: `model` param for base models (PHOENIX, FLUX), `model_id` for custom UUIDs
  - Polling logic with progress callback
  - Error handling
- [ ] **4.3** Test Leonardo provider standalone (deferred to integration testing)

### Phase 5: Sub-Action Executor with SSE Streaming
- [x] **5.1** Create `server/workflow/sub_action/__init__.py`
- [x] **5.2** Create `server/workflow/sub_action/executor.py` with:
  - `execute_sub_action_stream()` async generator
  - `SubActionRequest` dataclass for request data
  - SSE event formatting (started, progress, complete, error)
  - Thread pool for sync provider calls
  - Progress queue bridging sync→async
  - Database storage of generation metadata and content
  - Comprehensive error handling for all provider exceptions

### Phase 6: API Route
- [x] **6.1** Create `SubActionRequest` Pydantic model in `models/requests.py`
- [x] **6.2** Add POST `/{workflow_run_id}/sub-action` endpoint to `api/routes/streaming.py`
  - Returns `EventSourceResponse`
  - Calls `execute_sub_action_stream()`
  - Converts Pydantic model to executor dataclass

### Implementation Details

**Environment Variables:**
- `MIDAPI_API_KEY` - MidAPI bearer token
- `LEONARDO_API_KEY` - Leonardo AI bearer token

**Polling Configuration:**
- Poll interval: 2 seconds
- Max timeout: 5 minutes (300 seconds)
- Max poll attempts: 150

**SSE Event Types:**
```
event: started
data: {"action_id": "sa_xxx"}

event: progress
data: {"elapsed_ms": 5000, "message": "Generating..."}

event: complete
data: {"urls": [...], "metadata_id": "...", "content_ids": [...]}

event: error
data: {"message": "Error description"}
```

**Error Handling:**
- 401 Unauthorized → "Invalid API key"
- 402 Insufficient Credits → "Insufficient credits"
- 429 Rate Limited → "Rate limited, try again later"
- Timeout → "Generation timed out after 5 minutes"
- Generation failed → Provider-specific error message

---

## Implementation Completion Notes

**Completed: 2026-01-18**

### Implemented Components

| Component | Status | Notes |
|-----------|--------|-------|
| Database Migration (m_10.py) | ✅ | MongoDB indexes for content collections |
| ContentRepository | ✅ | All methods implemented |
| MediaProviderBase | ✅ | With `GenerationResult` return type |
| MediaProviderRegistry | ✅ | With `@register` decorator |
| MidAPIProvider | ✅ | txt2img, vary, img2vid |
| LeonardoProvider | ✅ | txt2img, img2img, img2vid |
| Sub-action SSE streaming | ✅ | Domain events + endpoint formatting |
| API endpoint routing | ✅ | Routes by module_id |

### Deviations from Original Design

#### 1. File Structure Changes

**Original:**
```
server/workflow/sub_action/
├── executor.py
├── providers/
│   ├── base.py
│   ├── midjourney.py
│   └── leonardo.py
```

**Implemented:**
```
server/modules/media/
├── base.py              # Provider base class
├── registry.py          # Provider registry
├── sub_action.py        # Media sub-action handler (NEW)
├── midapi/
│   └── provider.py      # MidAPI provider
└── leonardo/
    └── provider.py      # Leonardo provider

models/
└── sub_action.py        # Shared sub-action event types (NEW)
```

**Rationale:** Sub-action logic is module-specific. Media sub-actions belong in the media module, not a centralized executor. This allows other modules to implement their own sub-action handlers.

#### 2. SSE Formatting Location

**Original:** Executor yields SSE-formatted events (`{"event": "...", "data": "..."}`)

**Implemented:**
- Module handler yields domain events (dataclasses: `SubActionStarted`, `SubActionProgress`, `SubActionComplete`, `SubActionError`)
- API endpoint formats domain events to SSE

**Rationale:** Separation of concerns. Domain logic shouldn't know about SSE formatting. Matches pattern used by other streaming endpoints.

#### 3. Module-based Routing

**Original:** Sub-action endpoint directly calls executor

**Implemented:**
- `module_id` stored in INTERACTION_REQUESTED event data
- `module_id` stored in INTERACTION_RESPONSE event data
- API endpoint looks up `module_id` from interaction event
- Routes to appropriate module's sub-action handler

**Files changed:**
- `workflow/executor.py` - Added `module_id` to INTERACTION_REQUESTED data
- `workflow/processor.py` - Added `module_id` to INTERACTION_RESPONSE data
- `workflow/streaming.py` - Added `module_id` to INTERACTION_RESPONSE data
- `api/routes/streaming.py` - Routes based on `module_id`

**Rationale:** Extensibility. Other modules can implement sub-actions by adding a case in the routing logic.

#### 4. Provider Return Type

**Original:** `Tuple[List[str], dict]` (urls, raw_response)

**Implemented:** `GenerationResult` dataclass with fields:
- `urls: List[str]`
- `raw_response: Dict[str, Any]`
- `provider_task_id: Optional[str]`

**Rationale:** Type safety and clarity. Dataclass is self-documenting.

#### 5. MidAPI Provider

**Changes from doc:**
- `img2img()` raises `NotImplementedError` - MidJourney doesn't support true img2img
- Added `vary()` method for MidJourney variations (uses generateVary endpoint)
- `img2vid()` implemented using `mj_video` taskType (was NotImplementedError in doc)
- Added `variety` parameter support for txt2img

#### 6. Leonardo Provider

**Changes from doc:**
- Model selection uses `sd_version` parameter for base models (PHOENIX, FLUX, SDXL_1_0, etc.)
- `model_id` is optional override for custom trained models (UUIDs)
- Added `alchemy` and `photoReal` support for premium features

### Shared Sub-Action Events

New file `models/sub_action.py` exports:

```python
@dataclass
class SubActionStarted:
    action_id: str

@dataclass
class SubActionProgress:
    elapsed_ms: int
    message: str

@dataclass
class SubActionComplete:
    urls: List[str]
    metadata_id: str
    content_ids: List[str]

@dataclass
class SubActionError:
    message: str
    retry_after: Optional[int] = None

SubActionEvent = SubActionStarted | SubActionProgress | SubActionComplete | SubActionError
```

These are module-agnostic and can be used by any sub-action handler.

### Updated File Structure

```
server/
├── models/
│   ├── sub_action.py           # Shared sub-action event types
│   └── requests.py             # SubActionRequest Pydantic model
│
├── modules/media/
│   ├── __init__.py
│   ├── base.py                 # MediaProviderBase, GenerationResult
│   ├── registry.py             # MediaProviderRegistry
│   ├── sub_action.py           # execute_media_sub_action()
│   ├── midapi/
│   │   ├── __init__.py
│   │   └── provider.py         # MidAPIProvider
│   └── leonardo/
│       ├── __init__.py
│       └── provider.py         # LeonardoProvider
│
├── db/
│   ├── migrations/m_10.py      # Content generation tables
│   └── content_repository.py   # ContentRepository
│
├── workflow/
│   ├── executor.py             # Added module_id to INTERACTION_REQUESTED
│   ├── processor.py            # Added module_id to INTERACTION_RESPONSE
│   └── streaming.py            # Added module_id to INTERACTION_RESPONSE
│
└── api/routes/
    └── streaming.py            # Sub-action endpoint with routing
```

### Not Implemented (Deferred)

- `media.generate` module - UI/module work deferred
- `InteractionType.MEDIA_GENERATION` - contracts update deferred
- WebUI `MediaGeneration` component - UI work deferred
- Standalone provider testing - deferred to integration testing
