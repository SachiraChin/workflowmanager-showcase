 Media Generation Separation: Image vs Video (R5)

## Summary

Refactor media-generation to separate image/video generation AND
decentralize state management. Currently MediaGeneration centralizes
state for all tabs - but each tab is independent and should manage its
own state.

## Decisions from Review

- **Option A confirmed**: 3-level (`tab.media.image_generation`)
- **Naming confirmed**: `ImageGeneration` / `VideoGeneration`
- **New syntax needed**: `tab.media[input_schema,image_generation]`
- **Task reconnection**: Not working, remove for now
- **Decentralize state**: Each component manages its own state

## Architecture Problem Analysis

### Current: Centralized State (Wrong)

```
MediaGeneration
├── State for ALL tabs:
│   ├── generations: Record<path, GenerationResult[]>  ← path-keyed map
│   ├── loadingPrompts: Set<path>                      ← path-keyed set
│   ├── progressByPrompt: Record<path, ProgressState>  ← path-keyed map
│   ├── errorsByPrompt: Record<path, string>           ← path-keyed map
│   ├── previewByPrompt: Record<path, PreviewInfo>     ← path-keyed map
│   └── selectedContentId: string | null               ← ONLY shared state
│
├── API calls for ALL tabs
└── Context exposes getters keyed by path
```

**Problems:**
1. Each tab is independent - why centralize?
2. Path-keyed maps add complexity
3. Ref stability hacks needed because of centralization
4. 553 lines of complexity for no benefit

### Proposed: Decentralized State (Correct)

```
MediaGeneration (SIMPLIFIED)
├── State: selectedContentId only (truly shared)
├── Context: selection + updateProvider integration
└── Render: SchemaRenderer

ImageGeneration / VideoGeneration (each instance)
├── Own state: generations, loading, progress, error, preview
├── Own API calls: executeSubAction, fetchPreview
└── Own UI rendering
```

**Benefits:**
1. Each component is self-contained
2. No path-keyed maps
3. No ref stability hacks needed
4. Simpler code in each place

### What's Actually Shared?

Only these need to be in MediaGenerationContext:

| Item | Shared? | Reason |
|------|---------|--------|
| selectedContentId | YES | Global selection across all tabs |
| onSelectContent | YES | Updates global selection |
| subActions | YES | From display_data, same for all |
| readonly/disabled | YES | Interaction-level flags |
| updateProvider | YES | InteractionHost integration |

Everything else is per-component:
- generations (each tab has its own)
- loading/progress/error (each tab has its own)
- preview (each tab has its own)
- crop state (video only)

## Revised Component Design

### MediaGeneration (Simplified)

<!--lets rename this to MediaGenerationHost for clarity-->
```tsx
export function MediaGeneration() {
  const { request, disabled, updateProvider, mode } = useInteraction();
  const isReadonly = mode.type === "readonly";

  const displayData = request.display_data || {};
  const data = displayData.data;
  const schema = displayData.schema;
  const subActions = displayData.sub_actions || [];

  // ONLY shared state
  const [selectedContentId, setSelectedContentId] = useState<string | null>(null);

  // Track all generations for response (populated by children)
  const generationsRef = useRef<Record<string, GenerationResult[]>>({});

  // Register generation from child components
  const registerGeneration = useCallback((path: string, result: GenerationResult) => {
    generationsRef.current[path] = [
      ...(generationsRef.current[path] || []),
      result
    ];
  }, []);

  // InteractionHost integration
  useEffect(() => {
    updateProvider({
      getState: () => ({
        isValid: selectedContentId !== null,
        selectedCount: selectedContentId ? 1 : 0,
        selectedGroupIds: [],
      }),
      getResponse: () => ({
        selected_content_id: selectedContentId ?? undefined,
        generations: generationsRef.current,
      }),
    });
  }, [selectedContentId, updateProvider]);

  const contextValue = useMemo(() => ({
    subActions,
    selectedContentId,
    onSelectContent: setSelectedContentId,
    registerGeneration,
    readonly: isReadonly,
    disabled: disabled || isReadonly,
  }), [subActions, selectedContentId, registerGeneration, isReadonly, disabled]);

  return (
    <MediaGenerationProvider value={contextValue}>
      <SchemaRenderer data={data} schema={schema} path={[]} />
    </MediaGenerationProvider>
  );
}
```

~80 lines instead of 553.

### ImageGeneration (Self-Contained)

```tsx
export function ImageGeneration({ data, schema, path, ux }: Props) {
  const { subActions, selectedContentId, onSelectContent, registerGeneration, readonly, disabled }
    = useMediaGeneration();
  const inputContext = useInputSchemaOptional();
  const workflowRunId = useWorkflowStore(s => s.workflowRunId);

  // LOCAL state - not shared
  const [generations, setGenerations] = useState<GenerationResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState<ProgressState | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<PreviewInfo | null>(null);

  const provider = ux.provider;
  const promptId = ux.prompt_id || "default";

  // Load existing generations on mount
  useEffect(() => {
    if (!workflowRunId || readonly) return;
    api.getInteractionGenerations(workflowRunId, interactionId, "image")
      .then(response => {
        const myGenerations = response.generations.filter(
          g => g.provider === provider && g.prompt_id === promptId
        );
        setGenerations(myGenerations.map(g => ({
          urls: g.urls.map(toMediaUrl),
          metadata_id: g.metadata_id,
          content_ids: g.content_ids,
        })));
      });
  }, [workflowRunId, readonly, provider, promptId]);

  // Execute generation
  const handleGenerate = async (action: SubActionConfig) => {
    const params = inputContext?.getMappedValues() || {};

    setLoading(true);
    setProgress({ elapsed_ms: 0, message: "Starting..." });
    setError(null);

    api.streamSubAction(
      { workflowRunId, interactionId, provider, action_type: action.action_type, prompt_id: promptId, params },
      (eventType, eventData) => {
        if (eventType === "progress") {
          setProgress({ elapsed_ms: eventData.elapsed_ms, message: eventData.message });
        } else if (eventType === "complete") {
          const result = {
            urls: eventData.urls.map(toMediaUrl),
            metadata_id: eventData.metadata_id,
            content_ids: eventData.content_ids,
          };
          setGenerations(prev => [...prev, result]);
          registerGeneration(pathToKey(path), result);  // Report to parent
          setLoading(false);
          setProgress(null);
        } else if (eventType === "error") {
          setError(eventData.message);
          setLoading(false);
          setProgress(null);
        }
      },
      (err) => {
        setError(err.message);
        setLoading(false);
        setProgress(null);
      }
    );
  };

  // Fetch preview on param change
  useEffect(() => {
    if (readonly || !workflowRunId) return;
    const params = inputContext?.values || {};
    api.getMediaPreview(workflowRunId, { provider, action_type: "txt2img", params })
      .then(setPreview)
      .catch(() => {});
  }, [inputContext?.values, readonly, workflowRunId, provider]);

  return (
    <div className="rounded-lg border bg-card overflow-hidden shadow-sm">
      <div className="px-4 py-2.5 bg-muted/50 border-b">
        <span className="font-medium text-sm">{ux.display_label}</span>
      </div>
      <div className="p-4 space-y-4">
        {preview && <PreviewInfo preview={preview} />}
        <ActionButtons actions={subActions} onGenerate={handleGenerate} loading={loading} />
        {error && <div className="text-destructive">{error}</div>}
        {loading && progress && <ProgressDisplay progress={progress} />}
        {generations.length > 0 && (
          <MediaGrid
            generations={generations}
            selectedContentId={selectedContentId}
            onSelect={onSelectContent}
          />
        )}
      </div>
    </div>
  );
}
```

### VideoGeneration (Self-Contained + Crop)

Same as ImageGeneration, plus:
- `savedCrop` state (local, not shared)
- `showCropModal` state
- CropSelectionModal rendering
- Source image handling

## Bracket Syntax Design

### Syntax

```
tab.media[input_schema,image_generation]
```

Parsed as:
- Compound parts before `[`: `tab.media` (process as before)
- Bracket content: siblings to render at leaf level

### SchemaRenderer Flow

```typescript
// In SchemaRenderer

// 1. Check for bracket syntax
<!--
I think we need to be smarter that this. right now we split and take left and
right, but now it should be like

if (ux.render_as.includes(".") {
    const parts = ux.render_as.split(".")
    
    const nested = parts.reduceRight(
        (children, part) => return <SchemaRenderer render_as="part">{children}</SchemaRenderer>
    )
}

if (ux.render_as.includes("[") {
    const siblings = ux.render_as(remove brackets).split(",")
    return <SchemaRenderer render_as="{cleaned node}">
                siblings.forEach((sib) => {
                    if (sib === "input_schema") {
                        <InputSchemaComposer ... />
                    } else {
                        <SchemaRenderer render_as=sib />
                    }
                })
           </SchemaRenderer>
}

let me know if this make sense, be critial
-->

if (ux.render_as?.includes("[")) {
  const bracketStart = ux.render_as.indexOf("[");
  const bracketEnd = ux.render_as.indexOf("]");

  const compoundPart = ux.render_as.slice(0, bracketStart); // "tab.media"
  const siblingParts = ux.render_as
    .slice(bracketStart + 1, bracketEnd)
    .split(","); // ["input_schema", "image_generation"]

  // Process compound part normally, but with siblings as children
  return (
    <SchemaRenderer
      ux={{ ...ux, render_as: compoundPart }}
    >
      {siblingParts.map(part => renderSibling(part, ux))}
    </SchemaRenderer>
  );
}

function renderSibling(part: string, ux: UxConfig) {
  if (part === "input_schema") {
    // Requires InputSchemaContext to exist (provided by InputSchemaComposer)
    return <InputSchemaRenderer schema={ux.input_schema} data={data} path={path} />;
  }
  return <SchemaRenderer ux={{ ...ux, render_as: part }} />;
}
```

### InputSchemaComposer (Simplified)

```tsx
export function InputSchemaComposer({ data, schema, path, ux, children }) {
  // Create context value...

  // Just provide context, render children
  return (
    <InputSchemaContext.Provider value={contextValue}>
      <!--is children=input_schema render?-->
      {children}
    </InputSchemaContext.Provider>
  );
}
```

Wait - this doesn't work because InputSchemaComposer is called BY SchemaRenderer.

Let me reconsider...

### Revised Flow

When SchemaRenderer sees `input_schema` in ux config:

```typescript
// SchemaRenderer
if (ux.input_schema) {
  // Wrap in InputSchemaContext, then continue processing
  return (
    <InputSchemaContextProvider ux={ux} data={data} path={path}>
      <SchemaRenderer
        ux={{ ...ux, input_schema: undefined }}  // Prevent loop
        // ... rest of props
      />
    </InputSchemaContextProvider>
  );
}
```

Then bracket syntax renders `input_schema` keyword using the context:

```typescript
if (part === "input_schema") {
  // Context already provided above
  const inputSchema = ux.input_schema;
  return <InputSchemaRenderer schema={inputSchema} data={data} path={path} />;
}
```

## Implementation Plan

### Phase 1: Simplify MediaGeneration

1. Remove centralized state (generations, loading, progress, error, preview)
2. Keep only: selectedContentId, subActions, registerGeneration
3. Remove task reconnection logic
4. ~80 lines instead of 553

### Phase 2: Implement Bracket Syntax

1. Add bracket parsing to SchemaRenderer
2. Handle `input_schema` keyword
3. Adjust InputSchemaComposer to just provide context

### Phase 3: Create ImageGeneration

1. Self-contained state management
2. Own API calls (SSE streaming, preview)
3. Own UI (chrome, buttons, grid)
4. Register generations with parent

### Phase 4: Create VideoGeneration

1. Same as ImageGeneration
2. Plus crop modal state and handling
3. Plus source image handling

### Phase 5: Update MediaWrapper (render_as="media")

Simple wrapper for card chrome:
```tsx
function MediaWrapper({ children, ux }) {
  return (
    <div className="rounded-lg border bg-card">
      <div className="px-4 py-2.5 bg-muted/50 border-b">
        {ux.display_label}
      </div>
      <div className="p-4">{children}</div>
    </div>
  );
}
```

### Phase 6: Update Workflow Schemas

```diff
- "render_as": "tab.media"
+ "render_as": "tab.media[input_schema,image_generation]"
```

### Phase 7: Remove Old Code

- Remove MediaPanel.tsx
- Clean up unused context fields

## Questions for Review

1. **registerGeneration pattern**: Is callback registration the right
   way for children to report generations to parent for response?

2. **Bracket syntax position**: Should bracket be at end only?
   - `tab.media[input_schema,image_generation]` (end)
   - vs `tab[media,input_schema].image_generation` (middle - confusing)

3. **Load existing generations**: Each ImageGeneration/VideoGeneration
   loads its own. Should they filter by provider/prompt_id, or should
   MediaGeneration pre-load and pass down?
