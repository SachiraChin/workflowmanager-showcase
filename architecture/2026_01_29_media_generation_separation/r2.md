# Media Generation Separation: Image vs Video (R2)

## Summary

Refactor the media-generation components to separate image generation
(`txt2img`, `img2img`) from video generation (`img2vid`) into distinct
components. Currently, `MediaPanel` handles both with conditional logic
based on `action_type`. This refactor introduces `ImageGeneration` and
`VideoGeneration` as separate components.

## Current Architecture

### Full Component Hierarchy

```
InteractionHost
└── case "media_generation":
    └── MediaGeneration.tsx (lines 540-552)
        ├── MediaGenerationProvider (provides MediaGenerationContext)
        │   - generations state, loading/progress/error state
        │   - selectedContentId, executeSubAction()
        │   - crop state (savedCrop, setSavedCrop, clearSavedCrop)
        └── SchemaRenderer(data, schema from display_data)
            └── ... schema-driven routing
```

**Key insight**: `MediaGeneration` is NOT routed via `render_as`. It's
the **interaction type handler** rendered by `InteractionHost` when
`interaction_type === "media_generation"`. The backend module
`media.generate` sets this interaction type.

### render_as Flow for `tab.media` with `input_schema`

```
SchemaRenderer(render_as="tab.media", input_schema={...})
│
├─► input_schema detected (line 108)
│   └─► delegates to InputSchemaComposer
│
InputSchemaComposer:
├── Creates InputSchemaContext (values, errors, getMappedValues)
├── Creates inputComponent = <InputSchemaRenderer ... />
<!--following is wrong, input schema renderer should not have done this. this 
is logic of SchemaRenderer#121-145. we need to fix this in this session-->
├── Compound split (lines 193-220):
│   │   outer="tab", inner="media"
│   └── Returns:
│       <InputSchemaContext.Provider>
│         <SchemaRenderer render_as="tab">     ← routes to TabLayout
│           <div className="space-y-4">
│             {inputComponent}                  ← InputSchemaRenderer
│             <SchemaRenderer render_as="media"/> ← routes to MediaPanel
│           </div>
│         </SchemaRenderer>
│       </InputSchemaContext.Provider>
│
SchemaRenderer(render_as="tab") → TabLayout (wraps children)
│
SchemaRenderer(render_as="media") → MediaPanel (leaf, line 189-198)
```

### Key Files and Responsibilities

| File | Responsibility |
|------|----------------|
| `MediaGeneration.tsx` | **Interaction handler**. Provides MediaGenerationContext, manages state (generations, loading, errors, crop), handles SSE streaming, calls SchemaRenderer |
| `MediaGenerationContext.tsx` | Context definition: subActions, getGenerations, isLoading, executeSubAction, savedCrop, etc. |
| `MediaPanel.tsx` | **Leaf renderer** for `render_as="media"`. Uses both contexts, renders action buttons, preview info, validation, crop modal, MediaGrid |
| `MediaGrid.tsx` | Displays generated images/videos with selection (handles both types) |
| `CropSelectionModal.tsx` | Crop region selection modal (video only) |
| `InputSchemaComposer.tsx` | Handles input_schema, provides InputSchemaContext, does compound split |
| `InputSchemaRenderer.tsx` | Renders the actual input fields from input_schema |

### What MediaPanel Actually Does

MediaPanel (lines 47-409) does the following:

1. **Accesses contexts**:
   - `useMediaGeneration()` - generations, loading, executeSubAction, crop
   - `useInputSchemaOptional()` - input values for generation params

2. **Extracts UX config**: provider, prompt_id, input_schema properties

3. **Preview fetching**: Calls `fetchPreview()` on param changes (debounced)

4. **Renders UI**:
   - Header from `display_label`
   - Preview info (resolution, credits, crop info)
   - Action buttons (from subActions)
   - Validation errors
   - Progress indicator
   - Error display
   - MediaGrid for generated content
   - CropSelectionModal (conditionally for img2vid)

5. **Handles generation**:
   - `handleGenerate()` - validates, shows crop modal for video, calls
     `executeSubAction()`
   - `executeWithCrop()` - adds source_image and crop_region for video

### Problem: Mixed Concerns

MediaPanel has conditional logic for video:

```typescript
// Line 169: Add source_image for video
if (action.action_type === "img2vid" && sourceImageData) {
  finalParams.source_image = sourceImageData;
}

// Line 247: Show crop modal for video
if (action.action_type === "img2vid" && sourceImageData?.url) {
  if (savedCrop) { ... } else { /* show modal */ }
}

// Line 392-406: Render CropSelectionModal (only for video)
{sourceImageData?.url && (
  <CropSelectionModal ... />
)}
```

## Proposed Architecture

### New Hierarchy

```
InteractionHost
<!-- I dont see your research on MediaGeneration.tsx where is in in whole picture. i dont see it in 35-49 lines of this doc, and i dont see "media_generation" in workflows. so, agai, where does it used?
└── MediaGeneration.tsx (UNCHANGED)
    ├── MediaGenerationProvider (UNCHANGED)
    └── SchemaRenderer
        └── tabs
            └── tab.media.image_generation (3-level)
            │   └── TabLayout
            │       └── MediaWrapper (new, render_as="media")
            │           └── ImageGeneration (new)
            │
            └── tab.media.video_generation (3-level)
                └── TabLayout
                    └── MediaWrapper (new, render_as="media")
                        └── VideoGeneration (new)
```

### 3-Level Compound Flow

For `render_as="tab.media.image_generation"` with `input_schema`:

```
InputSchemaComposer:
├── Compound split: outer="tab", inner="media.image_generation"
└── <InputSchemaContext.Provider>
      <SchemaRenderer render_as="tab">
        <div>
          <InputSchemaRenderer />
          <SchemaRenderer render_as="media.image_generation" />
        </div>
      </SchemaRenderer>
    </InputSchemaContext.Provider>

SchemaRenderer(render_as="tab") → TabLayout

SchemaRenderer(render_as="media.image_generation")
├── Compound split: outer="media", inner="image_generation"
└── <SchemaRenderer render_as="media">
      <SchemaRenderer render_as="image_generation" />
    </SchemaRenderer>

SchemaRenderer(render_as="media") → MediaWrapper (accepts children)

SchemaRenderer(render_as="image_generation") → ImageGeneration
```

### What Goes Where

| Component | Responsibilities |
|-----------|------------------|
| `MediaGeneration` | UNCHANGED - interaction handler, context provider |
| `MediaWrapper` | NEW - shared chrome/wrapper for `render_as="media"`, renders children |
| `ImageGeneration` | NEW - preview info, action buttons, validation, MediaGrid (no crop) |
| `VideoGeneration` | NEW - preview info, action buttons, validation, crop modal, MediaGrid |
| `MediaPanel` | REMOVED after refactor |

<!--why does MediaWrapper needed when MediaPanel is there as a wrapper already?-->
### What MediaWrapper Should Do

Since InputSchemaComposer already handles:
- InputSchemaContext
- Input field rendering

And MediaGeneration already handles:
- MediaGenerationContext
- State management

MediaWrapper only needs to provide **shared UI chrome**:

```tsx
// render_as="media" with children
function MediaWrapper({ children, ux }: Props) {
  const header = ux.display_label || "Media Generation";

  return (
    <div className="rounded-lg border bg-card overflow-hidden shadow-sm">
      <div className="px-4 py-2.5 bg-muted/50 border-b">
        <span className="font-medium text-sm">{header}</span>
      </div>
      <div className="p-4 space-y-4">
        {children}
      </div>
    </div>
  );
}
```

This extracts the card/panel styling that's currently in MediaPanel.

## New Component Specifications

### ImageGeneration

```tsx
function ImageGeneration({ data, schema, path, ux }: Props) {
  const mediaContext = useMediaGeneration();
  const inputContext = useInputSchemaOptional();

  // From mediaContext:
  // - subActions, getGenerations, isLoading, getProgress, getError
  // - selectedContentId, onSelectContent, executeSubAction
  // - getPreview, isPreviewLoading, fetchPreview

  // From inputContext:
  // - values, getMappedValues, setError, clearAllErrors

  // Renders:
  // - Preview info (resolution, credits)
  // - Action buttons (subActions where action_type != "img2vid")
  // - Validation errors
  // - Progress/error display
  // - MediaGrid
}
```

### VideoGeneration

```tsx
function VideoGeneration({ data, schema, path, ux }: Props) {
  const mediaContext = useMediaGeneration();
  const inputContext = useInputSchemaOptional();

  // Additional from mediaContext:
  // - savedCrop, setSavedCrop, clearSavedCrop
  // - getDataAtPath (for _source_image)

  // Local state:
  // - showCropModal, cropModalViewOnly
  // - pendingAction, pendingParams

  // Renders:
  // - Preview info (resolution, credits, crop info)
  // - Action buttons (subActions where action_type == "img2vid")
  // - Validation errors
  // - Progress/error display
  // - MediaGrid
  // - CropSelectionModal
}
```

## Implementation Plan

### Phase 1: Add New render_as Types

In `schema/types.ts`:
```typescript
export type SpecialRendererType =
  | "content-panel"
  | "table"
  | "media"              // becomes wrapper
  | "image_generation"   // new
  | "video_generation";  // new
```

### Phase 2: Create MediaWrapper

New file or modify existing to handle `render_as="media"` with children:
- Extract card chrome from MediaPanel
- Render children inside

### Phase 3: Create ImageGeneration

Extract from MediaPanel:
- Preview display logic
- Action button rendering (filter to non-img2vid)
- Validation logic
- Progress/error display
- MediaGrid rendering

### Phase 4: Create VideoGeneration

Extract from MediaPanel:
- All of ImageGeneration logic, plus:
- Crop modal state and handlers
- Source image handling
- Crop info display
- CropSelectionModal rendering

### Phase 5: Update SchemaRenderer

```typescript
if (ux.render_as === "media") {
  return (
    <MediaWrapper data={data} schema={schema} path={path} ux={ux}>
      {children}
    </MediaWrapper>
  );
}

if (ux.render_as === "image_generation") {
  return <ImageGeneration data={data} schema={schema} path={path} ux={ux} />;
}

if (ux.render_as === "video_generation") {
  return <VideoGeneration data={data} schema={schema} path={path} ux={ux} />;
}
```

### Phase 6: Update Workflow Schemas

`cc_image_prompts_display_schema.json`:
```diff
- "render_as": "tab.media"
+ "render_as": "tab.media.image_generation"
```

`cc_video_generation_display_schema.json`:
```diff
- "render_as": "tab.media"
+ "render_as": "tab.media.video_generation"
```

### Phase 7: Remove MediaPanel

After verification, remove `MediaPanel.tsx`.

## Questions for Review

1. **MediaWrapper content**: Is the shared chrome (card border, header,
   padding) the right thing to extract? Or should ImageGeneration and
   VideoGeneration each render their own chrome?

2. **Action type filtering**: Should ImageGeneration filter out img2vid
   actions, or should the workflow schemas only provide appropriate
   actions per component? (I lean toward schema responsibility)

3. **File organization**: Suggested structure:
   ```
   media-generation/
   ├── MediaGeneration.tsx      (unchanged)
   ├── MediaGenerationContext.tsx (unchanged)
   ├── MediaWrapper.tsx         (new)
   ├── ImageGeneration.tsx      (new)
   ├── VideoGeneration.tsx      (new)
   ├── MediaGrid.tsx            (unchanged)
   ├── CropSelectionModal.tsx   (unchanged)
   ├── types.ts                 (unchanged)
   └── index.ts                 (update exports)
   ```
