# Media Generation Separation: Image vs Video (R6)

## Summary

Refactor media-generation with decentralized state and new bracket syntax
for compound render_as parsing.

## Decisions

- Rename `MediaGeneration` → `MediaGenerationHost`
- Decentralize state to ImageGeneration/VideoGeneration
- New bracket syntax: `tab.media[input_schema,image_generation]`

## Critical Analysis of Proposed Parsing

### Your Proposal

```typescript
// For dots
if (ux.render_as.includes(".")) {
    const parts = ux.render_as.split(".")
    const nested = parts.reduceRight(
        (children, part) => <SchemaRenderer render_as={part}>{children}</SchemaRenderer>
    )
}

// For brackets
if (ux.render_as.includes("[")) {
    const siblings = ux.render_as(remove brackets).split(",")
    return <SchemaRenderer render_as="{cleaned node}">
        siblings.forEach((sib) => {
            if (sib === "input_schema") {
                <InputSchemaComposer ... />
            } else {
                <SchemaRenderer render_as={sib} />
            }
        })
    </SchemaRenderer>
}
```

### Issues I See

**Issue 1: Order of operations**

If we check dots first, `tab.media[input_schema,image_generation]` would
split into `["tab", "media[input_schema", "image_generation]"]` which is
wrong.

**Fix**: Check brackets FIRST, extract and clean, then process dots.

**Issue 2: InputSchemaComposer vs InputSchemaRenderer**

Your pseudo-code shows `InputSchemaComposer` as a sibling. But:

- `InputSchemaComposer` = context provider + state management
- `InputSchemaRenderer` = renders the actual input fields

The context must WRAP both the inputs AND the components that use them
(ImageGeneration uses `useInputSchemaOptional()` to get values).

So `input_schema` sibling should render `InputSchemaRenderer`, but the
entire siblings block needs to be wrapped in `InputSchemaContext`.

**Issue 3: Where does context provider go?**

Current flow:
```
SchemaRenderer sees input_schema in ux → calls InputSchemaComposer
InputSchemaComposer → provides context + renders inputs + calls SchemaRenderer for inner
```

With bracket syntax, we want:
```
SchemaRenderer parses brackets → wraps siblings in context → renders each sibling
```

## Revised Parsing Design

### Step 1: Parse Brackets First

```typescript
function parseRenderAs(renderAs: string): {
  compoundParts: string[];      // ["tab", "media"]
  siblings: string[] | null;    // ["input_schema", "image_generation"] or null
} {
  if (!renderAs.includes("[")) {
    return {
      compoundParts: renderAs.split("."),
      siblings: null
    };
  }

  const bracketStart = renderAs.indexOf("[");
  const bracketEnd = renderAs.indexOf("]");

  const compoundPart = renderAs.slice(0, bracketStart);  // "tab.media"
  const siblingsStr = renderAs.slice(bracketStart + 1, bracketEnd);  // "input_schema,image_generation"

  return {
    compoundParts: compoundPart ? compoundPart.split(".") : [],
    siblings: siblingsStr.split(",").map(s => s.trim())
  };
}
```

Example: `tab.media[input_schema,image_generation]`
- compoundParts: `["tab", "media"]`
- siblings: `["input_schema", "image_generation"]`

### Step 2: Build Nested Structure

```typescript
function buildNestedRenderers(
  parts: string[],
  leafContent: ReactNode,
  ux: UxConfig,
  data: unknown,
  schema: SchemaProperty,
  path: string[]
): ReactNode {
  if (parts.length === 0) {
    return leafContent;
  }

  // reduceRight: innermost first, outermost last
  return parts.reduceRight(
    (children, part) => (
      <SchemaRenderer
        data={data}
        schema={schema}
        path={path}
        ux={{ ...ux, render_as: part as RenderAs }}
      >
        {children}
      </SchemaRenderer>
    ),
    leafContent
  );
}
```

### Step 3: Handle Siblings with Context

```typescript
function renderSiblings(
  siblings: string[],
  ux: UxConfig,
  data: unknown,
  schema: SchemaProperty,
  path: string[]
): ReactNode {
  const hasInputSchema = siblings.includes("input_schema");

  const siblingElements = (
    <div className="space-y-4">
      {siblings.map((sib, idx) => {
        if (sib === "input_schema") {
          // Render the input fields (context already provided)
          return (
            <InputSchemaRenderer
              key={idx}
              schema={ux.input_schema}
              data={data as Record<string, unknown>}
              path={[...path, "_inputs"]}
            />
          );
        }
        // Render other siblings
        return (
          <SchemaRenderer
            key={idx}
            data={data}
            schema={schema}
            path={path}
            ux={{ ...ux, render_as: sib as RenderAs, input_schema: undefined }}
          />
        );
      })}
    </div>
  );

  // If input_schema is present, wrap in context provider
  if (hasInputSchema && ux.input_schema) {
    return (
      <InputSchemaContextProvider
        inputSchema={ux.input_schema}
        data={data as Record<string, unknown>}
      >
        {siblingElements}
      </InputSchemaContextProvider>
    );
  }

  return siblingElements;
}
```

### Step 4: Main Parsing in SchemaRenderer

```typescript
// In SchemaRenderer, early in the function:

const { compoundParts, siblings } = parseRenderAs(ux.render_as);

if (siblings !== null) {
  // Has bracket syntax
  const leafContent = renderSiblings(siblings, ux, data, schema, path);
  return buildNestedRenderers(compoundParts, leafContent, ux, data, schema, path);
}

if (compoundParts.length > 1) {
  // Simple dot syntax (no brackets)
  // Last part is the leaf, rest are wrappers
  const leafPart = compoundParts[compoundParts.length - 1];
  const wrapperParts = compoundParts.slice(0, -1);

  const leafContent = (
    <SchemaRenderer
      data={data}
      schema={schema}
      path={path}
      ux={{ ...ux, render_as: leafPart as RenderAs }}
    />
  );

  return buildNestedRenderers(wrapperParts, leafContent, ux, data, schema, path);
}

// Single render_as value - continue to existing routing logic
```

## Complete Flow Example

For `tab.media[input_schema,image_generation]` with `input_schema` in ux:

```
1. parseRenderAs("tab.media[input_schema,image_generation]")
   → compoundParts: ["tab", "media"]
   → siblings: ["input_schema", "image_generation"]

2. renderSiblings(["input_schema", "image_generation"], ux, ...)
   → hasInputSchema = true
   → Returns:
     <InputSchemaContextProvider>
       <div className="space-y-4">
         <InputSchemaRenderer />           // input_schema
         <SchemaRenderer render_as="image_generation" />
       </div>
     </InputSchemaContextProvider>

3. buildNestedRenderers(["tab", "media"], leafContent, ...)
   → reduceRight builds:
     <SchemaRenderer render_as="tab">      // → TabLayout
       <SchemaRenderer render_as="media">  // → MediaWrapper
         {leafContent}                     // from step 2
       </SchemaRenderer>
     </SchemaRenderer>

4. Final structure:
   <TabLayout>
     <MediaWrapper>
       <InputSchemaContextProvider>
         <div>
           <InputSchemaRenderer />
           <ImageGeneration />
         </div>
       </InputSchemaContextProvider>
     </MediaWrapper>
   </TabLayout>
```

## InputSchemaComposer Answer

> Is `children` = input_schema render?

No. With the new design:

- `InputSchemaComposer` is **removed** (or becomes just a thin context provider)
- `InputSchemaContextProvider` = provides context only (state management)
- `InputSchemaRenderer` = renders the input fields
- They are separate concerns

The bracket syntax tells us:
1. THAT we need inputs (presence of `input_schema` sibling)
2. WHERE to render them (sibling position)
3. Context wraps all siblings automatically

## InputSchemaContextProvider (New)

```tsx
interface InputSchemaContextProviderProps {
  inputSchema: InputSchemaConfig;
  data: Record<string, unknown>;
  children: ReactNode;
}

export function InputSchemaContextProvider({
  inputSchema,
  data,
  children
}: InputSchemaContextProviderProps) {
  // All the state management from current InputSchemaComposer
  const [values, setValues] = useState<Record<string, unknown>>(() => {
    // Initialize from data and schema defaults
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  // ... rest of state

  const contextValue = useMemo(() => ({
    values,
    getValue: (key) => values[key],
    setValue: (key, value) => { /* ... */ },
    getMappedValues: () => { /* ... */ },
    errors,
    setError: (key, error) => { /* ... */ },
    // ... rest
  }), [values, errors, /* ... */]);

  return (
    <InputSchemaContext.Provider value={contextValue}>
      {children}
    </InputSchemaContext.Provider>
  );
}
```

## Files to Change

| File | Change |
|------|--------|
| `SchemaRenderer.tsx` | Add bracket parsing, use reduceRight for dots |
| `InputSchemaComposer.tsx` | Remove or rename to `InputSchemaContextProvider` |
| `InputSchemaRenderer.tsx` | No change (already just renders inputs) |
| `MediaGeneration.tsx` | Rename to `MediaGenerationHost`, simplify |
| `ImageGeneration.tsx` | NEW |
| `VideoGeneration.tsx` | NEW |
| `MediaWrapper.tsx` | NEW (or repurpose MediaPanel) |
| Workflow schemas | Update render_as values |

## Questions

1. Does the parsing flow make sense now?

2. Should `InputSchemaContextProvider` be in same file as
   `InputSchemaContext`, or separate?

3. Edge case: What if bracket has nested dots?
   `tab.media[input_schema,foo.bar]`
   - Should `foo.bar` be processed as compound inside siblings?
   - Or disallow dots inside brackets?
