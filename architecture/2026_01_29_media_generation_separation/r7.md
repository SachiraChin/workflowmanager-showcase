# Media Generation Separation: Image vs Video (R7)

## Summary

Refactor media-generation to separate image/video generation AND
decentralize state management. Each generation component manages its own
state instead of centralized path-keyed maps.

## Decisions

- Rename `MediaGeneration` → `MediaGenerationHost` (simplified coordinator)
- Decentralize state to `ImageGeneration` / `VideoGeneration`
- Bracket syntax: `tab.media[input_schema,image_generation]`
- Remove task reconnection (not working, clean up later)

## Parsing Logic

### Order of Operations

1. **Dots first**: Split by "." to get hierarchy
2. **Brackets per-node**: Each node may have brackets defining its children

### Example: `tab.media[input_schema,image_generation]`

```
Step 1: Split by "."
  → ["tab", "media[input_schema,image_generation]"]

Step 2: reduceRight builds nesting
  → <SchemaRenderer render_as="tab">
      <SchemaRenderer render_as="media[input_schema,image_generation]">
      </SchemaRenderer>
    </SchemaRenderer>

Step 3: When rendering "media[input_schema,image_generation]"
  → cleaned node = "media"
  → siblings = ["input_schema", "image_generation"]
  → Check if "input_schema" in siblings → YES
  → Wrap other siblings in InputSchemaComposer
```

### Pseudo-code

```typescript
// In SchemaRenderer

// Step 1: Handle dots - split hierarchy
if (ux.render_as.includes(".")) {
  const parts = ux.render_as.split(".");

  return parts.reduceRight(
    (children, part) => (
      <SchemaRenderer
        data={data}
        schema={schema}
        path={path}
        ux={{ ...ux, render_as: part }}
      >
        {children}
      </SchemaRenderer>
    )
  );
}

// Step 2: Handle brackets - per-node children
if (ux.render_as.includes("[")) {
  const bracketStart = ux.render_as.indexOf("[");
  const bracketEnd = ux.render_as.indexOf("]");

  const cleanedNode = ux.render_as.slice(0, bracketStart);  // "media"
  const siblings = ux.render_as
    .slice(bracketStart + 1, bracketEnd)
    .split(",")
    .map(s => s.trim());  // ["input_schema", "image_generation"]

  // Build sibling elements (excluding input_schema)
  const otherSiblings = siblings
    .filter(sib => sib !== "input_schema")
    .map(sib => (
      <SchemaRenderer
        key={sib}
        data={data}
        schema={schema}
        path={path}
        ux={{ ...ux, render_as: sib, input_schema: undefined }}
      />
    ));

  // If input_schema is a sibling, wrap others in InputSchemaComposer
  if (siblings.includes("input_schema")) {
    return (
      <SchemaRenderer
        data={data}
        schema={schema}
        path={path}
        ux={{ ...ux, render_as: cleanedNode, input_schema: undefined }}
      >
        <InputSchemaComposer ux={ux} data={data} path={path}>
          {otherSiblings}
        </InputSchemaComposer>
      </SchemaRenderer>
    );
  }

  // No input_schema - just render siblings
  return (
    <SchemaRenderer
      data={data}
      schema={schema}
      path={path}
      ux={{ ...ux, render_as: cleanedNode }}
    >
      {otherSiblings}
    </SchemaRenderer>
  );
}

// Step 3: No dots, no brackets → existing routing logic
switch (ux.render_as) {
  case "tab": return <TabLayout ux={ux}>{children}</TabLayout>;
  case "media": return <Media ux={ux}>{children}</Media>;
  case "image_generation": return <ImageGeneration ... />;
  case "video_generation": return <VideoGeneration ... />;
  // ... etc
}
```

## Component Design

### MediaGenerationHost (Simplified Coordinator)

Renamed from MediaGeneration. Only manages truly shared state.

```tsx
export function MediaGenerationHost() {
  const { request, disabled, updateProvider, mode } = useInteraction();
  const isReadonly = mode.type === "readonly";

  const displayData = request.display_data || {};
  const data = displayData.data;
  const schema = displayData.schema;
  const subActions = displayData.sub_actions || [];

  // ONLY shared state - selection across all tabs
  const [selectedContentId, setSelectedContentId] = useState<string | null>(
    null
  );

  // Track generations from children for response
  const generationsRef = useRef<Record<string, GenerationResult[]>>({});

  const registerGeneration = useCallback(
    (path: string, result: GenerationResult) => {
      generationsRef.current[path] = [
        ...(generationsRef.current[path] || []),
        result,
      ];
    },
    []
  );

  // InteractionHost integration
  useEffect(() => {
    updateProvider({
      getState: () => ({
        isValid: selectedContentId !== null,
        selectedCount: selectedContentId ? 1 : 0,
        selectedGroupIds: [],
      }),
      getResponse: () => ({
        selected_content_id: selectedContentId ?? undefined,
        generations: generationsRef.current,
      }),
    });
  }, [selectedContentId, updateProvider]);

  const contextValue = useMemo(
    () => ({
      subActions,
      selectedContentId,
      onSelectContent: setSelectedContentId,
      registerGeneration,
      readonly: isReadonly,
      disabled: disabled || isReadonly,
    }),
    [subActions, selectedContentId, registerGeneration, isReadonly, disabled]
  );

  return (
    <MediaGenerationProvider value={contextValue}>
      <SchemaRenderer data={data} schema={schema} path={[]} />
    </MediaGenerationProvider>
  );
}
```

~80 lines instead of 553. Removed:
- Centralized generations/loading/progress/error/preview maps
- Task reconnection logic
- Path-keyed complexity

### ImageGeneration (Self-Contained)

Each instance manages its own state.

```tsx
interface ImageGenerationProps {
  data: unknown;
  schema: SchemaProperty;
  path: string[];
  ux: UxConfig;
}

export function ImageGeneration({ data, schema, path, ux }: Props) {
  const {
    subActions,
    selectedContentId,
    onSelectContent,
    registerGeneration,
    readonly,
    disabled,
  } = useMediaGeneration();

  const inputContext = useInputSchemaOptional();
  const workflowRunId = useWorkflowStore((s) => s.workflowRunId);

  // LOCAL state - each instance has its own
  const [generations, setGenerations] = useState<GenerationResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState<ProgressState | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<PreviewInfo | null>(null);

  const provider = ux.provider;
  const promptId = ux.prompt_id || "default";

  // Load existing generations on mount
  useEffect(() => {
    if (!workflowRunId || readonly) return;

    api
      .getInteractionGenerations(workflowRunId, interactionId, "image")
      .then((response) => {
        const myGenerations = response.generations.filter(
          (g) => g.provider === provider && g.prompt_id === promptId
        );
        setGenerations(
          myGenerations.map((g) => ({
            urls: g.urls.map(toMediaUrl),
            metadata_id: g.metadata_id,
            content_ids: g.content_ids,
          }))
        );
      });
  }, [workflowRunId, readonly, provider, promptId]);

  // Execute generation via SSE
  const handleGenerate = async (action: SubActionConfig) => {
    const params = inputContext?.getMappedValues() || {};

    setLoading(true);
    setProgress({ elapsed_ms: 0, message: "Starting..." });
    setError(null);

    api.streamSubAction(
      {
        workflowRunId,
        interactionId,
        provider,
        action_type: action.action_type,
        prompt_id: promptId,
        params,
      },
      (eventType, eventData) => {
        if (eventType === "progress") {
          setProgress({
            elapsed_ms: eventData.elapsed_ms,
            message: eventData.message,
          });
        } else if (eventType === "complete") {
          const result = {
            urls: eventData.urls.map(toMediaUrl),
            metadata_id: eventData.metadata_id,
            content_ids: eventData.content_ids,
          };
          setGenerations((prev) => [...prev, result]);
          registerGeneration(pathToKey(path), result);
          setLoading(false);
          setProgress(null);
        } else if (eventType === "error") {
          setError(eventData.message);
          setLoading(false);
          setProgress(null);
        }
      },
      (err) => {
        setError(err.message);
        setLoading(false);
        setProgress(null);
      }
    );
  };

  // Fetch preview when params change
  useEffect(() => {
    if (readonly || !workflowRunId) return;

    const params = inputContext?.values || {};
    api
      .getMediaPreview(workflowRunId, {
        provider,
        action_type: "txt2img",
        params,
      })
      .then(setPreview)
      .catch(() => {});
  }, [inputContext?.values, readonly, workflowRunId, provider]);

  // Filter actions for image type
  const imageActions = subActions.filter((a) =>
    ["txt2img", "img2img"].includes(a.action_type)
  );

  return (
    <div className="space-y-4">
      {preview && <PreviewDisplay preview={preview} />}

      <ActionButtons
        actions={imageActions}
        onGenerate={handleGenerate}
        loading={loading}
        disabled={disabled}
      />

      {error && <div className="text-destructive text-sm">{error}</div>}

      {loading && progress && <ProgressDisplay progress={progress} />}

      {generations.length > 0 && (
        <MediaGrid
          generations={generations}
          selectedContentId={selectedContentId}
          onSelect={onSelectContent}
          mediaType="image"
        />
      )}
    </div>
  );
}
```

### VideoGeneration (Self-Contained + Crop)

Same as ImageGeneration, plus crop handling.

```tsx
export function VideoGeneration({ data, schema, path, ux }: Props) {
  const {
    subActions,
    selectedContentId,
    onSelectContent,
    registerGeneration,
    readonly,
    disabled,
  } = useMediaGeneration();

  const inputContext = useInputSchemaOptional();
  const workflowRunId = useWorkflowStore((s) => s.workflowRunId);

  // LOCAL state
  const [generations, setGenerations] = useState<GenerationResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState<ProgressState | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<PreviewInfo | null>(null);

  // Video-specific: crop state
  const [savedCrop, setSavedCrop] = useState<CropSelection | null>(null);
  const [showCropModal, setShowCropModal] = useState(false);
  const [sourceImage, setSourceImage] = useState<string | null>(null);

  const provider = ux.provider;
  const promptId = ux.prompt_id || "default";

  // Load existing generations on mount
  useEffect(() => {
    if (!workflowRunId || readonly) return;

    api
      .getInteractionGenerations(workflowRunId, interactionId, "video")
      .then((response) => {
        const myGenerations = response.generations.filter(
          (g) => g.provider === provider && g.prompt_id === promptId
        );
        setGenerations(
          myGenerations.map((g) => ({
            urls: g.urls.map(toMediaUrl),
            metadata_id: g.metadata_id,
            content_ids: g.content_ids,
          }))
        );
      });
  }, [workflowRunId, readonly, provider, promptId]);

  // Execute generation with crop params
  const handleGenerate = async (action: SubActionConfig) => {
    const params = {
      ...(inputContext?.getMappedValues() || {}),
      ...(savedCrop && { crop: savedCrop }),
    };

    setLoading(true);
    setProgress({ elapsed_ms: 0, message: "Starting..." });
    setError(null);

    api.streamSubAction(
      {
        workflowRunId,
        interactionId,
        provider,
        action_type: action.action_type,
        prompt_id: promptId,
        params,
      },
      (eventType, eventData) => {
        if (eventType === "progress") {
          setProgress({
            elapsed_ms: eventData.elapsed_ms,
            message: eventData.message,
          });
        } else if (eventType === "complete") {
          const result = {
            urls: eventData.urls.map(toMediaUrl),
            metadata_id: eventData.metadata_id,
            content_ids: eventData.content_ids,
          };
          setGenerations((prev) => [...prev, result]);
          registerGeneration(pathToKey(path), result);
          setLoading(false);
          setProgress(null);
        } else if (eventType === "error") {
          setError(eventData.message);
          setLoading(false);
          setProgress(null);
        }
      },
      (err) => {
        setError(err.message);
        setLoading(false);
        setProgress(null);
      }
    );
  };

  // Fetch preview and source image
  useEffect(() => {
    if (readonly || !workflowRunId) return;

    const params = inputContext?.values || {};
    api
      .getMediaPreview(workflowRunId, {
        provider,
        action_type: "img2vid",
        params,
        content_type: "image",
      })
      .then((result) => {
        setPreview(result);
        if (result.source_image_url) {
          setSourceImage(result.source_image_url);
        }
      })
      .catch(() => {});
  }, [inputContext?.values, readonly, workflowRunId, provider]);

  // Filter actions for video type
  const videoActions = subActions.filter((a) =>
    ["img2vid", "txt2vid"].includes(a.action_type)
  );

  return (
    <div className="space-y-4">
      {preview && <PreviewDisplay preview={preview} />}

      {sourceImage && (
        <CropSelector
          imageUrl={sourceImage}
          savedCrop={savedCrop}
          onOpenModal={() => setShowCropModal(true)}
        />
      )}

      <ActionButtons
        actions={videoActions}
        onGenerate={handleGenerate}
        loading={loading}
        disabled={disabled}
      />

      {error && <div className="text-destructive text-sm">{error}</div>}

      {loading && progress && <ProgressDisplay progress={progress} />}

      {generations.length > 0 && (
        <MediaGrid
          generations={generations}
          selectedContentId={selectedContentId}
          onSelect={onSelectContent}
          mediaType="video"
        />
      )}

      {showCropModal && sourceImage && (
        <CropSelectionModal
          imageUrl={sourceImage}
          initialCrop={savedCrop}
          onSave={(crop) => {
            setSavedCrop(crop);
            setShowCropModal(false);
          }}
          onClose={() => setShowCropModal(false)}
        />
      )}
    </div>
  );
}
```

### InputSchemaComposer (Updated)

Now accepts and renders children (other siblings).

```tsx
interface InputSchemaComposerProps {
  ux: UxConfig;
  data: Record<string, unknown>;
  path: string[];
  children?: ReactNode;  // Other siblings to render
}

export function InputSchemaComposer({
  ux,
  data,
  path,
  children,
}: InputSchemaComposerProps) {
  const inputSchema = ux.input_schema;

  // ... existing state management (values, errors, etc.) ...

  const contextValue = useMemo(
    () => ({
      values,
      getValue: (key: string) => values[key],
      setValue: (key: string, value: unknown) => {
        /* ... */
      },
      getMappedValues: () => {
        /* ... */
      },
      errors,
      setError: (key: string, error: string) => {
        /* ... */
      },
      schema: inputSchema,
    }),
    [values, errors, inputSchema]
  );

  return (
    <InputSchemaContext.Provider value={contextValue}>
      {/* Render the input fields */}
      <InputSchemaRenderer schema={inputSchema} data={data} path={path} />

      {/* Render other siblings (e.g., ImageGeneration) */}
      {children}
    </InputSchemaContext.Provider>
  );
}
```

### Media (render_as="media")

Card chrome wrapper, consistent with how TabLayout handles "tab".

```tsx
interface MediaProps {
  ux: UxConfig;
  children: ReactNode;
}

export function Media({ ux, children }: MediaProps) {
  return (
    <div className="rounded-lg border bg-card overflow-hidden shadow-sm">
      {ux?.display_label && (
        <div className="px-4 py-2.5 bg-muted/50 border-b">
          <span className="font-medium text-sm">{ux.display_label}</span>
        </div>
      )}
      <div className="p-4 space-y-4">{children}</div>
    </div>
  );
}
```

## Final Component Tree

For `tab.media[input_schema,image_generation]`:

```
<TabLayout>                              // render_as="tab"
  <Media>                                // render_as="media" (cleaned node)
    <InputSchemaComposer>                // wraps when input_schema present
      <InputSchemaRenderer />            // renders input fields
      <ImageGeneration />                // render_as="image_generation"
    </InputSchemaComposer>
  </Media>
</TabLayout>
```

For `tab.media[input_schema,video_generation]`:

```
<TabLayout>
  <Media>
    <InputSchemaComposer>
      <InputSchemaRenderer />
      <VideoGeneration />                // with crop modal
    </InputSchemaComposer>
  </Media>
</TabLayout>
```

## What's Shared vs Local

| State | Location | Reason |
|-------|----------|--------|
| selectedContentId | MediaGenerationHost | Global selection |
| subActions | MediaGenerationHost | Same for all tabs |
| readonly/disabled | MediaGenerationHost | Interaction-level |
| registerGeneration | MediaGenerationHost | Collect for response |
| generations | ImageGeneration/VideoGeneration | Per-component |
| loading/progress | ImageGeneration/VideoGeneration | Per-component |
| error | ImageGeneration/VideoGeneration | Per-component |
| preview | ImageGeneration/VideoGeneration | Per-component |
| savedCrop | VideoGeneration only | Video-specific |

## Implementation Plan

### Phase 1: Simplify MediaGeneration → MediaGenerationHost
- Remove centralized state maps
- Keep only: selectedContentId, subActions, registerGeneration
- Remove task reconnection logic
- ~80 lines instead of 553

### Phase 2: Add Bracket Parsing to SchemaRenderer
- Handle dots first (split hierarchy)
- Handle brackets per-node (extract siblings)
- Wrap in InputSchemaComposer when input_schema present

### Phase 3: Update InputSchemaComposer
- Accept children prop
- Render InputSchemaRenderer + children

### Phase 4: Create ImageGeneration
- Self-contained state
- Own API calls (SSE streaming, preview)
- Register generations with parent

### Phase 5: Create VideoGeneration
- Same as ImageGeneration
- Plus crop modal state/handling
- Plus source image handling

### Phase 6: Create Media Component
- Card chrome component for render_as="media"
- Consistent with TabLayout pattern

### Phase 7: Update Workflow Schemas
```diff
- "render_as": "tab.media"
+ "render_as": "tab.media[input_schema,image_generation]"
```

### Phase 8: Remove Old Code
- Remove MediaPanel.tsx (if unused)
- Clean up unused context fields

## Design Decisions (Confirmed)

1. **Parsing flow**: Confirmed correct - dots first, then brackets per-node

2. **Nested dots in brackets**: Disallowed - keep syntax simple
   - `[input_schema,image_generation]` ✓
   - `[input_schema,foo.bar]` ✗

3. **Backwards compatibility**: None required - focus only on proposed
   version, remove all legacy code paths
