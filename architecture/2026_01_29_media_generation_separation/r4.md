# Media Generation Separation: Image vs Video (R4)

## Summary

Refactor the media-generation components to separate image generation
from video generation. This includes:
1. Fix duplicate compound split logic in InputSchemaComposer
2. Implement new compound syntax for input_schema positioning
3. Create ImageGeneration and VideoGeneration components

## Decisions from Review

<!--correction here, I wanted to use A, not B-->
- **Option B confirmed**: 2-level (`tab.image_generation`), no MediaWrapper
- **Naming confirmed**: `ImageGeneration` / `VideoGeneration`
- **New syntax needed**: `tab[input_schema,image_generation]` for proper
  input_schema positioning

## MediaGeneration.tsx Analysis

### What It Does (NOT duplicated with MediaPanel)

MediaGeneration is the **interaction-level state manager**. It has no UI
rendering logic - that's all in MediaPanel.

| Responsibility | Lines | Description |
|----------------|-------|-------------|
| State: generations | 51 | `Record<string, GenerationResult[]>` keyed by prompt path |
| State: selection | 52 | `selectedContentId` |
| State: loading | 53-58 | `loadingPrompts`, `progressByPrompt`, `errorsByPrompt`, `tasksByPrompt` |
| State: preview | 60-62 | `previewByPrompt`, `previewLoadingPrompts` |
| State: crop | 64-66 | `savedCrop` (global for session) |
| API: load generations | 94-137 | Fetch existing generations on mount |
| API: reconnect tasks | 139-252 | Reconnect to in-progress SSE streams |
| API: executeSubAction | 285-420 | SSE streaming for new generations |
| API: fetchPreview | 422-460 | Get resolution/credit preview |
| InteractionHost | 254-282 | `updateProvider` for submission state |
| Context | 462-529 | Build and provide `MediaGenerationContextValue` |
| Render | 540-552 | Just wraps SchemaRenderer in context |

### Why It's Complex

1. **Multi-prompt state**: Each tab (midjourney, leonardo, etc.) has its
   own loading/progress/error/generations state, keyed by path string.
   <!--why does all these cramped inside one interaction host, all these are should be by its own. Why does MediaPanel cant handle them as MediaPanel does have context of each section.-->

2. **SSE streaming**: `executeSubAction` handles real-time progress
   updates, completion, and errors via Server-Sent Events.
   <!--again this is its own thing which could be handled in new components (ImageGeneration, VideoGeneration), there can be helper functions to share common logic, but i dont see why all of these are handled in single place.-->

3. **Task reconnection**: On page reload, reconnects to any in-progress
   generation tasks (lines 139-252). This is ~110 lines of reconnection
   logic.
   <!--if this is there, its not working. lets assume that we dont need this for now.-->

4. **Closure stability**: Uses refs (`generationsRef`, `selectedContentIdRef`)
   to ensure `updateProvider` callbacks have stable references.
   <!--isnt reference unstable because of how MediaGenetion work? because if this logic is in context of underlying generators, there's nothing to stabalize is it not?-->

### MediaGeneration vs MediaPanel

```
MediaGeneration (553 lines)          MediaPanel (409 lines)
─────────────────────────────        ─────────────────────────────
State management                     UI rendering
API calls (SSE streaming)            Action button handlers
Task reconnection                    Validation logic
Context provider                     Crop modal state
InteractionHost integration          Preview display
                                     MediaGrid rendering
```

**No duplication** - clean separation of concerns.

### Potential Simplification

The task reconnection logic (lines 139-252) is complex. Could be:
- Extracted to a custom hook `useTaskReconnection()`
- Simplified if reconnection is rarely used

The SSE handling in `executeSubAction` (lines 341-396) could be:
- Extracted to a utility function
- Shared with reconnection logic (similar patterns)

## New Compound Syntax Design

### Current Problem

InputSchemaComposer duplicates compound split logic. When it sees
`tab.media`, it:
1. Splits into outer="tab", inner="media"
2. Wraps inputs inside the tab, above the media panel

This is wrong - compound parsing should only be in SchemaRenderer.

### Proposed Syntax

```
tab[input_schema,image_generation]
```

Where:
- `tab` - outer wrapper (TabLayout)
- `[...]` - bracket syntax for siblings at same level
- `input_schema` - fixed keyword, renders InputSchemaRenderer
- `image_generation` - the leaf component

### Parsing Logic

In SchemaRenderer, when `render_as` contains `[`:

```typescript
// Example: "tab[input_schema,image_generation]"
if (ux.render_as.includes("[")) {
  const bracketStart = ux.render_as.indexOf("[");
  const bracketEnd = ux.render_as.indexOf("]");

  const outerRenderAs = ux.render_as.slice(0, bracketStart); // "tab"
  const innerParts = ux.render_as
    .slice(bracketStart + 1, bracketEnd)
    .split(","); // ["input_schema", "image_generation"]

  return (
    <SchemaRenderer ux={{ ...ux, render_as: outerRenderAs }}>
      <div className="space-y-4">
        {innerParts.map(part => {
          if (part === "input_schema") {
            // Render InputSchemaRenderer (requires InputSchemaContext)
            return <InputSchemaRenderer key={part} ... />;
          }
          return (
            <SchemaRenderer
              key={part}
              ux={{ ...ux, render_as: part }}
            />
          );
        })}
      </div>
    </SchemaRenderer>
  );
}
```

### InputSchemaComposer Changes

After this change, InputSchemaComposer becomes simpler:

```typescript
// InputSchemaComposer - AFTER
export function InputSchemaComposer({ data, schema, path, ux }) {
  // ... create InputSchemaContext ...

  // No compound parsing - just provide context
  // SchemaRenderer handles the bracket syntax
  return (
    <InputSchemaContext.Provider value={contextValue}>
      <!--shouldnt following just be {inputComponent}? there's nothing we are going to get by adding SchemaRenderer here.-->
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={{ ...ux, input_schema: undefined }}  // Remove to prevent loop
      />
    </InputSchemaContext.Provider>
  );
}
```

### Workflow Schema Changes

```diff
{
  "midjourney": {
    "_ux": {
-     "render_as": "tab.media",
+     "render_as": "tab[input_schema,image_generation]",
      "input_schema": { ... }
    }
  }
}
```

### Flow Diagram

```
SchemaRenderer(render_as="tab[input_schema,image_generation]", input_schema={...})
│
├─► Line 108: input_schema detected → InputSchemaComposer
│
InputSchemaComposer:
├── Creates InputSchemaContext
└── Returns <InputSchemaContext.Provider>
      <SchemaRenderer render_as="tab[input_schema,image_generation]" />
    </InputSchemaContext.Provider>
│
SchemaRenderer (now inside context):
├── Detects bracket syntax
├── outer="tab", innerParts=["input_schema", "image_generation"]
└── Returns:
    <SchemaRenderer render_as="tab">   // → TabLayout
      <div className="space-y-4">
        <InputSchemaRenderer />         // input_schema keyword
        <SchemaRenderer render_as="image_generation" />  // → ImageGeneration
      </div>
    </SchemaRenderer>
```

## Implementation Plan

### Phase 0: Extract MediaGeneration Utilities (Optional)

Consider extracting for clarity:
- `useTaskReconnection()` hook
- `handleSSEEvent()` utility

### Phase 1: Implement Bracket Syntax in SchemaRenderer

Add parsing for `render_as="outer[a,b,c]"`:
- Parse bracket content as comma-separated siblings
- Handle `input_schema` keyword specially
- Render siblings in order inside outer wrapper

### Phase 2: Simplify InputSchemaComposer

Remove duplicate compound split logic (lines 193-220).
Just provide context and delegate to SchemaRenderer.

### Phase 3: Add New render_as Types

```typescript
export type SpecialRendererType =
  | "content-panel"
  | "table"
  | "media"              // keep for backwards compat? or remove
  | "image_generation"   // new
  | "video_generation";  // new
```

### Phase 4: Create ImageGeneration

Extract from MediaPanel:
- Preview display
- Action buttons (txt2img, img2img)
- Validation
- Progress/error
- MediaGrid
- Card chrome (own wrapper)

### Phase 5: Create VideoGeneration

Extract from MediaPanel:
- All of ImageGeneration, plus:
- Crop modal state
- Source image handling
- CropSelectionModal
- Card chrome (own wrapper)

### Phase 6: Update Workflow Schemas

```diff
// cc_image_prompts_display_schema.json
- "render_as": "tab.media"
+ "render_as": "tab[input_schema,image_generation]"

// cc_video_generation_display_schema.json
- "render_as": "tab.media"
+ "render_as": "tab[input_schema,video_generation]"
```

### Phase 7: Remove MediaPanel

After verification, remove `MediaPanel.tsx`.

## File Changes Summary

| File | Change |
|------|--------|
| `SchemaRenderer.tsx` | Add bracket syntax parsing |
| `InputSchemaComposer.tsx` | Remove compound split, simplify |
| `schema/types.ts` | Add `image_generation`, `video_generation` |
| `ImageGeneration.tsx` | NEW - image generation panel |
| `VideoGeneration.tsx` | NEW - video generation panel |
| `MediaPanel.tsx` | REMOVE after migration |
| `index.ts` | Update exports |
| Workflow schemas | Update render_as values |

## Questions for Review

1. **Bracket syntax**: Is `tab[input_schema,image_generation]` the right
   syntax? Alternatives:
   - `tab{input_schema,image_generation}` (braces)
   - `tab(input_schema,image_generation)` (parens)
   - `tab:input_schema:image_generation` (colons)

2. **Nesting support**: Should bracket syntax support nesting?
   - `tabs[tab[input_schema,image_generation]]`
   - Or keep it simple: brackets only at leaf level

3. **MediaGeneration utilities**: Worth extracting reconnection/SSE logic
   to hooks/utilities, or leave as-is for this refactor?
