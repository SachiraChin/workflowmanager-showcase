# Media Generation Separation: Image vs Video

## Summary

Refactor the media-generation components to separate image generation
(`txt2img`, `img2img`) from video generation (`img2vid`) into distinct
components. Currently, `MediaPanel` handles both with conditional logic
based on `action_type`. This refactor introduces `ImageGeneration` and
`VideoGeneration` as separate components, enabling cleaner code paths
and easier feature additions.

## Current Architecture

### Component Hierarchy

```
MediaGeneration (interaction type handler)
├── Provides MediaGenerationContext
│   - generations state
│   - loading/progress/error state
│   - selectedContentId
│   - executeSubAction()
│   - crop state (for video)
└── SchemaRenderer
    └── tabs (render_as="tabs")
        └── TabsLayout
            └── tab.media (compound render_as)
                └── [InputSchemaComposer intercepts due to input_schema]
                    ├── InputSchemaContext.Provider
                    ├── InputSchemaRenderer (input fields)
                    └── SchemaRenderer(render_as="tab")
                        └── TabLayout
                            └── SchemaRenderer(render_as="media")
                                └── MediaPanel
```

<!--what does
ui/webui/src/interactions/types/media-generation/MediaGeneration.tsx and
ui/webui/src/interactions/types/media-generation/MediaGenerationContext.tsx do
here, where is it used in workflows? it looks to me like SchemaRenderer routes
render_as=media to MediaPanel, not MediaGeneration-->


### Key Files

| File | Responsibility |
|------|----------------|
| `MediaGeneration.tsx` | Context provider, state management, SSE streaming |
| `MediaPanel.tsx` | Renders inputs UI, action buttons, preview, grid |
| `MediaGrid.tsx` | Displays generated images/videos with selection |
| `CropSelectionModal.tsx` | Crop region selection (video only) |
| `MediaGenerationContext.tsx` | Context definition and hooks |
| `types.ts` | Shared type definitions |

### Current render_as Flow

For `render_as: "tab.media"` with `input_schema`:

1. **SchemaRenderer** detects `input_schema` → delegates to
   **InputSchemaComposer**

2. **InputSchemaComposer**:
   - Creates `InputSchemaContext` (values, errors, getMappedValues)
   - Renders `InputSchemaRenderer` for input fields
   <!--show me where following logic is in InputSchemaRenderer-->
   - Splits compound: outer="tab", inner="media"
   - Passes to SchemaRenderer for actual routing

3. **SchemaRenderer**(render_as="tab") → **TabLayout** (wraps children)

4. **SchemaRenderer**(render_as="media") → **MediaPanel** (leaf)

### Problem: Mixed Concerns in MediaPanel

`MediaPanel.tsx` currently handles both image and video with conditionals:

```typescript
// Video-specific: crop modal
if (action.action_type === "img2vid" && sourceImageData?.url) {
  // Show crop modal or use saved crop
}

// Video-specific: source image handling
if (action.action_type === "img2vid" && sourceImageData) {
  finalParams.source_image = sourceImageData;
}
```

This makes the component harder to maintain and extend.

## Proposed Architecture

### New Component Hierarchy

```
MediaGeneration (unchanged - context provider)
└── SchemaRenderer
    └── tabs
        └── tab.media.image_generation (3-level compound)
            └── TabLayout
                └── ??? (media wrapper - see Options below)
                    └── ImageGeneration (new)

        └── tab.media.video_generation (3-level compound)
            └── TabLayout
                └── ??? (media wrapper)
                    └── VideoGeneration (new)
```

### New Components

| Component | Responsibility |
|-----------|----------------|
| `ImageGeneration` | Action buttons, preview info, MediaGrid for images |
| `VideoGeneration` | Action buttons, preview info, crop modal, MediaGrid for videos |

### 3-Level Compound Parsing

For `tab.media.image_generation`:

```
SchemaRenderer(render_as="tab.media.image_generation")
  ↓ compound split: outer="tab", inner="media.image_generation"
SchemaRenderer(render_as="tab") → TabLayout
  ↓ children
SchemaRenderer(render_as="media.image_generation")
  ↓ compound split: outer="media", inner="image_generation"
SchemaRenderer(render_as="media") → ??? (wrapper)
  ↓ children
SchemaRenderer(render_as="image_generation") → ImageGeneration
```

## Open Question: What Should "media" Do?

With image/video logic extracted to separate components, what role does
the `media` wrapper serve?

<!--Are you sure there's nothing in MediaPanel left after adding everything to
new component, for example, where will input_schema go in this case-->

### Option A: Remove "media" Layer

Use 2-level compound directly:
- `tab.image_generation`
- `tab.video_generation`

**Pros:**
- Simpler, no intermediate wrapper
- Fewer components to maintain

**Cons:**
- Loses grouping concept (these are all "media generation" types)
- May need to duplicate any shared wrapper logic

### Option B: "media" as Passthrough

`render_as="media"` becomes a passthrough that just renders children:

```typescript
if (ux.render_as === "media") {
  return <>{children}</>;
}
```

**Pros:**
- Preserves 3-level naming convention
- Easy to add shared wrapper logic later

**Cons:**
- Extra indirection for no immediate benefit

### Option C: "media" as Shared Chrome

`render_as="media"` provides shared UI wrapper (container styling,
consistent padding, etc.):

```typescript
if (ux.render_as === "media") {
  return (
    <div className="rounded-lg border bg-card overflow-hidden shadow-sm">
      {children}
    </div>
  );
}
```

**Pros:**
- Consistent styling across image/video panels
- Single place to update shared chrome

**Cons:**
- Limited value if styling is minimal
- Could be handled by individual components

### Option D: "media" Provides Additional Context

`render_as="media"` could provide media-specific context that's separate
from `MediaGenerationContext`:

```typescript
if (ux.render_as === "media") {
  return (
    <MediaPanelContext.Provider value={panelContextValue}>
      {children}
    </MediaPanelContext.Provider>
  );
}
```

**Pros:**
- Clean separation of concerns
- Panel-level state separate from interaction-level state

**Cons:**
- Need to identify what state belongs here vs MediaGenerationContext
- Added complexity

## Implementation Plan (Pending Option Selection)

### Phase 1: Type System Updates
1. Add to `SpecialRendererType`: `"image_generation"`, `"video_generation"`
2. Add `"media"` handling based on chosen option
3. Update `SPECIAL_RENDERER_TYPES` array

### Phase 2: Create New Components
1. `ImageGeneration.tsx`:
   - Extract image-specific logic from MediaPanel
   - Action buttons, preview info, MediaGrid
   - Uses MediaGenerationContext and InputSchemaContext

2. `VideoGeneration.tsx`:
   - Extract video-specific logic from MediaPanel
   - Crop modal integration, source image handling
   - Uses MediaGenerationContext and InputSchemaContext

### Phase 3: Update SchemaRenderer
```typescript
if (ux.render_as === "media") {
  // Based on chosen option
}

if (ux.render_as === "image_generation") {
  return <ImageGeneration data={data} schema={schema} path={path} ux={ux} />;
}

if (ux.render_as === "video_generation") {
  return <VideoGeneration data={data} schema={schema} path={path} ux={ux} />;
}
```

### Phase 4: Update Workflow Schemas
1. `cc_image_prompts_display_schema.json`:
   - Change `"render_as": "tab.media"` → `"render_as": "tab.media.image_generation"`
   (or `"tab.image_generation"` if Option A)

2. `cc_video_generation_display_schema.json`:
   - Change `"render_as": "tab.media"` → `"render_as": "tab.media.video_generation"`
   (or `"tab.video_generation"` if Option A)

### Phase 5: Cleanup
1. Remove or deprecate `MediaPanel.tsx`
2. Update exports in `index.ts`

## Questions for Review

<!--i will answer following once we are done with question above-->

1. **Which option for "media" wrapper?** (A, B, C, or D)

2. **Shared utilities**: Should we extract any shared logic between
   ImageGeneration and VideoGeneration into hooks or utilities?
   - Preview fetching/display logic?
   - Action button rendering?
   - Progress/error display?

3. **MediaGrid reuse**: MediaGrid already handles both images and videos.
   Should it stay as-is, or split into ImageGrid/VideoGrid?

4. **File organization**: Keep all in `media-generation/` folder, or
   create subfolders?
   ```
   media-generation/
   ├── image/
   │   └── ImageGeneration.tsx
   ├── video/
   │   └── VideoGeneration.tsx
   │   └── CropSelectionModal.tsx
   ├── shared/
   │   └── MediaGrid.tsx
   └── ...
   ```
