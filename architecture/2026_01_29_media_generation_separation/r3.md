# Media Generation Separation: Image vs Video (R3)

## Summary

Refactor the media-generation components to separate image generation
(`txt2img`, `img2img`) from video generation (`img2vid`) into distinct
components. This refactor also fixes a bug where compound render_as
parsing is duplicated in InputSchemaComposer.

## Current Architecture

### Full Chain: Workflow → Backend → Frontend

```
WORKFLOW (e.g., cc/steps/3_image_prompts/step.json:69)
│
│  {
│    "module_id": "media.generate",
│    "inputs": {
│      "prompts": "{{ state.image_prompts }}",
│      "schema": { "$ref": "schemas/cc_image_prompts_display_schema.json" }
│    },
│    "sub_actions": [{ "id": "generate", "action_type": "txt2img", ... }]
│  }
│
▼
BACKEND MODULE (backend/server/modules/media/generate.py)
│
│  class MediaGenerateModule:
│      module_id = "media.generate"  (line 50)
│
│      async def execute(...):
│          return InteractionRequest(
│              interaction_type=InteractionType.MEDIA_GENERATION,  (line 124)
│              display_data={
│                  "data": data,
│                  "schema": schema,
│                  "sub_actions": sub_actions,
│              }
│          )
│
▼
FRONTEND (ui/webui/src/interactions/InteractionHost.tsx:150-151)
│
│  case "media_generation":
│      return <MediaGeneration />;
│
▼
<!--is there lots of duplicated logic in MediaGeneraration and MediaPanel, I 
see some parts it needs, but whats its role in grand schema of things? this 
feels like very complex component and i want know why this complexity is needed
-->
MediaGeneration.tsx (lines 540-552)
│
│  return (
│    <MediaGenerationProvider value={mediaContextValue}>
│      <SchemaRenderer
│        data={data}           // from display_data.data
│        schema={schema}       // from display_data.schema
│      />
│    </MediaGenerationProvider>
│  );
│
▼
SchemaRenderer routes based on schema's render_as values
```

### Current render_as Flow

The display schema (e.g., `cc_image_prompts_display_schema.json`) contains:

```json
{
  "prompts": {
    "_ux": {
      "render_as": "tabs"
    },
    "properties": {
      "midjourney": {
        "_ux": {
          "render_as": "tab.media",
          "input_schema": { ... }
        }
      }
    }
  }
}
```

Flow for `render_as="tab.media"` with `input_schema`:

```
SchemaRenderer(schema with render_as="tab.media", input_schema={...})
│
├─► Line 108: input_schema detected
│   └─► Delegates to InputSchemaComposer
│
▼
InputSchemaComposer (CURRENT - HAS BUG)
├── Creates InputSchemaContext (values, errors, getMappedValues)
├── Creates inputComponent = <InputSchemaRenderer />
├── BUG: Duplicates compound split logic (lines 193-220)
│   │   This should NOT be here - SchemaRenderer handles this
│   └── Returns nested SchemaRenderers for tab → media
│
▼
SchemaRenderer(render_as="tab") → TabLayout
│
▼
SchemaRenderer(render_as="media") → MediaPanel (leaf)
```

### Bug: Duplicate Compound Split Logic

**Location 1** - SchemaRenderer.tsx lines 121-145 (CORRECT):
```typescript
if (ux.render_as && ux.render_as.includes(".")) {
  const dotIndex = ux.render_as.indexOf(".");
  const outerRenderAs = ux.render_as.slice(0, dotIndex);
  const innerRenderAs = ux.render_as.slice(dotIndex + 1);
  return (
    <SchemaRenderer ux={{ ...ux, render_as: outerRenderAs }}>
      <SchemaRenderer ux={{ ...ux, render_as: innerRenderAs }} />
    </SchemaRenderer>
  );
}
```

**Location 2** - InputSchemaComposer.tsx lines 193-220 (BUG - DUPLICATE):
```typescript
if (ux.render_as && ux.render_as.includes(".")) {
  // Same logic duplicated here - should be removed
}
```

**Fix needed**: Remove compound split from InputSchemaComposer. It should
only provide InputSchemaContext and render inputs, then delegate to
SchemaRenderer for all routing.

### Key Files

| File | Responsibility |
|------|----------------|
| `MediaGeneration.tsx` | Interaction handler for `media_generation` type. Provides MediaGenerationContext, renders SchemaRenderer |
| `MediaGenerationContext.tsx` | Context: subActions, generations, loading, executeSubAction, crop state |
| `MediaPanel.tsx` | Leaf renderer for `render_as="media"`. Card chrome + buttons + preview + grid + crop modal |
| `MediaGrid.tsx` | Grid display of images/videos with selection |
| `CropSelectionModal.tsx` | Crop region selection (video only) |
| `InputSchemaComposer.tsx` | Handles input_schema, provides InputSchemaContext |
| `InputSchemaRenderer.tsx` | Renders input fields |
| `SchemaRenderer.tsx` | Routes render_as to components, handles compound split |

### What MediaPanel Currently Does

1. **Card chrome**: Border, header, padding
2. **Preview info**: Resolution, credits, crop dimensions
3. **Action buttons**: From subActions config
4. **Validation**: Required field checking
5. **Progress/error**: Loading states, error display
6. **MediaGrid**: Generated content display
7. **Crop modal**: For img2vid only

## Proposed Architecture

### Option A: 3-Level with MediaPanel as Wrapper

Keep MediaPanel but split its responsibilities:

```
tab.media.image_generation
│
├── TabLayout (render_as="tab")
│   └── MediaPanel (render_as="media") - card chrome only, renders children
│       └── ImageGeneration (render_as="image_generation") - logic
│
tab.media.video_generation
│
├── TabLayout (render_as="tab")
│   └── MediaPanel (render_as="media") - card chrome only, renders children
│       └── VideoGeneration (render_as="video_generation") - logic + crop
```

MediaPanel becomes a thin wrapper:
```tsx
function MediaPanel({ children, ux }: Props) {
  const header = ux.display_label || "Media Generation";
  return (
    <div className="rounded-lg border bg-card overflow-hidden shadow-sm">
      <div className="px-4 py-2.5 bg-muted/50 border-b">
        <span className="font-medium text-sm">{header}</span>
      </div>
      <div className="p-4 space-y-4">
        {children}
      </div>
    </div>
  );
}
```

### Option B: 2-Level, Each Component Has Own Chrome

No "media" wrapper - ImageGeneration and VideoGeneration render their
own card chrome:

```
tab.image_generation
│
├── TabLayout (render_as="tab")
│   └── ImageGeneration (render_as="image_generation") - chrome + logic
│
tab.video_generation
│
├── TabLayout (render_as="tab")
│   └── VideoGeneration (render_as="video_generation") - chrome + logic + crop
```

Each component includes the card wrapper internally.

### Comparison

| Aspect | Option A (3-level) | Option B (2-level) |
|--------|-------------------|-------------------|
| Complexity | More nesting | Simpler |
| Chrome consistency | Guaranteed same | Must maintain manually |
| Reuse | MediaPanel reusable | Chrome duplicated |
| render_as | `tab.media.image_generation` | `tab.image_generation` |

## Implementation Plan

### Phase 0: Fix InputSchemaComposer Bug

Remove duplicate compound split logic from InputSchemaComposer.tsx:

**Before** (lines 193-220):
```typescript
// Handle compound render_as (e.g., tab.media)
if (ux.render_as && ux.render_as.includes(".")) {
  // ... compound split logic - REMOVE THIS
}
```

**After**:
```typescript
// No compound handling - delegate to SchemaRenderer
return (
  <InputSchemaContext.Provider value={contextValue}>
    <div className="space-y-4">
      {inputComponent}
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={remainingUx}  // Keep full render_as, let SchemaRenderer split
      />
    </div>
  </InputSchemaContext.Provider>
);
```

**Issue**: This changes how inputs are positioned relative to the
compound structure. Need to verify inputs still render in correct place.

### Phase 1: Add New render_as Types

In `schema/types.ts`:
```typescript
export type SpecialRendererType =
  | "content-panel"
  | "table"
  | "media"              // wrapper (Option A) or removed (Option B)
  | "image_generation"   // new
  | "video_generation";  // new
```

### Phase 2: Create ImageGeneration

New file `ImageGeneration.tsx`:
- Uses `useMediaGeneration()` for generations, executeSubAction
- Uses `useInputSchemaOptional()` for input values
- Renders: preview info, action buttons, validation, progress, MediaGrid
- No crop-related code

### Phase 3: Create VideoGeneration

New file `VideoGeneration.tsx`:
- Same as ImageGeneration, plus:
- Crop modal state and handlers
- Source image handling (`getDataAtPath(["_source_image"])`)
- Crop info display
- CropSelectionModal

### Phase 4: Update MediaPanel or Remove

**Option A**: Modify MediaPanel to accept children, render only chrome
**Option B**: Remove MediaPanel entirely

### Phase 5: Update SchemaRenderer

```typescript
// Option A: media becomes wrapper
if (ux.render_as === "media") {
  return (
    <MediaPanel data={data} schema={schema} path={path} ux={ux}>
      {children}
    </MediaPanel>
  );
}

// Both options: new leaf components
if (ux.render_as === "image_generation") {
  return <ImageGeneration data={data} schema={schema} path={path} ux={ux} />;
}

if (ux.render_as === "video_generation") {
  return <VideoGeneration data={data} schema={schema} path={path} ux={ux} />;
}
```

### Phase 6: Update Workflow Schemas

**Option A** (3-level):
```diff
- "render_as": "tab.media"
+ "render_as": "tab.media.image_generation"
```

**Option B** (2-level):
```diff
- "render_as": "tab.media"
+ "render_as": "tab.image_generation"
```

## Questions for Review

1. **Option A or Option B?**
   - A: 3-level with MediaPanel as wrapper
   - B: 2-level with each component having own chrome
   <!--B-->

2. **InputSchemaComposer fix**: After removing compound split, where
   should inputs render relative to the component tree? Currently they
   render inside the tab but above the media panel. Should this change?

    <!--only way i think out of this is supprt render as this,
    "tab.media[input_schema,image_generation]" where input_schema is fixed
    keyword while image_generation is a keyword. but I need this properly
    implementeed, unlike current implementation.-->

3. **Naming**: `ImageGeneration` / `VideoGeneration` confirmed?
    <--yes-->

<!--I still want to figure out MediaGeneration component. I understand its
purpose, but the complexity of doesnt explain it.-->
