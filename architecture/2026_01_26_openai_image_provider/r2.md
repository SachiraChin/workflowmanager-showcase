# OpenAI Image Generation Provider Architecture (r2)

## Summary

Design for integrating OpenAI's image generation API into the existing media
provider system. This provider will support GPT Image models (gpt-image-1.5,
gpt-image-1, gpt-image-1-mini) for text-to-image generation and image editing
(inpainting).

## Changes from r1

- Clarified that worker handles all execution uniformly (no UI difference from polling APIs)
- Updated to follow existing worker/download pattern
- Added base64 handling strategy for download.py
- Clarified aspect ratio vs size (UI shows aspect ratios, API uses sizes)
- Removed pseudo-code noise, focused on integration points

---

## Design Decisions

### 1. Follow Existing Provider Pattern

**Decision**: Implement as a new provider under `backend/providers/media/openai/` following the established `MediaProviderBase` interface.

**Rationale**:
- Consistency with existing Leonardo, MidAPI, and Stable Diffusion providers
- Automatic registration via `@register` decorator
- Works with existing task queue and workflow integration
- Standardized return types (`GenerationResult`, `ContentItem`, `PreviewInfo`)

### 2. Synchronous API (Worker Perspective)

**Decision**: OpenAI's image API returns results directly - no polling loop needed inside the provider.

**Worker integration**: The MediaActor calls `provider.txt2img()` and waits for
the response. From the worker and UI perspective, this is identical to polling
APIs - the task is queued, worker claims it, executes (blocking), returns
result. The UI sees the same progress updates and completion flow.

**Implementation note**: May need longer HTTP timeout (60-120s) since OpenAI generation can take 30-60 seconds.

### 3. Base64 Response → URL Pattern

**Decision**: Request images as base64 from OpenAI, convert to data URI, let existing `download_media()` handle storage.

**Current flow** (Leonardo/MidAPI):
```
Provider returns URLs → download_media(url) → requests.get(url) → save to disk
```

**OpenAI flow**:
```
Provider returns base64 → ContentItem(url=f"data:image/png;base64,{b64}")
→ download_media() handles data URI → decode base64 → save to disk
```

<!--just to clarify, i'm okay with your proposal below, but understand that
there are more things done in downlod_media, make sure to cover all apllicable
changes. also, we probably should move current current logic to
_download_from_uri and new one to _download_from_base64 or something like
that.-->

**Required change**: Extend `download_media()` to detect and handle data URIs. This is a small addition:

```python
def download_media(url: str, ...) -> DownloadResult:
    # Handle data URI (base64)
    if url.startswith("data:"):
        return _download_from_data_uri(url, ...)

    # Existing HTTP download logic
    response = requests.get(url, timeout=60, stream=True)
    ...
```

### 4. Local Cost Calculation

**Decision**: Implement cost calculation using a static lookup table.

**Rationale**:
- OpenAI has no pre-request pricing calculator API
- Pricing is deterministic: model + quality + size + n
- Similar to MidAPI's `CREDIT_COSTS` lookup table

### 5. Aspect Ratio Mapping

<!--in previous doc, you added more sizes, and looking at following resolutions
for aspect ratios, they dont match. can you clarify what exactly happening
    here?-->

**Decision**: UI shows aspect ratios (1:1, 2:3, 3:2, etc.), provider maps to OpenAI's size strings.

OpenAI only supports 3 sizes:
- `1024x1024` (square)
- `1024x1536` (portrait)
- `1536x1024` (landscape)

**UI options → API mapping**:
| UI Aspect Ratio | OpenAI Size |
|-----------------|-------------|
| 1:1 | 1024x1024 |
| 2:3, 9:16 | 1024x1536 |
| 3:2, 16:9 | 1536x1024 |

**Note**: Unlike Leonardo which supports arbitrary dimensions, OpenAI is limited to these 3. UI should only show these options for OpenAI provider.

---

## API Reference

- **Base URL**: `https://api.openai.com/v1`
- **Auth**: `Authorization: Bearer {OPENAI_API_KEY}`
- **Docs**: https://platform.openai.com/docs/api-reference/images

### Endpoints

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/images/generations` | POST | Text-to-image generation |
| `/images/edits` | POST | Image editing (inpainting) |

---

## Supported Parameters

### Generation (`txt2img`)

| Parameter | Type | Values | Default | Notes |
|-----------|------|--------|---------|-------|
| `model` | string | `gpt-image-1.5`, `gpt-image-1`, `gpt-image-1-mini` | `gpt-image-1` | Required |
| `prompt` | string | max 32,000 chars | - | Required |
| `n` / `num_images` | integer | 1-10 | 1 | Number of images |
| `aspect_ratio` | string | `1:1`, `2:3`, `3:2` | `1:1` | Mapped to size |
| `quality` | string | `low`, `medium`, `high` | `high` | Affects detail and cost |
| `background` | string | `transparent`, `opaque`, `auto` | `auto` | GPT models only |
| `output_format` | string | `png`, `jpeg`, `webp` | `png` | PNG/WebP for transparency |
| `moderation` | string | `auto`, `low` | `auto` | Content filtering |

### Editing (`img2img`)

| Parameter | Type | Notes |
|-----------|------|-------|
| `source_image` | string | URL or base64 of source image |
| `mask` | string | URL or base64 (transparent = edit area) |
| `prompt` | string | Description of desired edit |
| + all generation params | | |

---

## Pricing Table

Costs per-image in USD.

```python
# (model, quality, size) -> cost_per_image_usd
OPENAI_IMAGE_COSTS = {
    # gpt-image-1.5 (~20% cheaper than gpt-image-1)
    ("gpt-image-1.5", "low", "1024x1024"): 0.008,
    ("gpt-image-1.5", "low", "1024x1536"): 0.010,
    ("gpt-image-1.5", "low", "1536x1024"): 0.010,
    ("gpt-image-1.5", "medium", "1024x1024"): 0.032,
    ("gpt-image-1.5", "medium", "1024x1536"): 0.040,
    ("gpt-image-1.5", "medium", "1536x1024"): 0.040,
    ("gpt-image-1.5", "high", "1024x1024"): 0.136,
    ("gpt-image-1.5", "high", "1024x1536"): 0.170,
    ("gpt-image-1.5", "high", "1536x1024"): 0.170,

    # gpt-image-1
    ("gpt-image-1", "low", "1024x1024"): 0.011,
    ("gpt-image-1", "low", "1024x1536"): 0.016,
    ("gpt-image-1", "low", "1536x1024"): 0.016,
    ("gpt-image-1", "medium", "1024x1024"): 0.042,
    ("gpt-image-1", "medium", "1024x1536"): 0.063,
    ("gpt-image-1", "medium", "1536x1024"): 0.063,
    ("gpt-image-1", "high", "1024x1024"): 0.167,
    ("gpt-image-1", "high", "1024x1536"): 0.250,
    ("gpt-image-1", "high", "1536x1024"): 0.250,

    # gpt-image-1-mini (budget option)
    ("gpt-image-1-mini", "low", "1024x1024"): 0.005,
    ("gpt-image-1-mini", "low", "1024x1536"): 0.007,
    ("gpt-image-1-mini", "low", "1536x1024"): 0.007,
    ("gpt-image-1-mini", "medium", "1024x1024"): 0.020,
    ("gpt-image-1-mini", "medium", "1024x1536"): 0.030,
    ("gpt-image-1-mini", "medium", "1536x1024"): 0.030,
    ("gpt-image-1-mini", "high", "1024x1024"): 0.080,
    ("gpt-image-1-mini", "high", "1024x1536"): 0.120,
    ("gpt-image-1-mini", "high", "1536x1024"): 0.120,
}
```

**Note**: Values are approximations. Verify against current OpenAI pricing before implementation.

---

## Implementation Checklist

### 1. Extend download.py for base64

Add data URI handling to `backend/providers/media/download.py`:

```python
import base64

def _download_from_data_uri(
    data_uri: str,
    metadata_id: str,
    content_id: str,
    index: int,
    content_type: str,
    images_path: Optional[str],
    videos_path: Optional[str],
) -> DownloadResult:
    """Download from a data URI (base64 encoded)."""
    # Parse data URI: data:image/png;base64,{data}
    if not data_uri.startswith("data:"):
        raise DownloadError("Invalid data URI")

    # Extract mime type and data
    header, encoded = data_uri.split(",", 1)
    mime_match = re.match(r"data:([^;]+)", header)
    mime_type = mime_match.group(1) if mime_match else "image/png"

    # Decode base64
    try:
        file_data = base64.b64decode(encoded)
    except Exception as e:
        raise DownloadError(f"Failed to decode base64: {e}")

    # Get extension from mime type
    extension = get_extension_from_content_type(mime_type) or "png"

    # Determine storage path
    storage_path = images_path if content_type == "image" else videos_path
    if not storage_path:
        raise DownloadError(f"Storage path not configured for {content_type}")

    os.makedirs(storage_path, exist_ok=True)

    # Save file
    filename = f"{metadata_id}_{content_id}_{index}.{extension}"
    local_path = os.path.join(storage_path, filename)

    with open(local_path, "wb") as f:
        f.write(file_data)

    return DownloadResult(local_path=local_path, extension=extension)


def download_media(url: str, ...) -> DownloadResult:
    """Download media from URL or data URI."""
    # Handle data URI (base64)
    if url.startswith("data:"):
        return _download_from_data_uri(url, ...)

    # Existing HTTP download logic...
```

### 2. Create OpenAI provider

File: `backend/providers/media/openai/provider.py`

Key methods:
- `txt2img()` - Call `/images/generations`, return base64 as data URI
- `img2img()` - Call `/images/edits` with multipart form data
- `img2vid()` - Raise NotImplementedError
- `get_preview_info()` - Calculate from pricing table

### 3. Register provider

Add import to `backend/providers/media/__init__.py`:
```python
from .openai import OpenAIProvider  # noqa - registers via decorator
```

### 4. Environment variable

Add to server config:
```
OPENAI_API_KEY=sk-...
```

---

## File Structure

```
backend/providers/media/
├── download.py              # Add base64 handling
├── openai/
│   ├── __init__.py          # Export OpenAIProvider
│   └── provider.py          # Provider implementation
└── ...
```

---

## Questions for Review

1. **Concurrency**: Default `concurrency=3` similar to Leonardo. OpenAI rate limits are per-minute. Should this be higher?
<!--yeah, this works for now-->

2. **Model default**: Default to `gpt-image-1` for stability, or `gpt-image-1.5` for best quality?
<!--lets use 1.5-->

3. **img2img complexity**: The `/images/edits` endpoint uses multipart form-data (not JSON). Should we implement this for v1, or start with txt2img only?
<!--lets add it as we have it in others when applicable.-->

4. **Pricing verification**: Should we verify pricing values against OpenAI's current pricing page before implementing?
<!--yes-->
