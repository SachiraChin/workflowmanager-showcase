# OpenAI Image Generation Provider Architecture (r3)

## Summary

Design for integrating OpenAI's image generation API into the existing media
provider system. This provider will support GPT Image models (gpt-image-1.5,
gpt-image-1, gpt-image-1-mini) for text-to-image generation and image editing
(inpainting).

## Changes from r2

- Updated pricing table with verified values from official OpenAI pricing page
- Clarified aspect ratio mapping (only 3 sizes supported)
- Refined download.py refactoring: `_download_from_url` + `_download_from_base64`
- Default model set to `gpt-image-1.5`
- Confirmed img2img will be included

---

## Design Decisions

### 1. Follow Existing Provider Pattern

**Decision**: Implement as a new provider under
`backend/providers/media/openai/` following the established
`MediaProviderBase` interface.

**Rationale**:
- Consistency with existing Leonardo, MidAPI, and Stable Diffusion providers
- Automatic registration via `@register` decorator
- Works with existing task queue and workflow integration
- Standardized return types (`GenerationResult`, `ContentItem`, `PreviewInfo`)

### 2. Synchronous API (Worker Perspective)

**Decision**: OpenAI's image API returns results directly - no polling loop
needed inside the provider.

**Worker integration**: The MediaActor calls `provider.txt2img()` and waits
for the response. From the worker and UI perspective, this is identical to
polling APIs - the task is queued, worker claims it, executes (blocking),
returns result. The UI sees the same progress updates and completion flow.

**Implementation note**: May need longer HTTP timeout (60-120s) since OpenAI
generation can take 30-60 seconds.

### 3. Base64 Response Handling

**Decision**: Request images as base64 from OpenAI, convert to data URI, let
existing `download_media()` handle storage.

**Current flow** (Leonardo/MidAPI):
```
Provider returns URLs → download_media(url) → requests.get() → save to disk
```

**OpenAI flow**:
```
Provider returns base64 → ContentItem(url=f"data:image/png;base64,{b64}")
→ download_media() detects data URI → decode base64 → save to disk
```

**Required refactoring in download.py**:
- Rename current HTTP download logic to `_download_from_url()`
- Add new `_download_from_base64()` for data URI handling
- Main `download_media()` dispatches based on URL prefix

### 4. Local Cost Calculation

**Decision**: Implement cost calculation using a static lookup table.

**Rationale**:
- OpenAI has no pre-request pricing calculator API
- Pricing is deterministic: model + quality + size + n
- Similar to MidAPI's `CREDIT_COSTS` lookup table

### 5. Aspect Ratio Mapping

**Decision**: UI shows aspect ratios, provider maps to OpenAI's size strings.

**OpenAI GPT Image models support exactly 3 sizes:**
- `1024x1024` (square, 1:1)
- `1024x1536` (portrait, 2:3)
- `1536x1024` (landscape, 3:2)

**UI options (only exact 1:1 mappings):**

| UI Display        | Aspect Ratio | OpenAI Size  |
|-------------------|--------------|--------------|
| 1024x1024 (1:1)   | 1:1          | 1024x1024    |
| 1024x1536 (2:3)   | 2:3          | 1024x1536    |
| 1536x1024 (3:2)   | 3:2          | 1536x1024    |

**Note**: Unlike Leonardo which supports many dimensions, OpenAI is limited
to these 3. The UI should only show these exact options when OpenAI provider
is selected. No aliases (9:16, 16:9) since they don't match the actual
resolution ratios.

### 6. Default Model

**Decision**: Default to `gpt-image-1.5` for best quality and speed.

---

## API Reference

- **Base URL**: `https://api.openai.com/v1`
- **Auth**: `Authorization: Bearer {OPENAI_API_KEY}`
- **Docs**: https://platform.openai.com/docs/api-reference/images

### Endpoints

| Endpoint              | Method | Purpose                    |
|-----------------------|--------|----------------------------|
| `/images/generations` | POST   | Text-to-image generation   |
| `/images/edits`       | POST   | Image editing (inpainting) |

---

## Supported Parameters

### Generation (`txt2img`)

| Parameter        | Type    | Values                            | Default         |
|------------------|---------|-----------------------------------|-----------------|
| `model`          | string  | See models below                  | `gpt-image-1.5` |
| `prompt`         | string  | max 32,000 chars                  | -               |
| `n`/`num_images` | integer | 1-10                              | 1               |
| `aspect_ratio`   | string  | `1:1`, `2:3`, `3:2`               | `1:1`           |
| `quality`        | string  | `low`, `medium`, `high`           | `high`          |
| `background`     | string  | `transparent`, `opaque`, `auto`   | `auto`          |
| `output_format`  | string  | `png`, `jpeg`, `webp`             | `png`           |
| `moderation`     | string  | `auto`, `low`                     | `auto`          |

**Available models:**
- `gpt-image-1.5` - Latest, fastest, best quality (recommended)
- `chatgpt-image-latest` - Alias for gpt-image-1.5
- `gpt-image-1` - Original model
- `gpt-image-1-mini` - Budget option for high volume

### Editing (`img2img`)

| Parameter               | Type   | Notes                                   |
|-------------------------|--------|-----------------------------------------|
| `source_image`          | string | URL or base64 of source image           |
| `mask`                  | string | URL or base64 (transparent = edit area) |
| `prompt`                | string | Description of desired edit             |
| + all generation params |        |                                         |

**Note**: The `/images/edits` endpoint uses multipart form-data, not JSON.

---

## Pricing Table (Verified)

**Source**: OpenAI Official Pricing Page (January 2026)

Costs per-image in USD:

```python
# (model, quality, size) -> cost_per_image_usd
OPENAI_IMAGE_COSTS = {
    # gpt-image-1.5 (and chatgpt-image-latest)
    ("gpt-image-1.5", "low", "1024x1024"): 0.009,
    ("gpt-image-1.5", "low", "1024x1536"): 0.013,
    ("gpt-image-1.5", "low", "1536x1024"): 0.013,
    ("gpt-image-1.5", "medium", "1024x1024"): 0.034,
    ("gpt-image-1.5", "medium", "1024x1536"): 0.05,
    ("gpt-image-1.5", "medium", "1536x1024"): 0.05,
    ("gpt-image-1.5", "high", "1024x1024"): 0.133,
    ("gpt-image-1.5", "high", "1024x1536"): 0.2,
    ("gpt-image-1.5", "high", "1536x1024"): 0.2,

    # gpt-image-1
    ("gpt-image-1", "low", "1024x1024"): 0.011,
    ("gpt-image-1", "low", "1024x1536"): 0.016,
    ("gpt-image-1", "low", "1536x1024"): 0.016,
    ("gpt-image-1", "medium", "1024x1024"): 0.042,
    ("gpt-image-1", "medium", "1024x1536"): 0.063,
    ("gpt-image-1", "medium", "1536x1024"): 0.063,
    ("gpt-image-1", "high", "1024x1024"): 0.167,
    ("gpt-image-1", "high", "1024x1536"): 0.25,
    ("gpt-image-1", "high", "1536x1024"): 0.25,

    # gpt-image-1-mini
    ("gpt-image-1-mini", "low", "1024x1024"): 0.005,
    ("gpt-image-1-mini", "low", "1024x1536"): 0.006,
    ("gpt-image-1-mini", "low", "1536x1024"): 0.006,
    ("gpt-image-1-mini", "medium", "1024x1024"): 0.011,
    ("gpt-image-1-mini", "medium", "1024x1536"): 0.015,
    ("gpt-image-1-mini", "medium", "1536x1024"): 0.015,
    ("gpt-image-1-mini", "high", "1024x1024"): 0.036,
    ("gpt-image-1-mini", "high", "1024x1536"): 0.052,
    ("gpt-image-1-mini", "high", "1536x1024"): 0.052,
}
```

---

## Implementation Checklist

### 1. Refactor download.py

Refactor `backend/providers/media/download.py` to separate URL vs base64:

```python
import base64
import re

def _download_from_url(
    url: str,
    metadata_id: str,
    content_id: str,
    index: int,
    content_type: str,
    images_path: Optional[str],
    videos_path: Optional[str],
) -> DownloadResult:
    """Download from HTTP/HTTPS URL (existing logic)."""
    # Determine storage path
    storage_path = images_path if content_type == "image" else videos_path
    if not storage_path:
        raise DownloadError(f"Storage path not configured for {content_type}")

    os.makedirs(storage_path, exist_ok=True)

    # Download the file
    logger.info(f"[MediaDownload] Downloading {content_type} from URL...")

    try:
        response = requests.get(url, timeout=60, stream=True)
        response.raise_for_status()
    except requests.RequestException as e:
        raise DownloadError(f"Failed to download: {e}")

    # Determine extension from Content-Type or URL
    extension = None
    content_type_header = response.headers.get("Content-Type", "")
    if content_type_header:
        extension = get_extension_from_content_type(content_type_header)
    if not extension:
        extension = get_extension_from_url(url)
    if not extension:
        extension = "mp4" if content_type == "video" else "png"

    # Save file
    filename = f"{metadata_id}_{content_id}_{index}.{extension}"
    local_path = os.path.join(storage_path, filename)

    with open(local_path, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)

    logger.info(f"[MediaDownload] Saved to {local_path}")
    return DownloadResult(local_path=local_path, extension=extension)


def _download_from_base64(
    data_uri: str,
    metadata_id: str,
    content_id: str,
    index: int,
    content_type: str,
    images_path: Optional[str],
    videos_path: Optional[str],
) -> DownloadResult:
    """Download from a data URI (base64 encoded)."""
    # Parse data URI: data:image/png;base64,{data}
    if "," not in data_uri:
        raise DownloadError("Invalid data URI format")

    header, encoded = data_uri.split(",", 1)

    # Extract mime type
    mime_match = re.match(r"data:([^;,]+)", header)
    mime_type = mime_match.group(1) if mime_match else "image/png"

    # Decode base64
    try:
        file_data = base64.b64decode(encoded)
    except Exception as e:
        raise DownloadError(f"Failed to decode base64: {e}")

    # Get extension from mime type
    extension = get_extension_from_content_type(mime_type)
    if not extension:
        extension = "mp4" if content_type == "video" else "png"

    # Determine storage path
    storage_path = images_path if content_type == "image" else videos_path
    if not storage_path:
        raise DownloadError(f"Storage path not configured for {content_type}")

    os.makedirs(storage_path, exist_ok=True)

    # Save file
    filename = f"{metadata_id}_{content_id}_{index}.{extension}"
    local_path = os.path.join(storage_path, filename)

    with open(local_path, "wb") as f:
        f.write(file_data)

    logger.info(f"[MediaDownload] Saved base64 to {local_path}")
    return DownloadResult(local_path=local_path, extension=extension)


def download_media(
    url: str,
    metadata_id: str,
    content_id: str,
    index: int,
    content_type: str,
    images_path: Optional[str],
    videos_path: Optional[str],
) -> DownloadResult:
    """
    Download media from URL or data URI and save to local storage.

    Supports:
    - HTTP/HTTPS URLs (existing behavior)
    - Data URIs with base64 encoding (new for OpenAI)
    """
    if url.startswith("data:"):
        return _download_from_base64(
            url, metadata_id, content_id, index,
            content_type, images_path, videos_path
        )
    else:
        return _download_from_url(
            url, metadata_id, content_id, index,
            content_type, images_path, videos_path
        )
```

### 2. Create OpenAI provider

File: `backend/providers/media/openai/provider.py`

Key methods:
- `txt2img()` - Call `/images/generations`, return base64 as data URI
- `img2img()` - Call `/images/edits` with multipart form data
- `img2vid()` - Raise NotImplementedError
- `get_preview_info()` - Calculate from pricing table

### 3. Register provider

Add import to `backend/providers/media/__init__.py`:
```python
from .openai import OpenAIProvider  # noqa - registers via decorator
```

### 4. Environment variable

Add to server config:
```
OPENAI_API_KEY=sk-...
```

---

## File Structure

```
backend/providers/media/
├── download.py              # Refactor: add base64 handling
├── openai/
│   ├── __init__.py          # Export OpenAIProvider
│   └── provider.py          # Provider implementation
└── ...
```

---

## Resolved Questions

1. **Concurrency**: `concurrency=3` confirmed
2. **Model default**: `gpt-image-1.5` confirmed
3. **img2img**: Include in v1, uses multipart form-data
4. **Pricing**: Verified from official OpenAI pricing page

---

## Plan of Action (POA)

### Phase 1: Infrastructure (download.py refactoring)
- [x] 1.1 Refactor `download_media()` - extract current logic to
      `_download_from_url()`
- [x] 1.2 Add `_download_from_base64()` for data URI handling
- [x] 1.3 Update `download_media()` to dispatch based on URL prefix
- [x] 1.4 Test base64 download with sample data URI

### Phase 2: Provider Implementation
- [x] 2.1 Create `backend/providers/media/openai/__init__.py`
- [x] 2.2 Create `backend/providers/media/openai/provider.py` with:
  - [x] 2.2.1 Class structure and `@register` decorator
  - [x] 2.2.2 Pricing lookup table (`OPENAI_IMAGE_COSTS`)
  - [x] 2.2.3 `_get_headers()` for auth
  - [x] 2.2.4 `_handle_response_error()` for error handling
  - [x] 2.2.5 `_resolve_size()` for aspect ratio → size mapping
  - [x] 2.2.6 `txt2img()` implementation
  - [x] 2.2.7 `img2img()` implementation (multipart form-data)
  - [x] 2.2.8 `img2vid()` stub (NotImplementedError)
  - [x] 2.2.9 `get_preview_info()` for cost calculation

### Phase 3: Registration and Integration
- [x] 3.1 Add import to `backend/providers/media/__init__.py`
- [x] 3.2 Verify provider appears in registry

### Phase 4: Testing
- [ ] 4.1 Test `txt2img` with simple prompt (requires OPENAI_API_KEY)
- [x] 4.2 Test `get_preview_info` cost calculation
- [x] 4.3 Test different quality/size combinations
- [ ] 4.4 Test `img2img` if time permits (requires OPENAI_API_KEY)

### Phase 5: Documentation
- [ ] 5.1 Add `OPENAI_API_KEY` to environment documentation
