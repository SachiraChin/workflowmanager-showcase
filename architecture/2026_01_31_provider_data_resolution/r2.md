# Provider Data Resolution - Revision 2

## Summary

This revision incorporates learnings from discussing the original proposal.
The goal remains: remove the `api.fetch` module that exposes internal API
endpoints and replace it with a secure, universal mechanism for provider
metadata (models, styles, etc.).

## Problem Statement

Step 3 of CC workflow has this security/architecture issue:

```json
// step.json - Module 2 (PROBLEMATIC)
{
  "module_id": "api.fetch",
  "inputs": {
    "url": "/wm-api/models/by_category",
    "base_url": "http://192.168.1.181:7860"
  },
  "outputs_to_state": { "response": "sd_model_categories" }
}
```

And the display schema references it:

```json
// display_schema.json
"model_category": {
  "enum": "{{ state.sd_model_categories }}",
  ...
}
```

**Issues:**
1. Workflow JSON contains hardcoded internal API endpoint
2. Potential attack vector (workflow can be modified to call arbitrary URLs)
3. Inconsistent with other providers (Leonardo/OpenAI/Midjourney have static
   data in schema)

## Revised Proposal: Module-Based Approach

Instead of adding a new `$provider` directive system, leverage the existing
`media.generate` module which is already responsible for media generation.

### Core Idea

1. Add inputs to `media.generate` module:
   - `providers`: List of providers used in this interaction
   - `action_type`: `txt2img` | `img2vid` | `txt2audio`

2. Module fetches provider metadata internally and includes it in `data`

3. Client renders using the data (no state references needed)

### Proposed Data Structure

```python
# In media.generate.get_interaction_request()

data = {
    "prompts": resolved_prompts,        # From LLM (existing)
    "provider_metadata": {              # NEW - fetched by module
        "stable_diffusion": {
            "categories": [
                {
                    "id": "realistic",
                    "name": "Realistic",
                    "models": [
                        {
                            "checkpoint_name": "realisticVision_v51.safetensors",
                            "model_name": "Realistic Vision V5.1",
                            "params": { ... }
                        }
                    ]
                }
            ]
        },
        "leonardo": {
            "models": [
                {"key": "de7d3faf-...", "label": "Phoenix 1.0", "styles": [...]}
            ]
        },
        "openai": {
            "models": [
                {"key": "gpt-image-1", "label": "GPT Image 1"}
            ]
        },
        "midjourney": {
            "versions": [
                {"key": "7", "label": "V7"}
            ]
        }
    },
    "generations": []                   # Empty, filled by client
}
```

<!--
lets take a step back on this re-iterate structure, the data schema we are working with is workflows/cc/steps/3_image_prompts/schemas/cc_image_prompts_schema.json, lets try to start from this one as this is the original data schema from llm. lets take example like below,

{
  "scene_title": "laborum fugiat",
  "key_moment": "officia dolore",
  "prompts": {
    "midjourney": {
      "prompt": "Lorem nostrud adipisicing deserunt",
      "style_notes": "est aliquip voluptate proident magna"
    },
    "leonardo": {
      "phoenix_1_0": {
        "prompt": "veniam commodo ut incididunt consequat",
        "style_notes": "mollit ad dolore"
      }
    },
    "openai": {
      "prompt": "ut amet",
      "camera_notes": "proident tempor non culpa qui"
    },
    "stable_diffusion": {
      "tag_prompt": "aliqua minim",
      "natural_prompt": "ullamco minim occaecat labore dolor",
      "negative_prompt": "aliquip",
      "style_notes": "nulla cillum magna"
    }
  }
}

the nodes directly under "prompts" are the names of providers. so, given that,
we really dont need input list of providers, because we can check nodes inside
the prompts and extract providers we are working with (as additional
improvements, we can see if it contain unknown providers, and fail early).

with data structure like this, my proposal falls behind because now in ui
level, we have to map providers. so, instead of that, we do this.

{
  "scene_title": "laborum fugiat",
  "key_moment": "officia dolore",
  "prompts": {
    "midjourney": {
      "_provider_metadata": {},
      "_generations": [],
      "prompt": "Lorem nostrud adipisicing deserunt",
      "style_notes": "est aliquip voluptate proident magna"
    },
    "leonardo": {
      "_provider_metadata": {},
      "_generations": [],
      "phoenix_1_0": {
        "prompt": "veniam commodo ut incididunt consequat",
        "style_notes": "mollit ad dolore"
      }
    },
    "openai": {
      "_provider_metadata": {},
      "_generations": [],
      "prompt": "ut amet",
      "camera_notes": "proident tempor non culpa qui"
    },
    "stable_diffusion": {
      "_provider_metadata": {},
      "_generations": [],
      "tag_prompt": "aliqua minim",
      "natural_prompt": "ullamco minim occaecat labore dolor",
      "negative_prompt": "aliquip",
      "style_notes": "nulla cillum magna"
    }
  }
}

Now we have each node within the provider with prompts and everything else.
wouldnt this resolve most problems you had?

-->

## The Challenge: input_schema and Data Matching

### How Data/Schema Matching Works

From studying other steps (e.g., music_options):

- **Data schema**: Defines structure of data (LLM output)
- **Display schema**: 1:1 matching fields with `_ux` hints
- Client walks schema, finds matching data by **field name**, applies `_ux`

Example:
```
data: { options: [{ name: "...", bpm: 120 }] }

schema: {
  properties: {
    options: {
      items: {
        properties: {
          name: { _ux: { render_as: "section-title" } },
          bpm: { _ux: { display_label: "BPM" } }
        }
      }
    }
  }
}
```

Fields match by path: `data.options[].name` ↔ `schema.options.items.name`

### The Problem with input_schema

In the image prompts display schema, `input_schema` lives **inside** `_ux`:

```json
"stable_diffusion": {
  "_ux": {
    "provider": "stable_diffusion",
    "render_as": "tab.media[input_schema,image_generation]",
    "input_schema": {                          // ← Inside _ux (metadata)
      "properties": {
        "model_category": {
          "enum": "{{ state.sd_model_categories }}"  // ← Needs data
        }
      }
    }
  },
  "properties": {                              // ← Data-matching fields
    "tag_prompt": { ... },
    "style_notes": { ... }
  }
}
```

**Key insight**: `input_schema` is rendering metadata (inside `_ux`), NOT part
of the 1:1 data-matching structure. The `properties` at the same level as
`_ux` are for data matching.

So how does `input_schema.model_category.enum` get populated from
`data.provider_metadata.stable_diffusion.categories`?

## Options to Resolve

### Option A: Client-Side Provider Lookup Convention

Since `_ux.provider: "stable_diffusion"` already declares the provider, the
client-side renderer can automatically look up provider metadata:

```javascript
// Client-side rendering logic (pseudo-code)
function renderInputSchema(inputSchema, uxConfig, data) {
  const provider = uxConfig.provider;
  const providerMeta = data.provider_metadata?.[provider];

  for (const [fieldName, fieldDef] of Object.entries(inputSchema.properties)) {
    if (fieldDef.enum === "$provider_models") {
      // Convention: replace with provider's model data
      fieldDef.enum = providerMeta?.categories || providerMeta?.models;
    }
  }
}
```

**Schema would change to:**
```json
"model_category": {
  "enum": "$provider_models",    // ← Convention marker, not Jinja2
  "enum_path": "categories",     // ← Optional: path within provider metadata
  ...
}
```

**Pros:**
- Simple convention
- No new directive resolution on server
- Provider already declared in `_ux`

**Cons:**
- Implicit magic (need to document the convention)
- Client needs to know about `$provider_*` markers

### Option B: Explicit Path Reference in input_schema

Allow input_schema fields to reference paths within `data`:

```json
"model_category": {
  "enum": {
    "$data_path": "provider_metadata.stable_diffusion.categories"
  },
  ...
}
```

**Pros:**
- Explicit, no guessing
- Works for any data path, not just provider metadata

**Cons:**
- Verbose
- Still needs client-side resolution (but it's just path lookup)

### Option C: Provider Metadata as Top-Level Schema Field

Include `provider_metadata` in the display schema as a hidden, data-matching
field:

```json
{
  "properties": {
    "prompts": { ... },
    "provider_metadata": {
      "_ux.display": false,
      "properties": {
        "stable_diffusion": {
          "properties": {
            "categories": { ... }
          }
        }
      }
    }
  }
}
```

Then `input_schema` could use a relative reference:

```json
"model_category": {
  "enum": "{{ provider_metadata.stable_diffusion.categories }}"
}
```

**Pros:**
- Consistent with data/schema matching pattern
- Template resolution can happen server-side

**Cons:**
- Mixing data-matching structure with rendering metadata
- Still uses Jinja2 templates (were we trying to avoid this?)

### Option D: Restructure input_schema Out of _ux

Move `input_schema` to be a sibling of `_ux` rather than inside it, making it
part of the data-matching structure:

```json
"stable_diffusion": {
  "_ux": {
    "provider": "stable_diffusion",
    "render_as": "tab.media[input_schema,image_generation]"
  },
  "input_schema": {              // ← Now at same level, data-matching
    "model_category": {
      "type": "string",
      "title": "Category"
      // enum would come from data.stable_diffusion.input_schema.model_category.enum
    }
  },
  "properties": {
    "tag_prompt": { ... }
  }
}
```

With data:
```json
data: {
  "prompts": {
    "stable_diffusion": {
      "tag_prompt": "...",
      "input_schema": {
        "model_category": {
          "enum": [...]   // Populated by module from provider.models()
        }
      }
    }
  }
}
```

**Pros:**
- Pure data/schema matching, no special resolution
- Module controls exactly what data goes where

**Cons:**
- Significant restructure
- Mixes prompt data with UI metadata
- Data structure becomes more complex

## Questions for Discussion

1. **Which option feels right?** Given the existing patterns and your vision
   for the system, which approach aligns best?

2. **Template elimination goal**: Is eliminating Jinja2 templates like
   `{{ state.X }}` from schemas a goal, or just eliminating the `api.fetch`
   security issue?

3. **Scope of change**: Should this be minimal (just fix SD models) or more
   comprehensive (standardize how all provider metadata flows)?

4. **Client complexity**: How much new logic is acceptable in the client-side
   rendering? Or should resolution happen server-side before sending to client?

