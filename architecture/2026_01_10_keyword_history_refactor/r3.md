# Keyword History Module Refactor - Revision 3

**Date:** 2026-01-10
**Status:** Draft - Awaiting Review
**Changes from r2:** Radically simplified design - module only handles weighted keywords, no source tracking

---

## 1. Summary

Create a new `io.weighted_keywords` module that stores and retrieves weighted keywords. The module is agnostic to concepts like "generated" vs "selected" - it simply stores keyword objects with weights and returns them based on configurable filters.

---

## 2. Clarification: Current Weight Behavior

### 2.1 For Generated Keywords (`update_keyword`)

```python
update_ops = {
    "$inc": {"total_weight": weight},  # ADDS to existing weight
    "$set": {"last_used": ..., "expires": ..., "source": source}
}
```

**Weight is accumulated.** Each call adds the provided weight to `total_weight`.

### 2.2 For Selected Keywords (`update_keyword_to_selected`)

```python
update_ops = {
    "$set": {"source": "selected", "last_used": ..., "expires": ...},
    "$setOnInsert": {"total_weight": 50}  # Only for NEW keywords
}
```

**Weight is NOT changed for existing keywords.** The `$setOnInsert` only applies when upserting a new document - it sets initial weight to 50. For existing keywords, weight stays unchanged.

**Bottom line:** When marking a keyword as "selected", its accumulated weight from generation is preserved, but no additional weight is added.
<!--this is wrong, it should be accumulated no matter what-->

---

## 3. Design Philosophy

The operator's feedback crystallized the key insight:

> "module does not need to know anything but weighted aspect of keyword"

This means:
- Module stores keyword objects (with weight, category, and any other fields)
- Module returns keyword objects based on filters
- **Source tracking, expiry logic, and semantic interpretation are workflow concerns**

---

## 4. New Module: `io.weighted_keywords`

### 4.1 Core Concept

The module is essentially a **keyword accumulator** - it stores weighted keywords and retrieves them. What workflows do with the keywords (exclude from prompts, filter by source, etc.) is up to them.

### 4.2 Keyword Object Structure

A weighted keyword has this shape:
```json
{
  "keyword": "sunny window",
  "weight": 80,
  "category": "setting",
  "source": "generated",      // optional - workflow decides what this means
  "expires": "2026-01-15",    // optional - workflow decides expiry logic
  // ... any other fields the workflow wants to store
}
```

The module stores whatever fields are provided. Only `keyword` and `weight` are required.

### 4.3 Module Inputs

```python
@property
def inputs(self) -> List[ModuleInput]:
    return [
        ModuleInput(
            name="mode",
            type="string",
            required=True,
            description="Operation: 'save' or 'load'"
        ),

        # === SAVE MODE ===
        ModuleInput(
            name="weighted_keywords",
            type="array",
            required=False,
            description="Array of keyword objects. Required fields: keyword, weight. Optional: category, source, expires, etc."
        ),
        ModuleInput(
            name="accumulate_weight",
            type="boolean",
            required=False,
            default=True,
            description="If true, weight is added to existing. If false, weight replaces existing."
        ),

        # === LOAD MODE ===
        ModuleInput(
            name="filters",
            type="object",
            required=False,
            default={},
            description="Filter criteria: {category: [...], source: '...', min_weight: N, max_age_days: N}"
        ),
        ModuleInput(
            name="limit",
            type="number",
            required=False,
            default=50,
            description="Maximum keywords to return"
        ),
        ModuleInput(
            name="sort_by",
            type="string",
            required=False,
            default="weight",
            description="Sort field: 'weight' (default) or 'last_used'"
        )
    ]
```

### 4.4 Module Outputs

```python
@property
def outputs(self) -> List[ModuleOutput]:
    return [
        # Load mode
        ModuleOutput(
            name="weighted_keywords",
            type="array",
            description="Array of keyword objects matching filters"
        ),
        ModuleOutput(
            name="count",
            type="number",
            description="Number of keywords returned"
        ),

        # Save mode
        ModuleOutput(
            name="saved_count",
            type="number",
            description="Number of keywords saved/updated"
        )
    ]
```

### 4.5 Filtering Without DB Queries

The `filters` input provides structured filtering without exposing raw DB queries:

```json
{
  "filters": {
    "category": ["setting", "object"],       // Include only these categories
    "source": "generated",                    // Match specific source value
    "min_weight": 50,                         // Minimum weight threshold
    <!--since expiry date is something provided by provider, following is not going to work -->
    "max_age_days": 7,                        // Only keywords used within N days
    "exclude_expired": true                   // Skip keywords past their expires date
  }
}
```

This is translated to a MongoDB query internally but workflows don't write raw queries.
<!--i want to to entertain idea of user providing mongo db pipline in module, but we make sure we enforce the context with running workflow_template_id, something like, we have parent node in mongodb pipeline with workflow_template_id filter, user provided pipeline will be executed after that. can be enforce something like that, simply sandboxing user's query. in that way, user will have all the flexibility they need, while we make sure they dont access to data they shouldnt have access to. -->

---

## 5. Usage Examples

### 5.1 Save Keywords After LLM Generation

```json
{
  "module_id": "io.weighted_keywords",
  "inputs": {
    "mode": "save",
    "weighted_keywords": "{{ state.flattened_keywords }}"
  },
  "name": "save_keywords"
}
```

Where `flattened_keywords` might look like:
```json
[
  {"keyword": "sunny window", "weight": 80, "category": "setting", "source": "generated", "expires": "2026-01-15"},
  {"keyword": "morning light", "weight": 60, "category": "atmosphere", "source": "generated", "expires": "2026-01-15"}
]
```

### 5.2 Update Keywords When User Selects

```json
{
  "module_id": "io.weighted_keywords",
  "inputs": {
    "mode": "save",
    "weighted_keywords": "{{ state.selected_scene.scene_keywords | map('combine', {'source': 'selected', 'expires': state.selected_expiry_date}) | list }}",
    "accumulate_weight": false
  },
  "name": "mark_selected"
}
```

**Note:** The workflow is responsible for:
- Changing `source` to `"selected"`
- Setting a longer `expires` date
- The module just stores what it's given

### 5.3 Load Keywords for Exclusion

```json
{
  "module_id": "io.weighted_keywords",
  "inputs": {
    "mode": "load",
    "filters": {
      "category": ["setting", "object"],
      "max_age_days": 7,
      "exclude_expired": true
    },
    "limit": 50,
    "sort_by": "weight"
  },
  "outputs_to_state": {
    "weighted_keywords": "all_keywords"
  },
  "name": "load_keywords"
}
```

### 5.4 Workflow Formats the Output

After loading, the workflow formats keywords for its prompt:

**Simple exclusion list (CC style):**
```
{{ state.all_keywords | map(attribute='keyword') | join(', ') }}
```

**Two-tier exclusion (OMS style):**
```
### Critically Prohibited
{% for kw in state.all_keywords | selectattr('source', 'equalto', 'selected') %}
{{ kw.keyword }}:{{ kw.weight }}{% if not loop.last %}, {% endif %}
{% endfor %}

### Optionally Prohibited
{% for kw in state.all_keywords | selectattr('source', 'equalto', 'generated') %}
{{ kw.keyword }}:{{ kw.weight }}{% if not loop.last %}, {% endif %}
{% endfor %}
```

---

## 6. Flattening Nested Data

### 6.1 Problem

OMS has nested keywords:
- `aesthetic_concepts[].aesthetic_keywords[]`
- `aesthetic_concepts[].ideas[].idea_keywords[]`

### 6.2 Solution: Use `transform.query`

The `transform.query` module can flatten and reshape data:

```json
{
  "module_id": "transform.query",
  "inputs": {
    "data": "{{ state.aesthetic_concepts_response.aesthetic_concepts }}",
    "query": "$..[aesthetic_keywords,idea_keywords][*]"
  },
  "outputs_to_state": {
    "result": "flattened_keywords"
  },
  "name": "flatten_keywords"
}
```

Or use `transform.extract` with Jinja2:

```json
{
  "module_id": "transform.extract",
  "inputs": {
    "flattened": "{% set all = [] %}{% for a in state.aesthetic_concepts_response.aesthetic_concepts %}{% for k in a.aesthetic_keywords %}{% set _ = all.append(k) %}{% endfor %}{% for i in a.ideas %}{% for k in i.idea_keywords %}{% set _ = all.append(k) %}{% endfor %}{% endfor %}{% endfor %}{{ all }}"
  },
  "outputs_to_state": {
    "flattened": "flattened_keywords"
  }
}
```

### 6.3 Add Flatten Filter to Jinja2

<!--i dont like to add things like this unless its absolutely necessary-->
Current Jinja2 environment does **not** have `flatten` filter. We should add it:

```python
# In jinja2_resolver.py
def flatten_filter(value):
    """Flatten nested lists into a single list."""
    result = []
    for item in value:
        if isinstance(item, list):
            result.extend(flatten_filter(item))
        else:
            result.append(item)
    return result

self._env.filters['flatten'] = flatten_filter
```

Then OMS could use:
```
{{ state.aesthetic_concepts_response.aesthetic_concepts
   | map(attribute='aesthetic_keywords') | list
   | flatten }}
```

---

## 7. Database Schema

### 7.1 Collection: `weighted_keywords`
<!--in reality, we only need #1, #4 and #5 is it not? what does step_id and module_id adds other than confusion. -->
```json
{
  "workflow_template_id": "tpl_abc123",
  "step_id": "user_input",
  "module_name": "save_keywords",
  "keyword": "sunny window",
  "weight": 240,
  "category": "setting",
  "source": "selected",
  "last_used": ISODate("2026-01-10T15:30:00Z"),
  "expires": ISODate("2026-01-20T15:30:00Z")
}
```

### 7.2 Indexes

```javascript
db.weighted_keywords.createIndex({
  "workflow_template_id": 1,
  "step_id": 1,
  "module_name": 1,
  "keyword": 1
}, { unique: true })

db.weighted_keywords.createIndex({
  "workflow_template_id": 1,
  "expires": 1
})
```

---

## 8. What About `source_module_name`?

### 8.1 Current Use

In the current design, `source_module_name` scopes keyword storage to specific modules:
- `save_keywords` module stores keywords
- `mark_selected` references `source_module_name: "save_keywords"` to update those same records

### 8.2 New Design

Keywords are still scoped by `(workflow_template_id, step_id, module_name)`. The module that saves keywords owns them.
<!--above is incorrect, keywords are not restricted by anything but workflow_template_id, if called needs to add some fields they needs to restrict on, they can add it and filter as needed. module is not going to do that for me. -->

To update keywords saved by another module, use:
```json
{
  "module_id": "io.weighted_keywords",
  "inputs": {
    "mode": "save",
    "weighted_keywords": "...",
    "target_module": "save_keywords"  // Optional: write to different module's namespace
  }
}
```

Or simpler: just use the same module `name` for both save operations:
```json
// First save (after LLM)
{ "name": "keyword_store", "mode": "save", ... }

// Second save (after user selection)
{ "name": "keyword_store", "mode": "save", ... }
```

---

## 9. Migration Plan

### Step 1: Create New Module
1. Create `server/modules/io/weighted_keywords.py`
2. Implement save/load with filters
3. Add `flatten` filter to Jinja2 environment

### Step 2: Update CC Workflow
1. Replace `history.keyword_history` calls with `io.weighted_keywords`
2. Remove Jinja2 hacks (no more faking OMS structure)
3. Add `source` and `expires` fields in the workflow's keyword preparation

### Step 3: Update OMS Workflow
1. Add keyword flattening step (transform.query or enhanced Jinja2)
2. Replace `db.query` modules with `io.weighted_keywords` load
3. Replace `history.keyword_history` calls with `io.weighted_keywords`
4. Format loaded keywords in prompt template using Jinja2

### Step 4: Cleanup
1. Remove `config.keyword_history` from both workflow_v3.json
2. Deprecate/remove old `history.keyword_history` module
3. Rename database collection if needed (or keep for backwards compat)

---

## 10. Files to Modify/Create

| File | Action |
|------|--------|
| `server/modules/io/weighted_keywords.py` | **CREATE** - New module |
| `server/engine/jinja2_resolver.py` | Add `flatten` filter |
| `workflows/cc/steps/2_scene_generation/step.json` | Use new module |
| `workflows/cc/workflow_v3.json` | Remove `config.keyword_history` |
| `workflows/oms/steps/1_user_input/step.json` | Use new module, remove db.query |
| `workflows/oms/workflow_v3.json` | Remove `config.keyword_history` |
| `TECHNICAL_DEBT.md` | Close item #9 |
| `server/modules/history/keyword_history.py` | Mark deprecated or remove |

---

## 11. Open Questions

1. **Database collection name:** Keep `keyword_history` or rename to `weighted_keywords`?
<!--lets rename-->

2. **Module scoping:** Should keywords be scoped per-step or per-workflow? Currently per-step+module.
<!--replied above-->

3. **Combine filter:** Does Jinja2 have a `combine` filter for merging dicts? If not, we may need to add it for the "mark selected" pattern.
<!--lets keep this open for now.-->
