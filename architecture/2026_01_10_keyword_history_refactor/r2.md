# Keyword History Module Refactor - Revision 2

**Date:** 2026-01-10
**Status:** Draft - Awaiting Review
**Changes from r1:** Simplified design based on operator feedback

---

## 1. Summary

Refactor `history.keyword_history` module to be workflow-agnostic with a simpler, more intuitive API. The module will work with flat keyword arrays and contain all configuration internally (no global config dependency).

---

## 2. Current Weight Management (How It Works Today)

### 2.1 Weight Accumulation

Weights are **accumulated over time** using MongoDB's `$inc` operator:

```python
# database_history.py, line 512-513
update_ops = {
    "$inc": {"total_weight": weight},  # Adds to running total
    "$set": {
        "last_used": last_used,
        "expires": expires,
        "source": source
    }
}
```

**Example:** If keyword "sunny window" is saved with weight 80 three times:
- First save: `total_weight = 80`
- Second save: `total_weight = 160`
- Third save: `total_weight = 240`

### 2.2 Keyword Record Structure (Database)

Each keyword is stored as a separate document:
```json
{
  "workflow_template_id": "tpl_abc123",
  "step_id": "user_input",
  "module_name": "save_keywords",
  "keyword": "sunny window",
  "total_weight": 240,
  "last_used": "2026-01-10T15:30:00Z",
  "expires": "2026-01-15T15:30:00Z",
  "source": "selected",
  "category": "setting"
}
```

### 2.3 Source Tracking

- `"generated"`: Keyword came from LLM-generated content
- `"selected"`: Keyword was in user-selected item (higher priority for exclusion)

When `update_keyword_to_selected()` is called, it changes `source` to `"selected"` and extends the expiry, but does **not** increment weight (uses `$setOnInsert` for new keywords only).
<!--i didnt get what you said about, did you mean, when selected keywords adding to db, it does not increase the weight, or its like that just for new keywords only?-->

---

## 3. Current Global Config (To Be Removed)

Both OMS and CC have this in `workflow_v3.json`:

```json
"config": {
  "keyword_history": {
    "generated_expiry_days": 5,
    "selected_expiry_days": 10,
    "max_selected_keywords": 30,
    "max_generated_keywords": 50,
    "categories": ["setting", "atmosphere", ...],
    "exclusion_categories": ["setting", "object"]
  }
}
```

**Problem:** Every module call must reference `{{ config.keyword_history.xxx }}` for each parameter.

**Solution:** Move all configuration into module inputs with sensible defaults.

---

## 4. Proposed New Design

### 4.1 Design Principles

1. **Single intuitive mode parameter** - `save` or `load`
2. **Flat data only** - Module receives `keywords[]`, workflows flatten their data
3. **Self-contained config** - All settings are module inputs with defaults
4. **No OMS-specific terminology** - Generic names only

### 4.2 Module Inputs (Simplified)

```python
@property
def inputs(self) -> List[ModuleInput]:
    return [
        # Core operation
        ModuleInput(
            name="mode",
            type="string",
            required=True,
            description="Operation: 'load' or 'save'"
        ),

        # === SAVE MODE INPUTS ===
        <!--i think output below should be weighted_keywords because thats what they are.-->
        ModuleInput(
            name="keywords",
            type="array",
            required=False,
            description="Array of keyword objects: [{keyword, category, weight}, ...]"
        ),
        <!--i dont think we should have this field. let provider add "source" field, and they can filter by it. module does not need to know anything but weighted asopect of keyword.-->
        ModuleInput(
            name="is_selected",
            type="boolean",
            required=False,
            default=False,
            description="True if these are user-selected keywords (longer expiry, higher priority)"
        ),
        ModuleInput(
            name="expiry_days",
            type="number",
            required=False,
            default=None,
            description="Days until keywords expire. Defaults: 5 for generated, 10 for selected"
        ),

        # === LOAD MODE INPUTS ===
        <!--given what i said above, how can we add filters to keywords without give explicit access to db queries?-->  
        ModuleInput(
            name="exclusion_categories",
            type="array",
            required=False,
            default=["setting", "object"],
            description="Categories to include in exclusion list"
        ),
        ModuleInput(
            name="max_keywords",
            type="number",
            required=False,
            default=50,
            description="Maximum keywords to return in exclusion list"
        ),
        ModuleInput(
            name="lookback_days",
            type="number",
            required=False,
            default=7,
            description="Only include keywords used within this many days"
        ),

        # === CROSS-MODULE REFERENCE ===
        <!--do we need source module name in this design?-->
        ModuleInput(
            name="source_module_name",
            type="string",
            required=False,
            description="For load: which module's keywords to load. For save with is_selected: which module to update."
        )
    ]
```

### 4.3 Module Outputs

```python
@property
def outputs(self) -> List[ModuleOutput]:
    return [
        # Load mode outputs
        ModuleOutput(
            name="exclusion_list",
            type="array",
            description="Array of keyword strings to exclude"
        ),
        <!--consistant naming between input and output, so below would be weighted_keywords-->
        ModuleOutput(
            name="keywords_detailed",
            type="object",
            description="Detailed keyword data: {selected: [...], generated: [...]}"
        ),
        ModuleOutput(
            name="stats",
            type="object",
            description="Statistics: {total, selected_count, generated_count}"
        ),

        # Save mode outputs
        ModuleOutput(
            name="saved_count",
            type="number",
            description="Number of keywords saved/updated"
        )
    ]
```

### 4.4 Usage Examples

**Save generated keywords (after LLM call):**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ state.scene_concepts.scenes[0].scene_keywords }}"
  },
  "name": "save_keywords"
}
```

**Save ALL generated keywords (multiple items):**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ state.scene_concepts.scenes | map(attribute='scene_keywords') | list | flatten }}"
  },
  "name": "save_keywords"
}
```

**Mark selected keywords:**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ state.selected_scene.scene_keywords }}",
    "is_selected": true,
    "source_module_name": "save_keywords"
  },
  "name": "mark_selected"
}
```

**Load exclusion list:**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "load",
    "source_module_name": "save_keywords",
    "exclusion_categories": ["setting", "behavior", "object"],
    "max_keywords": 50
  },
  "outputs_to_state": {
    "exclusion_list": "keyword_exclusion_list",
    "keywords_detailed": "keyword_data"
  },
  "name": "load_keywords"
}
```

---

## 5. OMS Two-Tier Exclusion Support

### 5.1 Problem

OMS needs separate lists for:
- **Critically prohibited** (selected keywords) - Hard ban
- **Optionally prohibited** (generated keywords) - Soft avoidance

### 5.2 Solution

The `keywords_detailed` output provides this:

```json
<!--I dont think we should do this, lets set flat list of keywords based on provided config, user can easlily filter it out and generate to format it needs. -->
{
  "selected": [
    {"keyword": "rooftop", "weight": 240, "category": "setting"},
    {"keyword": "laundry", "weight": 180, "category": "object"}
  ],
  "generated": [
    {"keyword": "golden hour", "weight": 80, "category": "atmosphere"},
    {"keyword": "window", "weight": 50, "category": "setting"}
  ]
}
```

**OMS prompt can use:**
```
### Critically Prohibited
{% for kw in state.keyword_data.selected %}{{ kw.keyword }}:{{ kw.weight }}{% if not loop.last %}, {% endif %}{% endfor %}

### Optionally Prohibited
{% for kw in state.keyword_data.generated %}{{ kw.keyword }}:{{ kw.weight }}{% if not loop.last %}, {% endif %}{% endfor %}
```

This eliminates the `db.query` hack while giving OMS the data structure it needs.

---

## 6. Flattening Nested Data

### 6.1 Responsibility

Workflows are responsible for flattening nested keyword structures before calling the module.

### 6.2 OMS Example (Aesthetic + Idea Keywords)

OMS has two levels of keywords per concept:
- `aesthetic_keywords[]` on the aesthetic
- `idea_keywords[]` on each idea

<!--i'm fine with either of these options, better yet, we can use transform.query module to structure data in more verbose way -->

**Flattening approach using Jinja2:**

```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ (state.aesthetic_concepts_response.aesthetic_concepts | map(attribute='aesthetic_keywords') | list + state.aesthetic_concepts_response.aesthetic_concepts | map(attribute='ideas') | map('map', attribute='idea_keywords') | list | flatten) | flatten }}"
  }
}
```

**Alternative: Use transform.extract first:**

```json
{
  "module_id": "transform.extract",
  "inputs": {
    "all_keywords": "{% set kws = [] %}{% for a in state.aesthetic_concepts_response.aesthetic_concepts %}{% for k in a.aesthetic_keywords %}{% set _ = kws.append(k) %}{% endfor %}{% for i in a.ideas %}{% for k in i.idea_keywords %}{% set _ = kws.append(k) %}{% endfor %}{% endfor %}{% endfor %}{{ kws | tojson }}"
  },
  "outputs_to_state": {
    "all_keywords": "flattened_keywords"
  }
},
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ state.flattened_keywords }}"
  }
}
```

### 6.3 CC Example (Already Flat)

CC's structure is simpler - just needs to concatenate scene keywords:

```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save",
    "keywords": "{{ state.scene_concepts.scenes | map(attribute='scene_keywords') | list | flatten }}"
  }
}
```

---

## 7. Migration Plan

### Step 1: Update Module Implementation
1. Add new inputs (`keywords`, `is_selected`, `expiry_days`, etc.)
2. Add new outputs (`keywords_detailed`)
3. Remove legacy inputs (`aesthetics`, `aesthetic`, `idea`)
4. Remove modes (`save_generated`, `save_selected`) - just `save` and `load`

### Step 2: Update CC Workflow
1. Remove Jinja2 hacks for faking OMS structure
2. Use new simple `keywords` input
3. Test keyword saving and loading

### Step 3: Update OMS Workflow
1. Remove `db.query` modules for keyword loading
2. Add keyword flattening (either inline Jinja2 or separate transform)
3. Use `keywords_detailed` output for two-tier exclusion
4. Test keyword saving and loading

### Step 4: Remove Global Config
1. Remove `config.keyword_history` from both workflow_v3.json files
2. All config is now in module inputs

---

## 8. Files to Modify

| File | Changes |
|------|---------|
| `server/modules/history/keyword_history.py` | New inputs/outputs, simplified modes |
| `workflows/cc/steps/2_scene_generation/step.json` | Remove hacks, use new API |
| `workflows/cc/workflow_v3.json` | Remove `config.keyword_history` |
| `workflows/oms/steps/1_user_input/step.json` | Remove db.query, use module properly |
| `workflows/oms/workflow_v3.json` | Remove `config.keyword_history` |
| `TECHNICAL_DEBT.md` | Close item #9 |

---

## 9. Questions for Review

1. **Jinja2 flatten filter:** Does the Jinja2 environment support the `flatten` filter? If not, we may need to add it or use a different approach for OMS keyword flattening.
<!--yeah, it should support it, but we better verify it. use venv to run commands in current env.-->

2. **Default expiry values:** Are these defaults acceptable?
   - Generated: 5 days
   - Selected: 10 days
   - Lookback: 7 days
<!--yeah, they are fine for now.-->

3. **Module naming:** Is `history.keyword_history` still the right name, or should it be renamed to something more generic like `history.keywords` or `data.keyword_tracker`?
<!--lets create brand new module io.weighted_keywords. it covers most bases. -->
