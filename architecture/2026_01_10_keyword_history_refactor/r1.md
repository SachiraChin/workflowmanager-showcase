# Keyword History Module Refactor

**Date:** 2026-01-10
**Status:** Draft - Awaiting Review
**Author:** Claude (with operator guidance)

---

## 1. Summary

The `history.keyword_history` module is currently hardcoded for OMS workflow's data structure. This document analyzes all the issues with the current implementation and proposes a generic, workflow-agnostic solution.

---

## 2. Current State Analysis

### 2.1 Module Location

`server/modules/history/keyword_history.py`

### 2.2 Current Input Structure (OMS-Specific)

The module expects these OMS-specific inputs:

**For `save_generated` mode:**
```python
aesthetics = [
    {
        "aesthetic_keywords": [
            {"keyword": "...", "category": "...", "weight": 50}
        ],
        "ideas": [
            {
                "idea_keywords": [
                    {"keyword": "...", "category": "...", "weight": 50}
                ]
            }
        ]
    }
]
```

**For `save_selected` mode:**
```python
aesthetic = {
    "aesthetic_keywords": [{"keyword": "...", "category": "...", "weight": 50}]
}
idea = {
    "idea_keywords": [{"keyword": "...", "category": "...", "weight": 50}]
}
```

### 2.3 Current Output Structure (Load Mode)

The `load` mode outputs:
- `keyword_exclusion_list`: Array of keyword strings (used for LLM prompts)
- `keyword_stats`: Object with counts
- `keyword_history`: Full history data

---

## 3. OMS Workflow Analysis (Step 1)

### 3.1 Keyword Loading - BYPASSES the Module!

OMS step 1 does **NOT** use `history.keyword_history` in `load` mode. Instead, it uses **two separate `db.query` modules** to query the keyword_history collection directly:

**Module: `load_keywords_generated` (lines 156-204)**
```json
{
  "module_id": "db.query",
  "inputs": {
    "table_schema": "keyword_history",
    "query": {
      "filter": {
        "step_id": "user_input",
        "module_name": "save_keywords",
        "category": { "$in": "{{ config.keyword_history.exclusion_categories }}" },
        "source": "generated",
        "$expr": { "$gte": ["$last_used", {"$dateSubtract": {...}}] }
      },
      "fields": ["keyword", "category", "total_weight", "source"],
      "sort": { "total_weight": -1 },
      "limit": 50
    }
  },
  "outputs_to_state": {
    "results": "keyword_query_results_generated"
  }
}
```

**Module: `load_keywords_2` (lines 206-255)** - Same structure but `"source": "selected"`

**Issue:** The keyword history module has a `load` mode, but OMS bypasses it entirely and queries the database directly. This suggests the module's load mode doesn't meet OMS's needs.

### 3.2 Why OMS Bypasses Load Mode

Looking at the LLM prompt (`aesthetic_concepts_generation_user.txt`), OMS needs:

1. **Separate lists** for "critically prohibited" (selected) and "optionally prohibited" (generated)
2. **Weight information** per keyword for priority ranking
3. **Direct control** over the query (custom date filtering, sorting, limits)

The module's `load` mode returns a **single combined list** without weights, which doesn't support OMS's two-tier exclusion system.

### 3.3 Keyword Saving in OMS

**Module: `save_keywords` (lines 402-424)**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save_generated",
    "aesthetics": "{{ state.aesthetic_concepts_response.aesthetic_concepts }}",
    "generated_expiry_days": "{{ config.keyword_history.generated_expiry_days }}"
  }
}
```

This works because OMS's LLM output schema (`aesthetic_concepts_schema.json`) matches the expected structure with `aesthetic_keywords` and `ideas[].idea_keywords`.

### 3.4 Save Selected in OMS

**Module: `update_selected_keywords` (lines 500-526)**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save_selected",
    "aesthetic": "{{ state.aesthetic_concepts_response.aesthetic_concepts[state.selected_concept_indices[1]] }}",
    "idea": "{{ state.aesthetic_concepts_response.aesthetic_concepts[state.selected_concept_indices[1]].ideas[state.selected_concept_indices[2]] }}",
    "target_module_name": "save_keywords"
  }
}
```

**Issue:** Requires complex Jinja2 expression to extract the selected aesthetic and idea from nested array indices.

---

## 4. CC Workflow Analysis (Step 2)

### 4.1 CC Data Structure

CC's LLM output (`scene_concepts_schema.json`) uses a simpler, flat structure:
```json
{
  "scenes": [
    {
      "title": "...",
      "scene_keywords": [
        {"keyword": "...", "category": "...", "weight": 50}
      ]
    }
  ]
}
```

### 4.2 Hack #1: Load Mode Works

CC step 2 actually **uses the load mode** properly:
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "load",
    "source_module_name": "save_scene_keywords",
    ...
  },
  "outputs_to_state": {
    "keyword_exclusion_list": "keyword_exclusion_list"
  }
}
```

This works because CC's prompt (`scene_generation_user.txt`) uses a **single combined list**:
```
{{ state.keyword_exclusion_list | join(', ') }}
```

### 4.3 Hack #2: save_generated Workaround

**Module: `save_scene_keywords` (lines 75-92)**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save_generated",
    "aesthetics": "[{% for scene in state.scene_concepts.scenes %}{\"aesthetic_keywords\": {{ scene.scene_keywords | tojson }}, \"ideas\": []}{% if not loop.last %}, {% endif %}{% endfor %}]"
  }
}
```

**What this hack does:**
1. Takes CC's `scenes[].scene_keywords` structure
2. Transforms it into OMS's expected `aesthetics[].aesthetic_keywords` format using Jinja2
3. Sets `ideas: []` because CC doesn't have the nested idea concept

**Problems:**
- Unreadable inline Jinja2 template
- Fragile string concatenation
- Must fake the OMS structure

### 4.4 Hack #3: save_selected Workaround

**Module: `update_selected_keywords` (lines 156-176)**
```json
{
  "module_id": "history.keyword_history",
  "inputs": {
    "mode": "save_selected",
    "aesthetic": "{\"aesthetic_keywords\": {{ state.selected_scene.scene_keywords | tojson }}}",
    "idea": "{\"idea_keywords\": []}"
  }
}
```

**What this hack does:**
1. Wraps CC's `scene_keywords` in a fake `aesthetic_keywords` wrapper
2. Creates empty `idea_keywords` object

---

## 5. Database Storage (Generic Already!)

The database storage in `database_history.py` is actually **workflow-agnostic**:

```python
def update_keyword(self, workflow_template_name, step_id, module_name,
                   keyword, weight, source, last_used, expires, category, user_id):
    # Stores: keyword, total_weight, last_used, expires, source, category
```

**Key insight:** The database layer stores keywords generically. The problem is only in the module's **input parsing** and **extraction logic**.

---

## 6. Problems Summary

| Problem | Severity | Affected Workflows |
|---------|----------|-------------------|
| Module expects `aesthetics[].aesthetic_keywords` structure | High | CC (requires Jinja2 hack) |
| Module expects `ideas[].idea_keywords` nested structure | High | CC (must fake empty ideas) |
| `load` mode returns single combined list | Medium | OMS (bypasses module entirely) |
| `load` mode doesn't return weights | Medium | OMS (needs weights for two-tier system) |
| `save_selected` requires both `aesthetic` and `idea` | Medium | CC (must fake empty idea) |
| Input names use OMS terminology (`aesthetic`, `idea`) | Low | Confusing for non-OMS workflows |

---

## 7. Proposed Solution

### 7.1 Generic Input Structure

Replace OMS-specific inputs with a generic structure:

**For `save_generated` mode:**
```json
{
  "mode": "save_generated",
  "items": [
    {
      "keywords": [
        {"keyword": "sunny window", "category": "setting", "weight": 80}
      ]
    }
  ],
  "generated_expiry_days": 5
}
```

**For `save_selected` mode:**
```json
{
  "mode": "save_selected",
  "item": {
    "keywords": [
      {"keyword": "sunny window", "category": "setting", "weight": 80}
    ]
  },
  "selected_expiry_days": 10
}
```

<!-- is there specific reason to have above 2 separately? modes like this will simply confuse me and users later unless someone has perfect memory to remember these. module design must be intituve enough to understand whats heppening after few glances. -->

### 7.2 Enhanced Load Mode

Return richer data to support both single-list and two-tier use cases:

```json
{
  "keyword_exclusion_list": ["keyword1", "keyword2"],
  "keywords_by_source": {
    "selected": [
      {"keyword": "...", "weight": 100, "category": "..."}
    ],
    "generated": [
      {"keyword": "...", "weight": 50, "category": "..."}
    ]
  },
  "keyword_stats": {
    "total": 45,
    "selected_count": 15,
    "generated_count": 30
  }
}
```

<!--above is not module config, its data.-->

### 7.3 Backwards Compatibility

Support both old and new input structures during migration:

```python
def _execute_save_generated(self, inputs, context):
    # Try new generic structure first
    items = inputs.get('items')

    # Fall back to legacy OMS structure
    if not items:
        aesthetics = inputs.get('aesthetics', [])
        items = self._convert_legacy_aesthetics(aesthetics)

    # Process items generically
    for item in items:
        for kw_data in item.get('keywords', []):
            # ... save keyword
```

<!-- no need to keep backwards compatibility, we fix this, then update both workflows. -->

---

## 8. Migration Path

### Phase 1: Add Generic Input Support
1. Add `items` and `item` inputs alongside existing inputs
2. Add detection logic to use new or legacy structure
3. Update `load` mode to return `keywords_by_source`
4. Test with both OMS and CC

### Phase 2: Update CC Workflow
1. Update CC step 2 to use new generic structure
2. Remove Jinja2 hacks
3. Verify keyword history works correctly

### Phase 3: Update OMS Workflow
1. Update OMS step 1 to use new generic structure
2. Decide: keep `db.query` for two-tier system OR use enhanced `load` mode
3. Simplify save_selected input expressions

### Phase 4: Deprecate Legacy Inputs
1. Add deprecation warnings for `aesthetics`, `aesthetic`, `idea` inputs
2. Document migration guide
3. Remove legacy support in future version

---

## 9. Questions for Review

1. **Two-tier exclusion system:** Should the module's `load` mode support OMS's two-tier (critically prohibited vs optionally prohibited) pattern, or should OMS continue using `db.query` for that flexibility?
<!--db.query is a huge risk which was added as hack and debugging module, that module never meant to be used by actual users, it meant for my personal use only if ever needed. -->

2. **Weight aggregation:** When loading keywords, should weights be summed across multiple saves or use the latest weight?
<!-- i assume that keywords weights are accumulated over time, please check and add how keywords are managed in to the doc so I can see where it is now -->

3. **Category filtering in load mode:** Should `exclusion_categories` filtering happen in the module or let workflows filter in their prompts?
<!--lets module handle it. i also noticed that there are global configs for this, i want to entertain the idea of containing it in module itself rather than having global settings. -->

4. **Keyword field name:** The proposal uses `keywords` as the field name. Should we support configurable field names for maximum flexibility?
   ```json
   {
     "items": "{{ state.scenes }}",
     "keywords_field": "scene_keywords"
   }
   ```

<!--lets come back to above once we finalyze actual  module structure-->

5. **Nested keywords:** OMS has two levels (aesthetic_keywords + idea_keywords). Should the generic structure support nested keyword groups, or should OMS flatten them before calling the module?
<!--i dont think this module should worry about nested data. it only works with flat data. data provider is resposible to flatten data for the module. there's enough tooling to do that without too much hassle. -->

---

## 10. Files to Modify

| File | Changes |
|------|---------|
| `server/modules/history/keyword_history.py` | Add generic inputs, backwards compat |
| `workflows/cc/steps/2_scene_generation/step.json` | Remove Jinja2 hacks, use new structure |
| `workflows/oms/steps/1_user_input/step.json` | Optionally update to new structure |
| `TECHNICAL_DEBT.md` | Update or close item #9 |

---

## 11. Appendix: Current Code References

### keyword_history.py - save_generated (lines 297-355)
```python
for aesthetic in aesthetics:
    for kw_data in aesthetic.get('aesthetic_keywords', []):
        # ... save keyword
    for idea in aesthetic.get('ideas', []):
        for kw_data in idea.get('idea_keywords', []):
            # ... save keyword
```

### keyword_history.py - save_selected (lines 357-428)
```python
for kw_data in aesthetic.get('aesthetic_keywords', []):
    # ... update keyword
for kw_data in idea.get('idea_keywords', []):
    # ... update keyword
```

### CC Hack - save_generated (step.json line 86)
```json
"aesthetics": "[{% for scene in state.scene_concepts.scenes %}{\"aesthetic_keywords\": {{ scene.scene_keywords | tojson }}, \"ideas\": []}{% if not loop.last %}, {% endif %}{% endfor %}]"
```

### CC Hack - save_selected (step.json lines 168-169)
```json
"aesthetic": "{\"aesthetic_keywords\": {{ state.selected_scene.scene_keywords | tojson }}}",
"idea": "{\"idea_keywords\": []}"
```
