# Schema-Driven Media Display Architecture (Revision 3)

## Summary

This revision addresses operator feedback on r2:
1. **Input layout proposal** - how to define layout for inputs in schema
2. **Compound render_as extraction** - use existing SchemaRenderer pattern correctly
3. **Input type routing** - belongs in TerminalRenderer (inputs are terminal nodes)
4. **InputContext management** - InputSchemaRenderer creates context, parent accesses for validation
5. **Focus** - only fix input_schema first, don't touch other media components
6. **No backward compatibility** - can break existing schemas

---

## Problem Statement

### Current Architecture

```
MediaPanel (render_as: "media")
    ├── ParameterField (custom mini-router for inputs)
    │       ↓
    │   Input Renderers (Select, Slider, Textarea)
    │
    └── Hardcoded layout: grid grid-cols-2 sm:grid-cols-3 gap-4
```

### Issues

1. **ParameterField duplicates schema routing** - should use TerminalRenderer
2. **Layout is hardcoded** - `grid-cols-2 sm:grid-cols-3` in JSX, not schema-driven
3. **Special cases in code** - `_text` field gets `col-span-full` via code check

---

## Proposal 1: Input Layout Definition

### Current Hardcoding

```tsx
// MediaPanel.tsx:313
<div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
  {parameterKeys.map((key) => (
    <ParameterField ... />
  ))}
</div>

// MediaPanel.tsx:459 - special case
if (fieldKey === "_text") {
  return <div className="col-span-full">...</div>;
}
```

### Proposed Schema-Driven Layout

Add `_ux.layout` configuration to `input_schema`:

```json
"input_schema": {
  "type": "object",
  "_ux": {
    "layout": "grid",
    "layout_columns": 3,
    "layout_columns_sm": 2,
    "layout_gap": 4
  },
  "properties": {
    "sampler_combo": {
      "type": "string",
      "title": "Sampler",
      "_ux": {
        "input_type": "select",
        "col_span": 1
      }
    },
    "resolution": {
      "type": "string",
      "title": "Resolution",
      "_ux": {
        "input_type": "select",
        "col_span": 1
      }
    },
    "prompt": {
      "type": "string",
      "title": "Prompt",
      "_ux": {
        "input_type": "textarea",
        "col_span": "full"
      }
    }
  }
}
```

### Layout UX Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `layout` | `"grid" \| "flex" \| "stack"` | `"grid"` | Container layout mode |
| `layout_columns` | `number` | `3` | Grid columns (default/lg) |
| `layout_columns_sm` | `number` | `2` | Grid columns on small screens |
| `layout_gap` | `number` | `4` | Gap between items (Tailwind scale) |

### Item UX Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `col_span` | `number \| "full"` | `1` | Columns to span in grid |
| `row_span` | `number` | `1` | Rows to span in grid |
| `order` | `number` | - | Display order override |

### InputSchemaRenderer Layout Implementation

```tsx
function InputSchemaRenderer({ schema, path }: Props) {
  const ux = getUx(schema);
  const properties = schema.properties || {};

  // Extract layout config with defaults
  const layout = ux.layout || "grid";
  const columns = ux.layout_columns || 3;
  const columnsSm = ux.layout_columns_sm || 2;
  const gap = ux.layout_gap || 4;

  // Build Tailwind classes
  const layoutClass = layout === "grid"
    ? `grid grid-cols-${columnsSm} sm:grid-cols-${columns} gap-${gap}`
    : layout === "stack"
    ? `flex flex-col gap-${gap}`
    : `flex flex-wrap gap-${gap}`;

  return (
    <InputContext.Provider value={inputContext}>
      <div className={layoutClass}>
        {Object.entries(properties).map(([key, fieldSchema]) => {
          const fieldUx = getUx(fieldSchema);
          const colSpan = fieldUx.col_span;

          // Build item classes
          const itemClass = colSpan === "full"
            ? "col-span-full"
            : colSpan
            ? `col-span-${colSpan}`
            : "";

          return (
            <div key={key} className={itemClass}>
              <SchemaRenderer
                schema={fieldSchema}
                <!--they can have initial data, which can be defined in its
                normal schema counterpart. for example, lets say there's field
                in normal schema called "name", which means data for this node
                has "name" field. In the schema, in the normal properties, one
                can "name" is display=hidden, and add "name" node under
                properties of input_schema, in this case, data for that input
                is name under data.-->
                data={undefined}  // Inputs don't have initial data
                path={[...path, key]}
              />
            </div>
          );
        })}
      </div>
    </InputContext.Provider>
  );
}
```

---

## Proposal 2: Compound Render_as Extraction

### Existing Pattern (SchemaRenderer.tsx:95-114)

```tsx
if (ux.render_as && ux.render_as.includes(".")) {
  const dotIndex = ux.render_as.indexOf(".");
  const outerRenderAs = ux.render_as.slice(0, dotIndex);
  const innerRenderAs = ux.render_as.slice(dotIndex + 1);

  return (
    <SchemaRenderer
      schema={schema}
      data={data}
      path={path}
      ux={{ ...ux, render_as: outerRenderAs }}
    >
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={{ ...ux, render_as: innerRenderAs }}
      />
    </SchemaRenderer>
  );
}
```

### How input_schema Fits In

When SchemaRenderer sees `input_schema` in UX config AND compound `render_as`:

1. **First pass**: Compound splitting happens (outer wraps inner)
2. **Inner renderer**: When `render_as: "media"` executes, it checks for `input_schema`
3. **MediaPanel receives**: Schema with `input_schema` already present in UX

The input_schema handling should happen **inside the special renderer**, not in SchemaRenderer:

```tsx
// MediaPanel.tsx (simplified)
function MediaPanel({ data, schema, path, ux }: Props) {
  const inputSchema = ux.input_schema;

  return (
    <div className="media-panel">
      {/* InputSchemaRenderer handles the inputs */}
      {inputSchema && (
        <InputSchemaRenderer
          schema={inputSchema}
          path={[...path, '_inputs']}
        />
      )}

      {/* MediaGrid and buttons rendered by MediaPanel */}
      <MediaGrid ... />
      <Button>Generate</Button>
    </div>
  );
}
```

<!--abouve is 100% wrong, didnt you see in my example data SchemaRenderer
render the InputSchemaRenderer? why you suddenly decide to change that? did my
suggestion asked to implenment it lik this?-->

This approach:
- Keeps compound render_as handling unchanged in SchemaRenderer
- MediaPanel (special renderer for `render_as: "media"`) checks for and renders `input_schema`
- No modification to SchemaRenderer's core routing logic

---

## Proposal 3: Input Type Routing in TerminalRenderer

### Rationale

Inputs are **terminal nodes** (leaf values that render to editable controls). TerminalRenderer already routes by `render_as` for display types (`text`, `color`, `url`, etc.). Input types follow the same pattern.

### Current TerminalRenderer Switch

```tsx
switch (renderAs) {
  case "text": return <TextRenderer ... />;
  case "color": return <ColorRenderer ... />;
  case "url": return <UrlRenderer ... />;
  case "datetime": return <DateTimeRenderer ... />;
  case "number": return <NumberRenderer ... />;
  case "image": return <ImageRenderer ... />;
  default: return <TextRenderer ... />;
}
```

### Extended with Input Types

```tsx
function TerminalRenderer({ fieldKey, value, path, data, schema, ux }: Props) {
  const renderAs = ux.render_as || "text";
  const inputType = ux.input_type;

  // Handle null/undefined for display types
  if (value === null || value === undefined) {
    // For input types, still render (they manage their own state)
    if (!inputType) {
      return null;
    }
  }

  // Input types - editable controls
  if (inputType) {
    switch (inputType) {
      case "select":
        return <SelectInputRenderer schema={schema} path={path} ux={ux} />;
      case "slider":
        return <SliderInputRenderer schema={schema} path={path} ux={ux} />;
      case "textarea":
        return <TextareaInputRenderer schema={schema} path={path} ux={ux} />;
      case "text":
        return <TextInputRenderer schema={schema} path={path} ux={ux} />;
      case "checkbox":
        return <CheckboxInputRenderer schema={schema} path={path} ux={ux} />;
      default:
        return <TextInputRenderer schema={schema} path={path} ux={ux} />;
    }
  }

  // Display types - read-only rendering
  switch (renderAs) {
    case "text": return <TextRenderer ... />;
    case "color": return <ColorRenderer ... />;
    // ... existing cases
  }
}
```

### Key Distinction

| Category | UX Property | Purpose | Example |
|----------|-------------|---------|---------|
| Display types | `render_as` | Read-only rendering | `"text"`, `"color"`, `"image"` |
| Input types | `input_type` | Editable controls | `"select"`, `"slider"`, `"textarea"` |

---

## Proposal 4: InputContext Management and Validation

### InputContext Ownership

**InputSchemaRenderer creates and provides InputContext:**

```tsx
function InputSchemaRenderer({ schema, path }: Props) {
  const [values, setValues] = useState<Record<string, unknown>>({});
  const [errors, setErrors] = useState<Record<string, string>>({});

  const inputContext = useMemo(() => ({
    values,
    getValue: (key: string) => values[key],
    setValue: (key: string, value: unknown) => {
      setValues(prev => ({ ...prev, [key]: value }));
      // Clear error on change
      if (errors[key]) {
        setErrors(prev => {
          const { [key]: _, ...rest } = prev;
          return rest;
        });
      }
    },
    errors,
    setError: (key: string, error: string) => {
      setErrors(prev => ({ ...prev, [key]: error }));
    },
    clearErrors: () => setErrors({}),
  }), [values, errors]);

  return (
    <InputContext.Provider value={inputContext}>
      {/* render inputs */}
    </InputContext.Provider>
  );
}
```

### Parent Access for Validation

**Option A: Ref-based access**

```tsx
function MediaPanel({ ... }: Props) {
  const inputRef = useRef<InputSchemaHandle>(null);

  const handleGenerate = () => {
    const ctx = inputRef.current;
    if (!ctx) return;

    // Get values
    const params = ctx.getValues();

    // Validate
    const validationErrors = validateInputs(params, inputSchema);
    if (validationErrors.length > 0) {
      validationErrors.forEach(e => ctx.setError(e.field, e.message));
      return;
    }

    // Execute action
    executeSubAction(path, action, params);
  };

  return (
    <>
      <InputSchemaRenderer ref={inputRef} schema={inputSchema} path={path} />
      <Button onClick={handleGenerate}>Generate</Button>
    </>
  );
}
```

**Option B: Callback-based access**

```tsx
<InputSchemaRenderer
  schema={inputSchema}
  path={path}
  onValuesChange={(values) => setInputValues(values)}
/>
```

### Validation Flow

```
1. User clicks "Generate" button
2. MediaPanel calls inputRef.current.getValues()
3. MediaPanel validates using input_schema (required fields, ranges, etc.)
4. If errors: MediaPanel calls inputRef.current.setError(field, message)
5. If valid: MediaPanel executes generation action
```

---

## Implementation Plan

### Phase 1: InputSchemaRenderer (Focus: Input Schema Only)

| Step | File | Change |
|------|------|--------|
| 1 | `schema-interaction/InputSchemaRenderer.tsx` | **New** - Create component with InputContext |
| 2 | `schema-interaction/renderers/TerminalRenderer.tsx` | Add `input_type` routing |
| 3 | `media-generation/MediaPanel.tsx` | Use InputSchemaRenderer, remove ParameterField |
| 4 | `schema-interaction/types.ts` | Add layout UX types |

### Files NOT Modified (Phase 1)

- MediaGrid.tsx - unchanged
- MediaPromptPanel.tsx - unchanged (has separate ParameterField copy)
- SchemaRenderer.tsx - unchanged (compound handling already works)

---

## Schema Example

### Before (Current)

```json
{
  "_ux": {
    "render_as": "tab.media",
    "provider": "stable_diffusion",
    "input_schema": {
      "type": "object",
      "properties": {
        "sampler_combo": { "type": "string", "title": "Sampler", "_ux": { "input_type": "select" } },
        "resolution": { "type": "string", "title": "Resolution", "_ux": { "input_type": "select" } }
      }
    }
  }
}
```

### After (With Layout)

```json
{
  "_ux": {
    "render_as": "tab.media",
    "provider": "stable_diffusion",
    "input_schema": {
      "type": "object",
      "_ux": {
        "layout": "grid",
        "layout_columns": 3,
        "layout_columns_sm": 2,
        "layout_gap": 4
      },
      "properties": {
        "sampler_combo": {
          "type": "string",
          "title": "Sampler",
          "_ux": { "input_type": "select", "col_span": 1 }
        },
        "resolution": {
          "type": "string",
          "title": "Resolution",
          "_ux": { "input_type": "select", "col_span": 1 }
        },
        "prompt": {
          "type": "string",
          "title": "Prompt",
          "_ux": { "input_type": "textarea", "col_span": "full" }
        }
      }
    }
  }
}
```

---

## Questions for Review

1. **Layout approach**: Is the grid-based `layout_columns` / `col_span` approach acceptable, or would you prefer a different layout system?
<!--yeah, that works.-->

2. **Ref vs Callback**: For parent validation access, prefer ref-based
   (`inputRef.current.getValues()`) or callback-based (`onValuesChange`)?
   <!--arent there better way to do this? both these doesnt seems like proper
   way to it. ref is always lead to mess and callbacks are not recommented in
   react afaik-->

3. **Default values**: Should InputSchemaRenderer initialize values from
   `schema.default` properties, or leave that to individual input renderers?
   <--added note in that section, we can have default input_schema, and its
   used when there's no map for the field in data-->
