# Schema-Driven Media Display Architecture (Revision 5)

## Summary

This revision addresses operator feedback on r4:
1. **Rename component** - `InputSchemaComposer` (clearer purpose)
2. **Move InputSchemaContext provider inside** - everything contained in one place
3. **Remove extractInputData** - data is 1:1 map, pass directly
4. **Fix children pattern** - InputSchemaComposer renders components directly, not via children
5. **Rename to InputSchemaContext** - consistent with InputSchemaRenderer
6. **Both error displays** - red border on input + detailed message from caller
7. **Remove isDirty** - not needed right now

---

## Core Architecture

### Component Tree

```
SchemaRenderer (detects input_schema in UX)
    │
    └── InputSchemaComposer (new component)
        │
        └── InputSchemaContext.Provider
            │
            ├── InputSchemaRenderer (renders input controls)
            │   ├── SelectInputRenderer (red border on error)
            │   ├── SliderInputRenderer (red border on error)
            │   └── TextareaInputRenderer (red border on error)
            │
            └── SchemaRenderer (remaining schema, no input_schema)
                └── MediaPanel (grid + button, shows error messages)
```

### SchemaRenderer Enhancement

```tsx
function SchemaRenderer({ data, schema, path, ux: uxProp, children }: Props) {
  const ux = uxProp ?? getUx(schema);

  // Detect input_schema and delegate to InputSchemaComposer
  if (ux.input_schema) {
    return (
      <InputSchemaComposer
        data={data}
        schema={schema}
        path={path}
        ux={ux}
      />
    );
  }

  // Continue with existing routing...
}
```

### InputSchemaComposer (New Component)

This component is an **extension to SchemaRenderer** - created for clarity to handle the `input_schema` case. It:
1. Provides `InputSchemaContext`
2. Renders `InputSchemaRenderer` for inputs
3. Renders remaining schema via `SchemaRenderer`
4. Handles compound `render_as` composition

```tsx
interface InputSchemaComposerProps {
  data: unknown;
  schema: SchemaProperty;
  path: string[];
  ux: UxConfig;
}

function InputSchemaComposer({ data, schema, path, ux }: InputSchemaComposerProps) {
  const inputSchema = ux.input_schema;

  // Initialize context state
  const [values, setValues] = useState<Record<string, unknown>>(() => {
    const initial: Record<string, unknown> = {};
    const properties = inputSchema.properties || {};
    const dataRecord = (data || {}) as Record<string, unknown>;

    for (const [key, fieldSchema] of Object.entries(properties)) {
      // Value priority: data[key] → schema.default → undefined
      initial[key] = dataRecord[key] ?? fieldSchema.default;
    }
    return initial;
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  const contextValue = useMemo<InputSchemaContextValue>(() => ({
    values,
    getValue: (key) => values[key],
    setValue: (key, value) => {
      setValues(prev => ({ ...prev, [key]: value }));
      // Clear error when value changes
      if (errors[key]) {
        setErrors(prev => {
          const { [key]: _, ...rest } = prev;
          return rest;
        });
      }
    },

    errors,
    setError: (key, error) => {
      setErrors(prev => ({ ...prev, [key]: error }));
    },
    clearError: (key) => {
      setErrors(prev => {
        const { [key]: _, ...rest } = prev;
        return rest;
      });
    },
    clearAllErrors: () => setErrors({}),

    isValid: Object.keys(errors).length === 0,
    inputSchema,
  }), [values, errors, inputSchema]);

  // Create UX without input_schema for remaining content
  const remainingUx = { ...ux, input_schema: undefined };

  // Render InputSchemaRenderer - data passed directly (1:1 map)
  const inputComponent = (
    <InputSchemaRenderer
      schema={inputSchema}
      data={data as Record<string, unknown>}
      path={[...path, '_inputs']}
    />
  );

  // Handle compound render_as (e.g., tab.media)
  if (ux.render_as?.includes('.')) {
    const dotIndex = ux.render_as.indexOf('.');
    const outerRenderAs = ux.render_as.slice(0, dotIndex);
    const innerRenderAs = ux.render_as.slice(dotIndex + 1);

    // Outer wraps both input and inner content
    return (
      <InputSchemaContext.Provider value={contextValue}>
        <SchemaRenderer
          schema={schema}
          data={data}
          path={path}
          ux={{ ...remainingUx, render_as: outerRenderAs }}
        >
          <>
            {inputComponent}
            <SchemaRenderer
              schema={schema}
              data={data}
              path={path}
              ux={{ ...remainingUx, render_as: innerRenderAs }}
            />
          </>
        </SchemaRenderer>
      </InputSchemaContext.Provider>
    );
  }

  // Simple render_as - fragment composition
  return (
    <InputSchemaContext.Provider value={contextValue}>
      {inputComponent}
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={remainingUx}
      />
    </InputSchemaContext.Provider>
  );
}
```

---

## InputSchemaContext

### Context Definition

```tsx
interface InputSchemaContextValue {
  // Values management
  values: Record<string, unknown>;
  getValue: (key: string) => unknown;
  setValue: (key: string, value: unknown) => void;

  // Validation errors
  errors: Record<string, string>;
  setError: (key: string, error: string) => void;
  clearError: (key: string) => void;
  clearAllErrors: () => void;

  // State
  isValid: boolean;

  // Schema reference (for validation rules)
  inputSchema: InputSchema;
}

const InputSchemaContext = createContext<InputSchemaContextValue | null>(null);

// Required hook - throws if no context
function useInputSchema() {
  const ctx = useContext(InputSchemaContext);
  if (!ctx) {
    throw new Error("useInputSchema must be used within InputSchemaComposer");
  }
  return ctx;
}

// Optional hook - returns null if no context
function useInputSchemaOptional() {
  return useContext(InputSchemaContext);
}
```

---

## InputSchemaRenderer

Renders input fields with schema-driven layout. Data is passed directly (1:1 map with input_schema).

```tsx
interface InputSchemaRendererProps {
  schema: InputSchema;
  data: Record<string, unknown>;  // 1:1 map, no extraction needed
  path: string[];
}

function InputSchemaRenderer({ schema, data, path }: InputSchemaRendererProps) {
  const properties = schema.properties || {};
  const ux = getUx(schema);

  // Layout configuration
  const layout = ux.layout || "grid";
  const columns = ux.layout_columns || 3;
  const columnsSm = ux.layout_columns_sm || 2;
  const gap = ux.layout_gap || 4;

  const layoutClass = layout === "grid"
    ? `grid grid-cols-${columnsSm} sm:grid-cols-${columns} gap-${gap}`
    : layout === "stack"
    ? `flex flex-col gap-${gap}`
    : `flex flex-wrap gap-${gap}`;

  return (
    <div className={layoutClass}>
      {Object.entries(properties).map(([key, fieldSchema]) => {
        const fieldUx = getUx(fieldSchema);
        const colSpan = fieldUx.col_span;

        // Initial value: data[key] if exists, otherwise schema.default
        // (Context initialization already handled this, but we pass for
        // TerminalRenderer to have initial value available)
        const initialValue = data?.[key] ?? fieldSchema.default;

        const itemClass = colSpan === "full"
          ? "col-span-full"
          : colSpan
          ? `col-span-${colSpan}`
          : "";

        return (
          <div key={key} className={itemClass}>
            <SchemaRenderer
              schema={fieldSchema}
              data={initialValue}
              path={[...path, key]}
            />
          </div>
        );
      })}
    </div>
  );
}
```

---

## Error Display Pattern

### Both Locations

1. **Input renderer** - Shows red border on control when error exists
2. **Caller (MediaPanel)** - Shows detailed error message text

### Input Renderer Error Styling

```tsx
function SelectInputRenderer({ schema, path, ux }: Props) {
  const inputSchema = useInputSchema();
  const fieldKey = path[path.length - 1];

  const value = inputSchema.getValue(fieldKey);
  const error = inputSchema.errors[fieldKey];
  const hasError = !!error;

  const handleChange = (newValue: string) => {
    inputSchema.setValue(fieldKey, newValue);
  };

  return (
    <div className="space-y-1">
      <label className="text-sm font-medium">{ux.display_label || schema.title}</label>
      <Select
        value={value as string}
        onValueChange={handleChange}
        // Red border when error
        className={hasError ? "border-destructive" : ""}
      >
        {/* options */}
      </Select>
      {/* No error text here - caller shows detailed message */}
    </div>
  );
}
```

### MediaPanel Error Display

```tsx
function MediaPanel({ data, schema, path, ux }: Props) {
  const inputSchema = useInputSchemaOptional();

  const handleGenerate = () => {
    if (!inputSchema) return;

    // Validate
    const validationErrors = validateInputs(inputSchema.values, inputSchema.inputSchema);

    if (validationErrors.length > 0) {
      validationErrors.forEach(e => inputSchema.setError(e.field, e.message));
      return;
    }

    inputSchema.clearAllErrors();
    executeSubAction(path, action, inputSchema.values, { provider, promptId });
  };

  // Collect error messages for display
  const errorMessages = inputSchema
    ? Object.entries(inputSchema.errors).map(([field, message]) => ({ field, message }))
    : [];

  return (
    <div className="media-panel">
      <MediaGrid ... />

      {/* Detailed error messages */}
      {errorMessages.length > 0 && (
        <div className="text-sm text-destructive space-y-1">
          {errorMessages.map(({ field, message }) => (
            <div key={field}>{message}</div>
          ))}
        </div>
      )}

      <Button onClick={handleGenerate} disabled={loading}>
        Generate
      </Button>
    </div>
  );
}
```

---

## Input Type Routing in TerminalRenderer

```tsx
function TerminalRenderer({ fieldKey, value, path, data, schema, ux }: Props) {
  const renderAs = ux.render_as || "text";
  const inputType = ux.input_type;

  // For input types, render even if value is null/undefined
  // (they manage their own state via context)
  if (value === null || value === undefined) {
    if (!inputType) {
      return null;
    }
  }

  // Input types - editable controls
  if (inputType) {
    switch (inputType) {
      case "select":
        return <SelectInputRenderer schema={schema} path={path} ux={ux} />;
      case "slider":
        return <SliderInputRenderer schema={schema} path={path} ux={ux} />;
      case "textarea":
        return <TextareaInputRenderer schema={schema} path={path} ux={ux} />;
      case "text":
        return <TextInputRenderer schema={schema} path={path} ux={ux} />;
      case "checkbox":
        return <CheckboxInputRenderer schema={schema} path={path} ux={ux} />;
      default:
        return <TextInputRenderer schema={schema} path={path} ux={ux} />;
    }
  }

  // Display types - read-only rendering (existing switch)
  switch (renderAs) {
    case "text": return <TextRenderer ... />;
    case "color": return <ColorRenderer ... />;
    case "url": return <UrlRenderer ... />;
    case "datetime": return <DateTimeRenderer ... />;
    case "number": return <NumberRenderer ... />;
    case "image": return <ImageRenderer ... />;
    default: return <TextRenderer ... />;
  }
}
```

---

## Layout System

### Container Level (`input_schema._ux`)

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `layout` | `"grid" \| "flex" \| "stack"` | `"grid"` | Container layout mode |
| `layout_columns` | `number` | `3` | Grid columns (default/lg) |
| `layout_columns_sm` | `number` | `2` | Grid columns on small screens |
| `layout_gap` | `number` | `4` | Gap between items (Tailwind scale) |

### Item Level (`input_schema.properties[key]._ux`)

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `col_span` | `number \| "full"` | `1` | Columns to span in grid |
| `row_span` | `number` | `1` | Rows to span in grid |
| `order` | `number` | - | Display order override |

---

## Detailed Plan of Action (POA)

### Phase 1: Foundation (Context & Types)

#### 1.1 Create InputSchemaContext
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/InputSchemaContext.tsx`

- [x] Create `InputSchemaContextValue` interface
  - [x] `values: Record<string, unknown>`
  - [x] `getValue(key: string): unknown`
  - [x] `setValue(key: string, value: unknown): void`
  - [x] `errors: Record<string, string>`
  - [x] `setError(key: string, error: string): void`
  - [x] `clearError(key: string): void`
  - [x] `clearAllErrors(): void`
  - [x] `isValid: boolean`
  - [x] `inputSchema: InputSchema`
- [x] Create `InputSchemaContext` with `createContext<InputSchemaContextValue | null>(null)`
- [x] Create `useInputSchema()` hook (throws if no context)
- [x] Create `useInputSchemaOptional()` hook (returns null if no context)
- [x] Export context and hooks

#### 1.2 Add Types to types.ts
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/types.ts`

- [x] Add `InputSchemaConfig` type (object schema with properties)
- [x] Add layout UX types to `UxConfig`:
  - [x] `layout?: "grid" | "flex" | "stack"` (as LayoutMode)
  - [x] `layout_columns?: number`
  - [x] `layout_columns_sm?: number`
  - [x] `layout_gap?: number`
- [x] Add item UX types:
  - [x] `col_span?: number | "full"`
  - [x] `row_span?: number`
  - [x] `order?: number`
- [x] Add `InputType` type: `"select" | "slider" | "textarea" | "text" | "checkbox"`
- [x] Update `input_schema` to use `InputSchemaConfig` type

---

### Phase 2: New Components

#### 2.1 Create InputSchemaRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/InputSchemaRenderer.tsx`

- [x] Create `InputSchemaRendererProps` interface
  - [x] `schema: InputSchema`
  - [x] `data: Record<string, unknown>`
  - [x] `path: string[]`
- [x] Implement layout class generation:
  - [x] Extract `layout`, `layout_columns`, `layout_columns_sm`, `layout_gap` from schema UX
  - [x] Build inline styles for grid/flex/stack layouts (dynamic values)
- [x] Implement property iteration:
  - [x] Loop over `schema.properties`
  - [x] Extract `col_span` for each field
  - [x] Build item styles (gridColumn for span)
  - [x] Render `SchemaRenderer` for each field with `data[key]` as initial value
- [x] Export component

#### 2.2 Create InputSchemaComposer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/InputSchemaComposer.tsx`

- [x] Create `InputSchemaComposerProps` interface
  - [x] `data: unknown`
  - [x] `schema: SchemaProperty`
  - [x] `path: string[]`
  - [x] `ux: UxConfig`
- [x] Implement state initialization:
  - [x] Initialize `values` from `data[key] ?? schema.default`
  - [x] Initialize `errors` as empty object
- [x] Create context value with `useMemo`:
  - [x] Implement `getValue`, `setValue`
  - [x] Implement `setError`, `clearError`, `clearAllErrors`
  - [x] Compute `isValid` from errors
- [x] Create `remainingUx` (ux without input_schema)
- [x] Create `inputComponent` (InputSchemaRenderer)
- [x] Handle compound `render_as` (e.g., `tab.media`):
  - [x] Split at first dot
  - [x] Wrap with outer SchemaRenderer, pass inner + inputComponent as children
- [x] Handle simple `render_as`:
  - [x] Return fragment with inputComponent + remaining SchemaRenderer
- [x] Wrap everything in `InputSchemaContext.Provider`
- [x] Export component

---

### Phase 3: Modify Existing Components

#### 3.1 Update SchemaRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/SchemaRenderer.tsx`

- [x] Import `InputSchemaComposer`
- [x] Add `input_schema` detection BEFORE compound render_as handling:
  ```tsx
  if (ux.input_schema) {
    return <InputSchemaComposer data={data} schema={schema} path={path} ux={ux} />;
  }
  ```
- [ ] Verify existing routing still works

#### 3.2 Update TerminalRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/renderers/TerminalRenderer.tsx`

- [x] Import input renderers (SelectInputRenderer, SliderInputRenderer, TextareaInputRenderer)
- [x] Modify null/undefined handling to allow input types to render
- [x] Add `input_type` routing BEFORE display type routing:
  ```tsx
  if (inputType) {
    switch (inputType) {
      case "select": return <SelectInputRenderer ... />;
      case "slider": return <SliderInputRenderer ... />;
      case "textarea": return <TextareaInputRenderer ... />;
      case "text": return <TextInputRenderer ... />;
      default: return <TextInputRenderer ... />;
    }
  }
  ```

#### 3.3 Update SelectInputRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/renderers/SelectInputRenderer.tsx`

- [x] Import `useInputSchemaOptional`
- [x] Get field key from path: `path[path.length - 1]`
- [x] Get value from context: try InputSchemaContext first, fall back to InputContext
- [x] Get error from context: `inputSchemaContext?.errors[fieldKey]`
- [x] Update `onChange` to use context: try InputSchemaContext first
- [x] Error styling already present (red border when `hasError`)
- [x] Backward compatibility maintained (works with or without context)

#### 3.4 Update SliderInputRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/renderers/SliderInputRenderer.tsx`

- [x] Import `useInputSchemaOptional`
- [x] Get field key from path
- [x] Get value from context (fallback to prop value)
- [x] Get error from context
- [x] Update `onChange` to use context
- [x] Error styling already present

#### 3.5 Update TextareaInputRenderer
**File:** `ui/webui/src/components/workflow/interactions/schema-interaction/renderers/TextareaInputRenderer.tsx`

- [x] Import `useInputSchemaOptional`
- [x] Get field key from path
- [x] Get value from context (fallback to prop value)
- [x] Get error from context
- [x] Update `onChange` to use context
- [x] Error styling already present

---

### Phase 4: MediaPanel Integration

#### 4.1 Update MediaPanel
**File:** `ui/webui/src/components/workflow/interactions/media-generation/MediaPanel.tsx`

- [x] Import `useInputSchemaOptional`
- [ ] Remove `ParameterField` component (keeping for backward compatibility)
- [x] Conditionally render parameters only when InputSchemaContext NOT available (legacy path)
- [x] Add context usage in `handleGenerate`:
  - [x] Get `inputSchemaContext` from `useInputSchemaOptional()`
  - [x] Get values: `inputSchemaContext.values`
  - [x] Validate using input schema
  - [x] Set errors: `inputSchemaContext.setError(field, message)` (shows red border)
  - [x] Clear errors before validation: `inputSchemaContext.clearAllErrors()`
  - [x] Pass values to `executeSubAction`
- [x] Error messages already displayed via validationErrors state
- [x] MediaGrid unchanged
- [x] Button rendering unchanged (validation logic updated)

---

### Phase 5: Testing & Verification

#### 5.1 Manual Testing
- [ ] Test with existing media generation workflow
- [ ] Verify inputs render with correct initial values from data
- [ ] Verify inputs render with schema defaults when no data
- [ ] Verify layout (grid columns, col_span) works correctly
- [ ] Verify error display (red border on input)
- [ ] Verify error messages in MediaPanel
- [ ] Verify validation on Generate button click
- [ ] Verify compound render_as (tab.media) works
- [ ] Verify simple render_as works

#### 5.2 Edge Cases
- [ ] Test with empty data object
- [ ] Test with missing schema defaults
- [ ] Test with all fields having errors
- [ ] Test clearing errors on value change

---

### Files Summary

| Status | File | Type |
|--------|------|------|
| [x] | `schema-interaction/InputSchemaContext.tsx` | **New** |
| [x] | `schema-interaction/InputSchemaComposer.tsx` | **New** |
| [x] | `schema-interaction/InputSchemaRenderer.tsx` | **New** |
| [x] | `schema-interaction/SchemaRenderer.tsx` | Modify |
| [x] | `schema-interaction/renderers/TerminalRenderer.tsx` | Modify |
| [x] | `schema-interaction/renderers/SelectInputRenderer.tsx` | Modify |
| [x] | `schema-interaction/renderers/SliderInputRenderer.tsx` | Modify |
| [x] | `schema-interaction/renderers/TextareaInputRenderer.tsx` | Modify |
| [x] | `media-generation/MediaPanel.tsx` | Modify |
| [x] | `schema-interaction/types.ts` | Modify |

### Files NOT Modified

- MediaGrid.tsx - unchanged
- MediaPromptPanel.tsx - unchanged (has separate ParameterField copy, can update later)

---

## Schema Example

```json
{
  "type": "object",
  "_ux": {
    "render_as": "tab.media",
    "provider": "stable_diffusion",
    "input_schema": {
      "type": "object",
      "_ux": {
        "layout": "grid",
        "layout_columns": 3,
        "layout_columns_sm": 2,
        "layout_gap": 4
      },
      "properties": {
        "sampler_combo": {
          "type": "string",
          "title": "Sampler",
          "_ux": { "input_type": "select", "col_span": 1 }
        },
        "resolution": {
          "type": "string",
          "title": "Resolution",
          "_ux": { "input_type": "select", "col_span": 1 }
        },
        "prompt": {
          "type": "string",
          "title": "Prompt",
          "_ux": { "input_type": "textarea", "col_span": "full" }
        }
      }
    }
  },
  "properties": {
    "sampler_combo": {
      "type": "string",
      "_ux": { "display": "hidden" }
    },
    "resolution": {
      "type": "string",
      "_ux": { "display": "hidden" }
    },
    "style_notes": {
      "type": "string",
      "_ux": { "display": true, "highlight": true }
    }
  }
}
```

With data:
```json
{
  "sampler_combo": "euler_a",
  "resolution": "1024x1024",
  "style_notes": "cinematic lighting"
}
```

Result:
- `sampler_combo` input: initial value "euler_a" (from data)
- `resolution` input: initial value "1024x1024" (from data)
- `prompt` input: initial value from schema.default or undefined
- `style_notes`: rendered as highlighted text (not an input)
