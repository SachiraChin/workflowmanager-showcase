# Schema-Driven Media Display Architecture (Revision 4)

## Summary

This revision corrects r3 based on operator feedback:
1. **SchemaRenderer renders InputSchemaRenderer** - NOT MediaPanel (corrected from r3)
2. **Inputs can have initial data** - from `data[fieldKey]` when field in both normal schema and input_schema
3. **Shared context for validation** - no refs or callbacks, proper React pattern
4. **Layout approach accepted** - grid with `layout_columns` / `col_span`

---

## Core Architecture: SchemaRenderer Handles input_schema

### Operator's Original Design (r1)

```tsx
const SchemaRenderer = (schema, ...) => {
    if (schema.input_schema) {
        const isc = <InputSchemaRenderer schema={schema.input_schema} />
        const cmp = <SchemaRenderer schema={...schema, input_schema: undefined}/>

        if (schema.render_as like '*.*') {
            return <firstPart>{isc}{cmp}</firstPart>
        } else {
            return <>{isc}{cmp}</>
        }
    }
}
```

### Resulting Component Tree

```
SchemaRenderer (detects input_schema in UX)
│
├── [Shared InputFormContext Provider]
│   │
│   ├── InputSchemaRenderer (renders input controls)
│   │   ├── SelectInputRenderer
│   │   ├── SliderInputRenderer
│   │   └── TextareaInputRenderer
│   │
│   └── SchemaRenderer (remaining schema, no input_schema)
│       └── MediaPanel (just grid + button, no ParameterField)
```

### Key Points

1. **SchemaRenderer** detects `input_schema` and composes both components
2. **InputSchemaRenderer** renders the inputs (not MediaPanel)
3. **MediaPanel** becomes simpler - just grid and button
4. **Shared context** enables communication without refs/callbacks

---

## Input Data Flow

### How Inputs Get Initial Values

When a field exists in BOTH:
- Normal `properties` with `display: hidden`
- `input_schema.properties`

The input gets its initial value from `data[fieldKey]`.

### Example Schema

```json
{
  "type": "object",
  "_ux": {
    "render_as": "tab.media",
    "input_schema": {
      "type": "object",
      "properties": {
        "sampler": { "_ux": { "input_type": "select" } },
        "seed": { "_ux": { "input_type": "text" } }
      }
    }
  },
  "properties": {
    "sampler": {
      "type": "string",
      "_ux": { "display": "hidden" }
    },
    "seed": {
      "type": "integer",
      "_ux": { "display": "hidden" }
    },
    "style_notes": {
      "type": "string",
      "_ux": { "display": true }
    }
  }
}
```

### Data Flow

```
data = {
  "sampler": "euler_a",
  "seed": 12345,
  "style_notes": "cinematic lighting"
}

InputSchemaRenderer receives:
- schema: input_schema
- data: { "sampler": "euler_a", "seed": 12345 }  // extracted from parent data

Each input field:
- sampler input: initial value = data["sampler"] = "euler_a"
- seed input: initial value = data["seed"] = 12345
- If no data match: uses schema.default
- If no default: empty/undefined
```

### InputSchemaRenderer Implementation

```tsx
interface InputSchemaRendererProps {
  schema: InputSchema;
  data: Record<string, unknown>;  // Parent data for initial values
  path: string[];
}

function InputSchemaRenderer({ schema, data, path }: InputSchemaRendererProps) {
  const properties = schema.properties || {};
  const ux = getUx(schema);

  // Layout configuration
  const layout = ux.layout || "grid";
  const columns = ux.layout_columns || 3;
  const columnsSm = ux.layout_columns_sm || 2;
  const gap = ux.layout_gap || 4;

  const layoutClass = layout === "grid"
    ? `grid grid-cols-${columnsSm} sm:grid-cols-${columns} gap-${gap}`
    : layout === "stack"
    ? `flex flex-col gap-${gap}`
    : `flex flex-wrap gap-${gap}`;

  return (
    <div className={layoutClass}>
      {Object.entries(properties).map(([key, fieldSchema]) => {
        const fieldUx = getUx(fieldSchema);
        const colSpan = fieldUx.col_span;

        // Get initial value: data[key] → schema.default → undefined
        const initialValue = data?.[key] ?? fieldSchema.default;

        const itemClass = colSpan === "full"
          ? "col-span-full"
          : colSpan
          ? `col-span-${colSpan}`
          : "";

        return (
          <div key={key} className={itemClass}>
            <SchemaRenderer
              schema={fieldSchema}
              data={initialValue}
              path={[...path, key]}
            />
          </div>
        );
      })}
    </div>
  );
}
```

---

## Shared Context for Validation (No Refs/Callbacks)

### Why Not Refs or Callbacks

- **Refs**: Lead to imperative patterns, harder to maintain, don't trigger re-renders
- **Callbacks**: Cause unnecessary re-renders, prop drilling issues

### Better Pattern: Shared Context

Since SchemaRenderer composes both InputSchemaRenderer and MediaPanel, it can provide a shared context that both consume.

### InputFormContext Design

```tsx
interface InputFormContextValue {
  // Values management
  values: Record<string, unknown>;
  getValue: (key: string) => unknown;
  setValue: (key: string, value: unknown) => void;

  // Validation
  errors: Record<string, string>;
  setError: (key: string, error: string) => void;
  clearError: (key: string) => void;
  clearAllErrors: () => void;

  // Form state
  isDirty: boolean;
  isValid: boolean;

  // Schema reference (for validation rules)
  inputSchema: InputSchema;
}

const InputFormContext = createContext<InputFormContextValue | null>(null);

// Hook for consuming
function useInputForm() {
  const ctx = useContext(InputFormContext);
  if (!ctx) {
    throw new Error("useInputForm must be used within InputFormProvider");
  }
  return ctx;
}

// Optional hook (returns null if no context)
function useInputFormOptional() {
  return useContext(InputFormContext);
}
```

### SchemaRenderer Enhancement

```tsx
function SchemaRenderer({ data, schema, path, ux: uxProp, children }: Props) {
  const ux = uxProp ?? getUx(schema);

  // Detect input_schema and provide shared context
  if (ux.input_schema) {
    return (
      <InputFormProvider
        inputSchema={ux.input_schema}
        initialData={data as Record<string, unknown>}
      >
        <SchemaRendererWithInputSchema
          data={data}
          schema={schema}
          path={path}
          ux={ux}
        />
      </InputFormProvider>
    );
  }

  // Continue with existing routing...
}

<!--I understand why you did this, i think you should move InputFormProvider
here so everything is contained here. I also would change this component name.
this component is not about SchemaRenderer, this is not similar to
SchemaRenderer, this is component created for clarity as extension to
SchemaRenderer--> 

function SchemaRendererWithInputSchema({ data, schema, path, ux }: Props) { // Extract data for input fields

  <!--not sure why we need an extraction, data here has to be 1:1 map for
  input_schema. there can be nodes in input_schema which are not in data, and
  vise-versa, but there shouldnt be any exteaction needed for this. any reason
  you thought to add this?-->
  
  const inputData = extractInputData(data, ux.input_schema);

  // Render InputSchemaRenderer
  const inputComponent = (
    <InputSchemaRenderer
      schema={ux.input_schema}
      data={inputData}
      path={[...path, '_inputs']}
    />
  );

  // Create UX without input_schema for remaining content
  const remainingUx = { ...ux, input_schema: undefined };

  // Handle compound render_as (e.g., tab.media)
  if (ux.render_as?.includes('.')) {
    const dotIndex = ux.render_as.indexOf('.');
    const outerRenderAs = ux.render_as.slice(0, dotIndex);
    const innerRenderAs = ux.render_as.slice(dotIndex + 1);

    // Outer wraps both input and inner content
    return (
      <SchemaRenderer
        schema={schema}
        data={data}
        path={path}
        ux={{ ...remainingUx, render_as: outerRenderAs }}
      >
        <>
          {inputComponent}
          <SchemaRenderer
            schema={schema}
            data={data}
            path={path}
            ux={{ ...remainingUx, render_as: innerRenderAs }}
          />
        </>
      </SchemaRenderer>
    );
  }

  // Simple render_as - fragment composition
  const restComponent = (
    <SchemaRenderer
      schema={schema}
      data={data}
      path={path}
      ux={remainingUx}
    />
  );

  return (
    <>
      {inputComponent}
      {restComponent}
    </>
  );
}
```

### InputFormProvider Implementation

```tsx
interface InputFormProviderProps {
  inputSchema: InputSchema;
  initialData: Record<string, unknown>;
  children: ReactNode;
}

function InputFormProvider({ inputSchema, initialData, children }: InputFormProviderProps) {
  // Initialize values from data, falling back to schema defaults
  const [values, setValues] = useState<Record<string, unknown>>(() => {
    const initial: Record<string, unknown> = {};
    const properties = inputSchema.properties || {};

    for (const [key, fieldSchema] of Object.entries(properties)) {
      initial[key] = initialData?.[key] ?? fieldSchema.default;
    }
    return initial;
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isDirty, setIsDirty] = useState(false);

  const contextValue = useMemo<InputFormContextValue>(() => ({
    values,
    getValue: (key) => values[key],
    setValue: (key, value) => {
      setValues(prev => ({ ...prev, [key]: value }));
      setIsDirty(true);
      // Clear error when value changes
      if (errors[key]) {
        setErrors(prev => {
          const { [key]: _, ...rest } = prev;
          return rest;
        });
      }
    },

    errors,
    setError: (key, error) => {
      setErrors(prev => ({ ...prev, [key]: error }));
    },
    clearError: (key) => {
      setErrors(prev => {
        const { [key]: _, ...rest } = prev;
        return rest;
      });
    },
    clearAllErrors: () => setErrors({}),

    isDirty,
    isValid: Object.keys(errors).length === 0,

    inputSchema,
  }), [values, errors, isDirty, inputSchema]);

  return (
    <InputFormContext.Provider value={contextValue}>

      <!--not sure what following children mean in this context. I see its
      passed down from SchemaRenderer, i dont think this meant to be used
      here.-->

      {children}
    </InputFormContext.Provider>
  );
}
```

### MediaPanel Using Shared Context

```tsx
function MediaPanel({ data, schema, path, ux }: Props) {
  // Access shared input form context (provided by SchemaRenderer)
  const inputForm = useInputFormOptional();

  const handleGenerate = () => {
    if (!inputForm) {
      console.warn("No input form context available");
      return;
    }

    // Validate using schema
    const validationErrors = validateInputs(inputForm.values, inputForm.inputSchema);

    if (validationErrors.length > 0) {
      validationErrors.forEach(e => inputForm.setError(e.field, e.message));
      return;
    }

    inputForm.clearAllErrors();

    // Execute generation with input values
    executeSubAction(path, action, inputForm.values, { provider, promptId });
  };

  return (
    <div className="media-panel">
      {/* MediaGrid displays generations */}
      <MediaGrid
        generations={generations}
        selectedContentId={selectedContentId}
        onSelect={onSelectContent}
      />

      {/* Generate button - validation through shared context */}
      <Button onClick={handleGenerate} disabled={loading}>
        Generate
      </Button>

      {/* Error display */}
      {/* Note: Individual field errors shown by input renderers via context */}
    </div>
  );
}
```

### Input Renderers Using Context

```tsx
function SelectInputRenderer({ schema, path, ux }: Props) {
  // Get form context
  const inputForm = useInputForm();
  const fieldKey = path[path.length - 1];

  // Get value and error from context
  const value = inputForm.getValue(fieldKey);
  const error = inputForm.errors[fieldKey];

  const handleChange = (newValue: string) => {
    inputForm.setValue(fieldKey, newValue);
  };

  return (
    <div>
      <Select value={value} onValueChange={handleChange}>
        {/* options */}
      </Select>
      {error && <span className="text-destructive text-sm">{error}</span>}
    </div>
  );
}
```

---

## Validation Flow

```
1. User edits input field
   → Input renderer calls inputForm.setValue(key, value)
   → Context updates, any existing error for that field is cleared

2. User clicks "Generate" button
   → MediaPanel calls validateInputs(inputForm.values, inputForm.inputSchema)
   → Validates required fields, type constraints, ranges, etc.

3. If validation fails:
   → MediaPanel calls inputForm.setError(field, message) for each error
   → Input renderers re-render and show errors (they read from context)

4. If validation passes:
   → MediaPanel calls executeSubAction with inputForm.values
   → Generation proceeds
```

---

## Layout System (Confirmed)

### Container Level (`input_schema._ux`)

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `layout` | `"grid" \| "flex" \| "stack"` | `"grid"` | Container layout mode |
| `layout_columns` | `number` | `3` | Grid columns (default/lg) |
| `layout_columns_sm` | `number` | `2` | Grid columns on small screens |
| `layout_gap` | `number` | `4` | Gap between items (Tailwind scale) |

### Item Level (`input_schema.properties[key]._ux`)

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `col_span` | `number \| "full"` | `1` | Columns to span in grid |
| `row_span` | `number` | `1` | Rows to span in grid |
| `order` | `number` | - | Display order override |

---

## Implementation Plan

### Phase 1: InputSchemaRenderer with Shared Context

| Step | File | Change |
|------|------|--------|
| 1 | `schema-interaction/InputFormContext.tsx` | **New** - Shared form context |
| 2 | `schema-interaction/InputSchemaRenderer.tsx` | **New** - Renders input fields with layout |
| 3 | `schema-interaction/SchemaRenderer.tsx` | Detect `input_schema`, wrap with provider, compose components |
| 4 | `schema-interaction/renderers/TerminalRenderer.tsx` | Add `input_type` routing |
| 5 | `media-generation/MediaPanel.tsx` | Remove ParameterField, use context for validation |
| 6 | `schema-interaction/types.ts` | Add layout UX types |

### Files NOT Modified

- MediaGrid.tsx - unchanged
- MediaPromptPanel.tsx - unchanged
- Existing input renderers - minimal changes (use context)

---

## Questions for Review

1. **Context naming**: `InputFormContext` vs `InputSchemaContext` vs something else?
<!--InputSchemaContext, keep it consistant with InputSchemaRenderer-->

2. **Error display location**: Should errors appear:
   - Below each input field (input renderer responsibility)
   - In a summary section (MediaPanel responsibility)
   - Both?

<!--both, input schema renderer will change the boudary of control red show
that its not valid, caller can show message saying the more detailed error-->

3. **Dirty tracking**: Is `isDirty` state needed, or can we simplify?
<!--do we have need right now to have isDirty?-->
