# Schema-Driven Media Display Architecture

## Summary

The current media generation display components (`MediaPanel`, `MediaGrid`) are tightly coupled and require code changes for every new feature (seeds, metadata panels, prompt details). This document proposes a schema-driven approach to make the display layer flexible and customizable per-provider/workflow.

---

## Problem Statement

### Current Architecture

```
Display Schemas (JSON)
    ↓
SchemaRenderer (routes by render_as)
    ↓
MediaPanel (render_as: "media")
    ├── ParameterField (custom mini-router for inputs)
    │       ↓
    │   Input Renderers (Select, Slider, Textarea)
    │
    └── MediaGrid (hardcoded grid display)
            ↓
        ContentItem (fixed shape: url, contentId, metadataId, generationIndex)
```

### Issues

1. **MediaGrid is not schema-driven**
   - `GenerationResult` type: only `urls`, `metadata_id`, `content_ids`
   - `ContentItem` in MediaGrid: fixed fields
   - No schema for what to display per image or per generation row

2. **ParameterField duplicates schema routing**
   - Custom component inside MediaPanel
   - Manually checks input_type and routes to renderers
   - Should be a generic `InputFieldRenderer` in schema-interaction

3. **Every new feature requires code changes**
   - Adding seeds: change types, change grid, change API
   - Adding metadata sidebar: change layout, change components
   - Adding prompt details: change data flow, change rendering

---

## Analysis: Input Schema Rendering Coupling

### What Already Exists (Generic, Reusable)

Input Renderers in `schema-interaction/renderers/`:
- `SelectInputRenderer` - dropdown, enum support, controlled/uncontrolled
- `SliderInputRenderer` - numeric with min/max/step
- `TextareaInputRenderer` - multiline text

These are **loosely coupled**:
- Use `useInputOptional()` - work with or without InputContext
- Accept both context-driven and prop-driven state
- Don't know anything about MediaPanel

### What MediaPanel Does (Tightly Coupled)

`ParameterField` component (lines 439-531):
```tsx
function ParameterField({ fieldKey, path, schema, ux, disabled }) {
  // Manual type checking - duplicates schema routing logic
  const isSelectType = enumData !== undefined || inputType === "select";
  if (isSelectType) {
    return <SelectInputRenderer ... />;
  }

  if (inputType === "slider" && minimum !== undefined) {
    return <SliderInputRenderer ... />;
  }

  if (inputType === "textarea") {
    return <TextareaInputRenderer ... />;
  }

  return null;
}
```

### Coupling Summary

| Component | Coupling | Issue |
|-----------|----------|-------|
| `SelectInputRenderer` | Low | Generic, reusable |
| `SliderInputRenderer` | Low | Generic, reusable |
| `TextareaInputRenderer` | Low | Generic, reusable |
| `ParameterField` | **High** | Custom router inside MediaPanel |
| Schema → Renderer mapping | **High** | Logic duplicated in ParameterField |
| Grid layout | **High** | Hardcoded columns, no schema control |

---

## Desired Capabilities

1. **Show seed on images** (Leonardo, Stable Diffusion - not MidJourney)
2. **Add metadata sidebar** to generation row (prompt, params, etc.)
3. **Customize display per provider** via schema, not code
4. **Extensible** - add new fields without component changes

---

<!-- I will stop here as this proposed solution is not goint work, at least
large picture of it. whats missing here is that, bigger picture of this
requirement, which is we need to follow existing patters and make
SchemaRenderer the router to render all components. 

first of, let most basic requirement in place. We need InputSchemaRenderer
which will render content under "input_schema" node. here onwards we assume
that this is implemented by default. We want to take advantage of
SchemaRenderer here agin  to render each input component. Discuss in detail in
the doc about how we are going to InputSchemaRenderer.

now, how can SchemaRenderer render this, in normal use case,
- SchemaRenderer -> sees input_schema -> decides that InputSchemaRenderer is
  needed -> looks normal schema, and if there's anything to render, use new
  SchemaRenderer instance to render it -> wrap both component around <></> and
  return it.
    ex: const SchemaRenderer = (schema, ...) => {
            if (schema.input_schema) {
                const isc = <InputSchemaRenderer schema={schema.input_schema} />
                const cmp = <SchemaRenderer schema={...schema, input_schema: undefined}/>
                
                if (schema.render_as like '*.*') {
                    return <fistPart>{isc}{cmp}</firstPart>
                } else {
                    return <>{isc}{cmp}</>
                }
            }
        }


if you go through example like below, you will see that we can safely cater to
    input and rest of schema using above example. one more thing to note is
    that, InputSchemaRenderer will not render the button as buttons can have
    any action, so whatver the place which it render InputSchemaRenderer. 

```
{
  "type": "object",
  "_ux.display": "passthrough",
  "properties": {
    "_ux.display": "passthrough",
    "scene_title": {
      "type": "string",
      "_ux.display": false
    },
    "key_moment": {
      "type": "string",
      "_ux.display": false
    },
    "prompts": {
      "type": "object",
      "_ux": {
        "display": "visible",
        "render_as": "tabs"
      },
      "properties": {
        "stable_diffusion": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "tab_label": "Stable Diffusion",
            "render_as": "tab.media",
            "provider": "stable_diffusion",
            "input_schema": {
              "type": "object",
              "properties": {
                "sampler_combo": {
                  "type": "string",
                  "title": "Sampler",
                  "required": true,
                  "_ux": {
                    "input_type": "select"
                  }
                },
                "resolution": {
                  "type": "string",
                  "title": "Resolution",
                  "required": true,
                  "_ux": {
                    "input_type": "select"
                  }
                },
                "vae": {
                  "type": "string",
                  "title": "VAE",
                  "_ux": {
                    "input_type": "select"
                  }
                }
              }
            }
          },
          "properties": {
            "style_notes": {
              "type": "string",
              "_ux": {
                "display": true,
                "display_label": "Style",
                "highlight": true,
                "highlight_color": "#9B59B6"
              }
            }
          }
        }
      }
    }
  }
}
```
-->

## Proposed Direction

### Phase 1: Extract Generic Input Rendering

Move `ParameterField` to `schema-interaction/InputFieldRenderer`:
- Generic schema-to-input routing
- Usable by any component, not just MediaPanel
- MediaPanel becomes thinner

### Phase 2: Schema-Driven Results Display

Add `result_display_schema` alongside `input_schema`:

```json
"_ux": {
  "render_as": "media",
  "provider": "leonardo",
  "input_schema": { ... },
  "result_display_schema": {
    "type": "generation-grid",
    "grid": {
      "item_overlay": [
        { "field": "seed", "position": "bottom-left" }
      ]
    },
    "sidebar": {
      "fields": [
        { "path": "prompt", "label": "Prompt" },
        { "path": "seed", "label": "Seed" }
      ]
    }
  }
}
```

### Phase 3: Richer Data Structure

```typescript
// Current
interface GenerationResult {
  urls: string[];
  metadata_id: string;
  content_ids: string[];
}

// Proposed
interface GenerationResult {
  content: ContentItem[];  // Already done with seed
  metadata_id: string;
  generation_metadata?: {
    prompt?: string;
    params?: Record<string, unknown>;
  };
}
```

---

## Questions for Review

1. **Phase 1 Priority**: Should we extract `InputFieldRenderer` first, or tackle the grid display schema first?

2. **Schema Location**: Should `result_display_schema` live in:
   - Display schemas (workflow-specific)
   - Provider configuration (provider-specific)
   - Both (merged at runtime)

3. **Sidebar Design**: Should the metadata sidebar be:
   - Per-generation row (shows info for that specific generation)
   - Global (shows info for selected image)
   - Both options available via schema

4. **Backward Compatibility**: Do existing workflows need to work unchanged, or can we migrate them?

---

## Files Affected

### Already Modified (This Session)
- `backend/providers/media/base.py` - ContentItem, GenerationResult
- `backend/providers/media/leonardo/provider.py` - seed extraction
- `backend/providers/media/midapi/provider.py` - seed = -1
- `backend/providers/media/stable_diffusion/provider.py` - seeds array
- `backend/worker/actors/media.py` - pass seed to storage
- `backend/worker/loop.py` - pass response to complete_task
- `backend/db/queue/task_queue.py` - response field
- `backend/db/repos/content.py` - seed parameter

### To Be Modified (Future Phases)
- `ui/webui/src/components/workflow/interactions/media-generation/types.ts`
- `ui/webui/src/components/workflow/interactions/media-generation/MediaGrid.tsx`
- `ui/webui/src/components/workflow/interactions/media-generation/MediaPanel.tsx`
- `ui/webui/src/components/workflow/interactions/schema-interaction/` (new InputFieldRenderer)
- `workflows/oms/steps/2_prompt_generation/schemas/*_display_schema.json`
