# Schema-Driven Media Display Architecture (Revision 2)

## Summary

This revision addresses operator feedback on r1. The key correction is that **SchemaRenderer must remain the central router** for all components. The architecture introduces `InputSchemaRenderer` as a specialized renderer that integrates with SchemaRenderer's existing patterns.

---

## Problem Statement

### Current Architecture

```
Display Schemas (JSON)
    ↓
SchemaRenderer (routes by render_as)
    ↓
MediaPanel (render_as: "media")
    ├── ParameterField (custom mini-router for inputs)
    │       ↓
    │   Input Renderers (Select, Slider, Textarea)
    │
    └── MediaGrid (hardcoded grid display)
            ↓
        ContentItem (fixed shape: url, contentId, metadataId, generationIndex)
```

### Issues

1. **ParameterField duplicates schema routing** - custom router inside MediaPanel instead of using SchemaRenderer
2. **MediaGrid is not schema-driven** - fixed fields, no configuration
3. **Every new feature requires code changes** - tightly coupled components

---

## Desired Capabilities

1. **Show seed on images** (Leonardo, Stable Diffusion - not MidJourney)
2. **Add metadata sidebar** to generation row (prompt, params, etc.)
3. **Customize display per provider** via schema, not code
4. **Extensible** - add new fields without component changes

---

## Proposed Architecture

### Core Principle: SchemaRenderer Remains Central Router

SchemaRenderer already handles:
- Compound `render_as` parsing (`tab.media` → recursive wrapping)
- Special renderer routing (`media`, `table`, `content-panel`)
- Type-based routing (`object`, `array`, primitives)
- Layout registry for container rendering

The solution extends this pattern rather than bypassing it.

### New Component: InputSchemaRenderer

`InputSchemaRenderer` renders the `input_schema` node found in `_ux`. It:

1. **Iterates over `input_schema.properties`** to render each input field
2. **Uses SchemaRenderer internally** for each field (with appropriate `render_as` mapping)
3. **Does NOT render buttons** - buttons have varied actions, so the parent handles them
4. **Returns a fragment** of rendered input components

```tsx
// Conceptual implementation
function InputSchemaRenderer({ schema, path }: { schema: InputSchema; path: string[] }) {
  const properties = schema.properties || {};

  return (
    <>
      {Object.entries(properties).map(([key, fieldSchema]) => (
        <SchemaRenderer
          key={key}
          schema={fieldSchema}
          path={[...path, key]}
          // SchemaRenderer routes based on _ux.input_type
        />
      ))}
    </>
  );
}
```

<!--I think one big question to answer is how are we going to define layout for
inputs. I think we currently hrdcode layout/positioning in media components
which is not going to work here. can you give me proposal on how we can addres
this?-->

### SchemaRenderer Enhancement

When SchemaRenderer encounters `input_schema` in the UX config, it:

1. Renders `InputSchemaRenderer` for the `input_schema`
2. Renders a new `SchemaRenderer` for the remaining schema (with `input_schema` removed)
3. Combines both, with wrapping based on `render_as` pattern

```tsx
const SchemaRenderer = ({ schema, path, ux, children }) => {
  const extractedUx = ux ?? getUx(schema);

  // Handle input_schema if present
  if (extractedUx.input_schema) {
    const inputComponent = (
      <InputSchemaRenderer
        schema={extractedUx.input_schema}
        path={[...path, 'inputs']}
      />
    );

    // Create schema without input_schema for remaining content
    <!--you need to extract inner commenent for *.* case, there's implmentation for that in SchemaRenderer.-->
    const remainingUx = { ...extractedUx, input_schema: undefined };
    const restComponent = (
      <SchemaRenderer
        schema={schema}
        path={path}
        ux={remainingUx}
      />
    );

    // Compound render_as (e.g., tab.media) - wrap in outer layout
    if (extractedUx.render_as?.includes('.')) {
      const [outer] = extractedUx.render_as.split('.');
      const Layout = getLayout(outer);
      return (
        <Layout>
          {inputComponent}
          {restComponent}
        </Layout>
      );
    }

    // Simple render_as - fragment composition
    return (
      <>
        {inputComponent}
        {restComponent}
      </>
    );
  }

  // Continue with existing routing logic...
};
```

### Input Type → Renderer Mapping

SchemaRenderer needs to route input types to the existing renderers:

| `_ux.input_type` | Renderer | Notes |
|------------------|----------|-------|
| `select` | `SelectInputRenderer` | Dropdown, enum support |
| `slider` | `SliderInputRenderer` | Numeric with min/max/step |
| `textarea` | `TextareaInputRenderer` | Multiline text |
| `text` | `TextInputRenderer` | Single-line text (new) |
| `checkbox` | `CheckboxInputRenderer` | Boolean toggle (future) |

This can be added to the special renderer priority in SchemaRenderer, or registered as a new category in the layout registry.

---

## Schema Example Walkthrough

Given this display schema:

```json
{
  "type": "object",
  "_ux": {
    "display": "passthrough"
  },
  "properties": {
    "prompts": {
      "type": "object",
      "_ux": {
        "display": "visible",
        "render_as": "tabs"
      },
      "properties": {
        "stable_diffusion": {
          "type": "object",
          "_ux": {
            "display": "visible",
            "tab_label": "Stable Diffusion",
            "render_as": "tab.media",
            "provider": "stable_diffusion",
            "input_schema": {
              "type": "object",
              "properties": {
                "sampler_combo": {
                  "type": "string",
                  "title": "Sampler",
                  "_ux": { "input_type": "select" }
                },
                "resolution": {
                  "type": "string",
                  "title": "Resolution",
                  "_ux": { "input_type": "select" }
                },
                "vae": {
                  "type": "string",
                  "title": "VAE",
                  "_ux": { "input_type": "select" }
                }
              }
            }
          },
          "properties": {
            "style_notes": {
              "type": "string",
              "_ux": {
                "display": true,
                "display_label": "Style",
                "highlight": true,
                "highlight_color": "#9B59B6"
              }
            }
          }
        }
      }
    }
  }
}
```

### Rendering Flow

```
1. Root SchemaRenderer
   └── display: passthrough → render children directly

2. prompts → SchemaRenderer
   └── render_as: tabs → TabsLayout
       └── provides TabsContext

3. stable_diffusion → SchemaRenderer
   └── render_as: tab.media (compound)
   └── input_schema present

   3a. Split compound: outer="tab", inner="media"

   3b. TabLayout wraps everything (registers tab with label "Stable Diffusion")
       └── Receives children:

           3c. InputSchemaRenderer (for input_schema)
               ├── sampler_combo → SchemaRenderer → SelectInputRenderer
               ├── resolution → SchemaRenderer → SelectInputRenderer
               └── vae → SchemaRenderer → SelectInputRenderer

           3d. SchemaRenderer (for remaining schema, render_as: "media")
               └── MediaPanel
                   ├── MediaGrid (displays generations)
                   └── Generate button (handled by MediaPanel, NOT InputSchemaRenderer)

4. style_notes inside stable_diffusion.properties
   └── SchemaRenderer → TerminalRenderer with highlight styling
```

### Key Points

1. **TabLayout** handles tab registration and visibility
2. **InputSchemaRenderer** renders the three select inputs (sampler, resolution, vae)
3. **MediaPanel** receives the remaining schema without `input_schema`
4. **Button** is rendered by MediaPanel, not InputSchemaRenderer
5. **style_notes** in `properties` is rendered as highlighted text display

---

## Phase 1: InputSchemaRenderer Implementation

### Step 1: Create InputSchemaRenderer Component

Location: `ui/webui/src/components/workflow/interactions/schema-interaction/InputSchemaRenderer.tsx`

Responsibilities:
- Iterate over `input_schema.properties`
- Call SchemaRenderer for each field
- Provide InputContext for value management
- NOT render buttons

### Step 2: Add Input Type Routing to SchemaRenderer

Modify SchemaRenderer to recognize `_ux.input_type` and route to appropriate input renderer:
<!--following should be in TerminalRenderer as this are native end nodes. -->
```tsx
// In SchemaRenderer, add after special renderer checks:
if (ux.input_type) {
  switch (ux.input_type) {
    case 'select':
      return <SelectInputRenderer schema={schema} path={path} ux={ux} />;
    case 'slider':
      return <SliderInputRenderer schema={schema} path={path} ux={ux} />;
    case 'textarea':
      return <TextareaInputRenderer schema={schema} path={path} ux={ux} />;
    default:
      return <TextInputRenderer schema={schema} path={path} ux={ux} />;
  }
}
```

### Step 3: Handle input_schema in SchemaRenderer

Add logic to detect `input_schema` and compose InputSchemaRenderer with remaining schema rendering.

### Step 4: Refactor MediaPanel

- Remove `ParameterField` component
- Rely on InputSchemaRenderer for input rendering
- Keep button rendering in MediaPanel
- Keep MediaGrid for generation display

---

## Phase 2: Schema-Driven Results Display

After Phase 1, MediaPanel will be thinner. Phase 2 adds schema-driven control over MediaGrid:

```json
"_ux": {
  "render_as": "tab.media",
  "provider": "stable_diffusion",
  "input_schema": { ... },
  "result_display": {
    "grid": {
      "overlay": [
        { "field": "seed", "position": "bottom-left", "visible_when": "seed != -1" }
      ]
    },
    "sidebar": {
      "fields": [
        { "path": "prompt", "label": "Prompt" },
        { "path": "seed", "label": "Seed" }
      ]
    }
  }
}
```

---

## Files Affected

### Phase 1 (InputSchemaRenderer)

| File | Change |
|------|--------|
| `schema-interaction/InputSchemaRenderer.tsx` | **New** - Input schema renderer |
| `schema-interaction/SchemaRenderer.tsx` | Add input_schema handling, input_type routing |
| `media-generation/MediaPanel.tsx` | Remove ParameterField, use InputSchemaRenderer |

### Phase 2 (Result Display)

| File | Change |
|------|--------|
| `media-generation/MediaGrid.tsx` | Accept display schema for overlays/sidebar |
| `media-generation/types.ts` | Add result_display types |

---

## Questions for Review

1. **InputContext Integration**: Should InputSchemaRenderer create its own InputContext, or receive one from parent (MediaPanel)?
<!--it should on InputSchemaRender as its managees all inputs, question is, how parent retrive/manage validation for input?-->

2. **Button Placement**: Should MediaPanel always render the generate button, or should there be a `_ux.actions` schema for button configuration?
<!--lets not touch anything else in media components, lets fix input_schema first and then we'll address other issues.-->

3. **Backward Compatibility**: Should existing `render_as: "media"` schemas work unchanged (InputSchemaRenderer activated only when `input_schema` is present)?
<!--no backwards compatibility-->
