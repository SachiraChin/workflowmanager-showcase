# Virtual Server Separation Architecture

## Summary

Separate virtual endpoints from `backend/server` into a standalone 
`backend/virtual-server` package. Extract shared code to `backend/shared`. 
This eliminates route collision risks, enables independent deployment, and 
provides resource isolation between production API and editor preview.

## Current State

### Problems
1. **Route collision**: Virtual routes must be registered before streaming 
   routes due to `/{workflow_run_id}/sub-action` matching `/virtual/sub-action`
2. **Shared resources**: Editor preview traffic competes with production
3. **Deployment coupling**: Any virtual endpoint change requires full API 
   redeploy
4. **Code entanglement**: Virtual routes live inside `backend/server/api/routes`

### Current Structure
```
backend/
├── server/
│   ├── api/
│   │   ├── app.py              # Mounts ALL routers including virtual
│   │   └── routes/
│   │       ├── virtual.py      # Virtual endpoints (~943 lines)
│   │       ├── execution.py    # Production endpoints
│   │       └── ...
│   └── ...
├── db/
│   ├── database.py             # Production Database class
│   └── virtual.py              # VirtualDatabase class
└── providers/
    └── ...
```

## Proposed Structure

```
backend/
├── shared/                     # NEW: Extracted shared code
│   ├── __init__.py
│   ├── db/
│   │   ├── __init__.py
│   │   ├── database.py         # Moved from backend/db/
│   │   └── virtual.py          # Moved from backend/db/
│   ├── providers/              # Moved from backend/providers/
│   │   └── ...
│   └── workflow/               # If WorkflowProcessor needs sharing
│       └── ...
│
├── server/                     # Production API only
│   ├── api/
│   │   ├── app.py              # NO virtual_router
│   │   └── routes/
│   │       ├── execution.py
│   │       ├── streaming.py
│   │       └── ...             # NO virtual.py
│   ├── Dockerfile
│   └── requirements.txt
│
└── virtual-server/             # NEW: Virtual API only
    ├── api/
    │   ├── app.py              # FastAPI app for virtual endpoints
    │   └── routes/
    │       └── virtual.py      # Moved from server/api/routes/
    ├── Dockerfile
    └── requirements.txt
```

## Technical Specification

### 1. Shared Package (`backend/shared/`)

<!--I dont agree on moving db and providers to shared. its clean have them
where they are and is easy to navigate to. i think what we should do instead
is, create new package "workflow_engine", which simply contains workflow
engine. if you look at files which needs to be moveed out of server, it is
literally workflow engine. this simply convey what it is and does not require
additional navigation. even though we have "shared" folders, i personally do
not like the term simply because it does not give any idea about what it
contains. -->

Extracted modules that both servers need:

| Module | Description |
|--------|-------------|
| `shared.db.database` | `Database` class for MongoDB operations |
| `shared.db.virtual` | `VirtualDatabase` class, `VIRTUAL_USER_ID` |
| `shared.providers.*` | Media providers, AI providers |

Import changes example:
```python
# Before (in virtual.py)
from backend.db.virtual import VirtualDatabase, VIRTUAL_USER_ID

# After
from backend.shared.db.virtual import VirtualDatabase, VIRTUAL_USER_ID
```

### 2. Production Server (`backend/server/`)

Remove virtual endpoint registration:

```python
# app.py - REMOVE these lines:
# from .routes import virtual_router
# app.include_router(virtual_router)

# REMOVE the route ordering comment about virtual
```

The streaming router's `/{workflow_run_id}/sub-action` no longer conflicts 
because there's no `/virtual/sub-action` in this server.

### 3. Virtual Server (`backend/virtual-server/`)

Standalone FastAPI application:

```python
# backend/virtual-server/api/app.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .routes.virtual import router as virtual_router

app = FastAPI(
    title="Virtual Workflow API",
    description="Endpoints for editor preview mode",
    version="1.0.0"
)

# CORS for editor origin
app.add_middleware(CORSMiddleware, ...)

# Single router - no prefix needed, virtual.py already has /workflow/virtual
app.include_router(virtual_router)

@app.get("/health")
async def health():
    return {"status": "healthy", "service": "virtual"}
```

### 4. URL Configuration

#### Production
```
api.randomsitein.space/              → backend/server (port 9000)
virtual.randomsitein.space/          → backend/virtual-server (port 9001)
```

#### Development
```
localhost:9000  → backend/server
localhost:9001  → backend/virtual-server
```

### 5. Editor Configuration

Add new environment variable:

```typescript
// ui/shared/src/core/config.ts
export const VIRTUAL_API_URL = import.meta.env.VITE_VIRTUAL_API_URL 
  ?? (isProduction 
    ? 'https://virtual.randomsitein.space' 
    : 'http://localhost:9001');
```

Update virtual-api.ts to use `VIRTUAL_API_URL`:

```typescript
// ui/editor/src/runtime/virtual-api.ts
import { VIRTUAL_API_URL } from '@wfm/shared';

export async function virtualStart(...) {
  // Use VIRTUAL_API_URL instead of API_URL
  return fetchResponse<VirtualStartResponse>(
    `${VIRTUAL_API_URL}/workflow/virtual/start`,
    ...
  );
}
```

### 6. Docker Compose

```yaml
# deploy/docker-compose.yml
services:
  api:
    build:
      context: ..
      dockerfile: backend/server/Dockerfile
    ports:
      - "9000:9000"
    environment:
      - MONGODB_URI=mongodb://mongo:27017
      - MONGODB_DATABASE=workflow_db

  virtual-api:
    build:
      context: ..
      dockerfile: backend/virtual-server/Dockerfile
    ports:
      - "9001:9001"
    environment:
      - MONGODB_VIRTUAL_URI=mongodb://mongo-virtual:27017
    depends_on:
      - mongo-virtual

  mongo:
    image: mongo:7
    volumes:
      - mongo-data:/data/db

  mongo-virtual:
    image: mongo:7
    # No persistent volume - ephemeral
```

### 7. Nginx Configuration

```nginx
# virtual.randomsitein.space
server {
    listen 443 ssl;
    server_name virtual.randomsitein.space;
    
    ssl_certificate /etc/letsencrypt/live/randomsitein.space/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/randomsitein.space/privkey.pem;
    
    location / {
        proxy_pass http://virtual-api:9001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # SSE support
        proxy_buffering off;
        proxy_cache off;
    }
}
```

## Migration Steps

### Phase 1: Extract Shared Code
1. Create `backend/shared/` directory structure
2. Move `backend/db/` to `backend/shared/db/`
3. Move `backend/providers/` to `backend/shared/providers/`
4. Update all imports in `backend/server/`
5. Verify server still works

### Phase 2: Create Virtual Server
1. Create `backend/virtual-server/` structure
2. Copy `virtual.py` to `backend/virtual-server/api/routes/`
3. Create `app.py` for virtual server
4. Update imports to use `backend.shared.*`
5. Create Dockerfile for virtual server

### Phase 3: Remove Virtual from Main Server
1. Remove `virtual_router` import and registration from `app.py`
2. Delete `backend/server/api/routes/virtual.py`
3. Remove route ordering comments

### Phase 4: Update Editor
1. Add `VITE_VIRTUAL_API_URL` to environment configs
2. Update `virtual-api.ts` to use new URL
3. Update `ui/shared/src/core/config.ts`

### Phase 5: Deploy
1. Update docker-compose.yml
2. Add nginx configuration for virtual subdomain
3. Deploy both services

## Development Workflow

### Running Locally

```bash
# Terminal 1: Main API
cd backend/server
uvicorn api.app:app --port 9000 --reload

# Terminal 2: Virtual API  
cd backend/virtual-server
uvicorn api.app:app --port 9001 --reload

# Terminal 3: Editor
cd ui/editor
VITE_VIRTUAL_API_URL=http://localhost:9001 npm run dev
```

Or with a combined script:

```bash
# scripts/dev.sh
#!/bin/bash
trap 'kill 0' EXIT

(cd backend/server && uvicorn api.app:app --port 9000 --reload) &
(cd backend/virtual-server && uvicorn api.app:app --port 9001 --reload) &
(cd ui/editor && npm run dev) &

wait
```

## Questions for Review

1. Should `workflow/` (WorkflowProcessor) be moved to `shared/` or kept in 
   `server/` with virtual-server importing from server?

   <!--no, virtual server should not import anything from server. idea is
   server/worker/virtual_server should not read anything from each other. if
   something has to be read, it is in wrong place-->
   
2. The `models/` package is imported by both servers. Should it also move 
   to `shared/`?

   <!-- yes, with previous instructions -->

3. Current virtual endpoints require authentication (`get_current_user_id`). 
   Should virtual-server have its own auth or share with main server?

   <!--yes but they share same db-->

4. Should we keep the `/workflow/virtual` prefix in virtual-server, or 
   simplify to `/virtual/*` or just `/*` since it's a dedicated server?

   <!--it depends i geuess, i can make virtual.arandomsitein.space, in that
   case *virtual* doesnt make sense, since we are hosting debug on differnt
   port, lets use /workflow/* which is normal endpoint struture. then we can
   map virtual endpoint 1:1 with server when needed-->

5. For the `utils/` package - move to shared or duplicate?

    <!--i dont think there's much and worker also duplicate this, lets do that
    for this. share should be virtual specific utils, those can be moved to
        virtual if applicable.-->
