# Virtual Server Separation Architecture (Revision 2)

## Summary

Separate virtual endpoints from `backend/server` into a standalone 
`backend/virtual-server` package. Create a new `workflow_engine/` package 
containing the core workflow execution logic that both servers need. This 
eliminates route collision risks, enables independent deployment, and provides 
resource isolation between production API and editor preview.

## Design Principles

1. **No cross-imports**: `server/`, `worker/`, and `virtual-server/` must never 
   import from each other. If something needs to be shared, it belongs in a 
   shared package.

2. **Semantic naming**: Use `workflow_engine/` instead of generic `shared/` - 
   the name describes what it contains.

3. **Minimal movement**: Keep `db/` and `providers/` where they are. Only move 
   what's truly engine-specific.

4. **1:1 endpoint mapping**: Virtual server uses `/workflow/*` prefix (same as 
   production) for easy mental mapping.

## Current State

### Problems
1. **Route collision**: Virtual routes must be registered before streaming 
   routes due to `/{workflow_run_id}/sub-action` matching `/virtual/sub-action`
2. **Shared resources**: Editor preview traffic competes with production
3. **Deployment coupling**: Any virtual endpoint change requires full API 
   redeploy
4. **Code entanglement**: Virtual routes live inside `backend/server/api/routes`

### Current Structure
```
backend/
├── server/
│   ├── api/
│   │   ├── app.py              # Mounts ALL routers including virtual
│   │   └── routes/
│   │       ├── virtual.py      # Virtual endpoints (~943 lines)
│   │       ├── execution.py    # Production endpoints
│   │       └── ...
│   └── ...
├── db/
│   ├── database.py             # Production Database class
│   └── virtual.py              # VirtualDatabase class
├── providers/
│   └── ...
├── workflow/                   # WorkflowProcessor lives here
│   └── ...
└── models/                     # Pydantic models
    └── ...
```

## Proposed Structure

```
backend/
├── workflow_engine/            # NEW: Core workflow execution logic
│   ├── __init__.py

    <!--lets not bring processor to root, lets keep current structure as is
    initially, and focus on proper integration. all files in /server/workflow
    are criticl to workflow run, and all them combined make the workflow
    engine. i dont want to bring all to root, so, lets keep them as is. im okay
    with renaming workflow -> execution-->

│   ├── processor.py            # WorkflowProcessor (moved from workflow/)
│   ├── models/                 # Pydantic models (moved from models/)
│   │   └── ...
│   └── ...                     # Other workflow-specific modules
│
├── db/                         # UNCHANGED - stays here
│   ├── database.py
│   └── virtual.py
│
├── providers/                  # UNCHANGED - stays here
│   └── ...
│
├── server/                     # Production API only
│   ├── api/
│   │   ├── app.py              # NO virtual_router
│   │   └── routes/
│   │       ├── execution.py
│   │       ├── streaming.py
│   │       └── ...             # NO virtual.py
│   ├── utils/                  # Server-specific utils (duplicated)
│   ├── Dockerfile
│   └── requirements.txt
│
├── worker/                     # UNCHANGED - existing structure
│   └── ...
│
└── virtual-server/             # NEW: Virtual API only
    ├── api/
    │   ├── app.py              # FastAPI app
    │   ├── auth.py             # Auth (reads same user DB as server)
    │   └── routes/
    │       └── workflow.py     # Virtual endpoints (prefix: /workflow)
    ├── utils/                  # Virtual-specific utils (duplicated)
    ├── Dockerfile
    └── requirements.txt
```

## Technical Specification

### 1. Workflow Engine Package (`backend/workflow_engine/`)

Contains the core execution logic shared by all consumers:

| Module | Description |
|--------|-------------|
| `workflow_engine.processor` | `WorkflowProcessor` class |
| `workflow_engine.models.*` | All Pydantic models |
| `workflow_engine.execution` | Execution logic |
| `workflow_engine.context` | Context management |

Both `server/` and `virtual-server/` import from `workflow_engine/`:

```python
# In backend/server/api/routes/execution.py
from workflow_engine import WorkflowProcessor
from workflow_engine.models import WorkflowResponse, ExecutionTarget

# In backend/virtual-server/api/routes/workflow.py
from workflow_engine import WorkflowProcessor
from workflow_engine.models import VirtualWorkflowResponse
```

### 2. Database and Providers (No Change)

`backend/db/` and `backend/providers/` stay where they are. Both servers 
import from them directly:

```python
# Both servers use:
from backend.db import Database
from backend.db.virtual import VirtualDatabase
from backend.providers.media import MediaProviderRegistry
```

### 3. Production Server (`backend/server/`)

Remove virtual endpoint registration:

```python
# app.py - REMOVE these lines:
# from .routes import virtual_router
# app.include_router(virtual_router)

# REMOVE the route ordering comment about virtual
```

The streaming router's `/{workflow_run_id}/sub-action` no longer conflicts 
because there's no `/virtual/sub-action` in this server.

### 4. Virtual Server (`backend/virtual-server/`)

Standalone FastAPI application with `/workflow/*` prefix (mirrors production):

```python
# backend/virtual-server/api/app.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .routes.workflow import router as workflow_router

app = FastAPI(
    title="Virtual Workflow API",
    description="Endpoints for editor preview mode",
    version="1.0.0"
)

app.add_middleware(CORSMiddleware, ...)

# /workflow/* prefix - mirrors production endpoint structure
app.include_router(workflow_router)

@app.get("/health")
async def health():
    return {"status": "healthy", "service": "virtual"}
```

Virtual endpoints use `/workflow/*` prefix (not `/workflow/virtual/*`):

| Current (in server) | New (in virtual-server) |
|---------------------|-------------------------|
| `/workflow/virtual/start` | `/workflow/start` |
| `/workflow/virtual/respond` | `/workflow/respond` |
| `/workflow/virtual/sub-action` | `/workflow/sub-action` |
| `/workflow/virtual/state` | `/workflow/state` |
| `/workflow/virtual/generations` | `/workflow/generations` |

### 5. Authentication

Virtual server has its own auth module but reads from the same user database:

```python
# backend/virtual-server/api/auth.py
from backend.db import Database

# Connects to same MongoDB as production server
# Reads user records for authentication
# Does NOT write to production collections

async def get_current_user_id(request: Request) -> str:
    # Same JWT/cookie validation logic as server
    # Reads from shared user database
    ...
```

Environment config:
```
# virtual-server uses same auth DB as server
MONGODB_URI=mongodb://mongo:27017          # For auth (shared)
MONGODB_VIRTUAL_URI=mongodb://mongo-virtual:27017  # For virtual execution
```

### 6. Utils Duplication

Like `worker/`, `virtual-server/` duplicates needed utils:

```
backend/
├── server/utils/           # Server-specific utils
├── worker/utils/           # Worker-specific utils (existing)
└── virtual-server/utils/   # Virtual-specific utils
```

Any virtual-specific utils currently in `server/` move to `virtual-server/`.

### 7. URL Configuration

#### Production
```
api.randomsitein.space/              → backend/server (port 9000)
virtual.randomsitein.space/          → backend/virtual-server (port 9001)
```

#### Development
```
localhost:9000  → backend/server
localhost:9001  → backend/virtual-server
```

### 8. Editor Configuration

Add new environment variable:

```typescript
// ui/shared/src/core/config.ts
export const VIRTUAL_API_URL = import.meta.env.VITE_VIRTUAL_API_URL 
  ?? (isProduction 
    ? 'https://virtual.randomsitein.space' 
    : 'http://localhost:9001');
```

Update virtual-api.ts to use `VIRTUAL_API_URL` and new paths:

```typescript
// ui/editor/src/runtime/virtual-api.ts
import { VIRTUAL_API_URL } from '@wfm/shared';

export async function virtualStart(...) {
  // New path: /workflow/start (not /workflow/virtual/start)
  return fetchResponse<VirtualStartResponse>(
    `${VIRTUAL_API_URL}/workflow/start`,
    ...
  );
}
```

### 9. Docker Compose

```yaml
# deploy/docker-compose.yml
services:
  api:
    build:
      context: ..
      dockerfile: backend/server/Dockerfile
    ports:
      - "9000:9000"
    environment:
      - MONGODB_URI=mongodb://mongo:27017
      - MONGODB_DATABASE=workflow_db

  virtual-api:
    build:
      context: ..
      dockerfile: backend/virtual-server/Dockerfile
    ports:
      - "9001:9001"
    environment:
      - MONGODB_URI=mongodb://mongo:27017        # Auth DB (shared)
      - MONGODB_VIRTUAL_URI=mongodb://mongo-virtual:27017  # Virtual exec
    depends_on:
      - mongo
      - mongo-virtual

  mongo:
    image: mongo:7
    volumes:
      - mongo-data:/data/db

  mongo-virtual:
    image: mongo:7
    # No persistent volume - ephemeral
```

### 10. Nginx Configuration

```nginx
# virtual.randomsitein.space
server {
    listen 443 ssl;
    server_name virtual.randomsitein.space;
    
    ssl_certificate /etc/letsencrypt/live/randomsitein.space/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/randomsitein.space/privkey.pem;
    
    location / {
        proxy_pass http://virtual-api:9001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # SSE support
        proxy_buffering off;
        proxy_cache off;
    }
}
```

## Migration Steps

### Phase 1: Create Workflow Engine Package
1. Create `backend/workflow_engine/` directory
2. Move `workflow/` contents to `workflow_engine/`
3. Move `models/` to `workflow_engine/models/`
4. Update imports in `backend/server/` to use `workflow_engine`
5. Update imports in `backend/worker/` to use `workflow_engine`
6. Verify both server and worker still work

### Phase 2: Create Virtual Server
1. Create `backend/virtual-server/` structure
2. Create `api/app.py` with FastAPI setup
3. Create `api/auth.py` for authentication
4. Create `api/routes/workflow.py` from current `virtual.py`:
   - Copy logic from `server/api/routes/virtual.py`
   - Change prefix from `/workflow/virtual` to `/workflow`
   - Update imports to use `workflow_engine`
5. Copy needed utils to `virtual-server/utils/`
6. Create Dockerfile

### Phase 3: Remove Virtual from Main Server
1. Remove `virtual_router` import and registration from `app.py`
2. Delete `backend/server/api/routes/virtual.py`
3. Remove route ordering comments
4. Remove virtual-specific utils from `server/utils/`

### Phase 4: Update Editor
1. Add `VITE_VIRTUAL_API_URL` to environment configs
2. Update `virtual-api.ts`:
   - Use `VIRTUAL_API_URL` instead of `API_URL`
   - Change paths from `/workflow/virtual/*` to `/workflow/*`
3. Update `ui/shared/src/core/config.ts`

### Phase 5: Deploy
1. Update docker-compose.yml
2. Add nginx configuration for virtual subdomain
3. Deploy both services
4. Update DNS for `virtual.randomsitein.space`

## Development Workflow

### Running Locally

```bash
# Terminal 1: Main API
cd backend/server
uvicorn api.app:app --port 9000 --reload

# Terminal 2: Virtual API  
cd backend/virtual-server
uvicorn api.app:app --port 9001 --reload

# Terminal 3: Editor
cd ui/editor
VITE_VIRTUAL_API_URL=http://localhost:9001 npm run dev
```

Or with a combined script:

```bash
# scripts/dev.sh
#!/bin/bash
trap 'kill 0' EXIT

(cd backend/server && uvicorn api.app:app --port 9000 --reload) &
(cd backend/virtual-server && uvicorn api.app:app --port 9001 --reload) &
(cd ui/editor && npm run dev) &

wait
```

## Import Dependency Diagram
<!--i dont think following is correct-->

```
                    ┌─────────────────┐
                    │ workflow_engine │
                    │  - processor    │
                    │  - models       │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
        ┌─────────┐   ┌───────────┐   ┌────────────────┐
        │ server  │   │  worker   │   │ virtual-server │
        └────┬────┘   └─────┬─────┘   └───────┬────────┘
             │              │                 │
             │              │                 │
             └──────────────┼─────────────────┘
                            │
              ┌─────────────┴─────────────┐
              │                           │
              ▼                           ▼
        ┌──────────┐               ┌─────────────┐
        │ backend/ │               │  backend/   │
        │   db/    │               │  providers/ │
        └──────────┘               └─────────────┘

    ✗ server ←→ worker ←→ virtual-server (NO cross-imports)
```

## Questions Resolved

| Question | Resolution |
|----------|------------|
| Where to put WorkflowProcessor? | `workflow_engine/` package |
| Where to put models? | `workflow_engine/models/` |
| Auth sharing? | Same DB, separate auth module per server |
| URL prefix? | `/workflow/*` (mirrors production) |
| Utils? | Duplicate per server (like worker does) |

<!-- one thing i forgot to mention, all files muust be moved via git mv -->
